// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base_gcmessages.proto

#include "base_gcmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CGCStorePurchaseInit_LineItem::CGCStorePurchaseInit_LineItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_id_)*/0u
  , /*decltype(_impl_.quantity_)*/0u
  , /*decltype(_impl_.cost_in_local_currency_)*/0u
  , /*decltype(_impl_.purchase_type_)*/0u
  , /*decltype(_impl_.supplemental_data_)*/uint64_t{0u}} {}
struct CGCStorePurchaseInit_LineItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCStorePurchaseInit_LineItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCStorePurchaseInit_LineItemDefaultTypeInternal() {}
  union {
    CGCStorePurchaseInit_LineItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCStorePurchaseInit_LineItemDefaultTypeInternal _CGCStorePurchaseInit_LineItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseInit::CMsgGCStorePurchaseInit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.line_items_)*/{}
  , /*decltype(_impl_.country_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_.currency_)*/0} {}
struct CMsgGCStorePurchaseInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseInitDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseInitDefaultTypeInternal _CMsgGCStorePurchaseInit_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseInitResponse::CMsgGCStorePurchaseInitResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_ids_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_id_)*/uint64_t{0u}
  , /*decltype(_impl_.result_)*/0} {}
struct CMsgGCStorePurchaseInitResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseInitResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseInitResponseDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseInitResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseInitResponseDefaultTypeInternal _CMsgGCStorePurchaseInitResponse_default_instance_;
PROTOBUF_CONSTEXPR CSOPartyInvite::CSOPartyInvite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/uint64_t{0u}
  , /*decltype(_impl_.sender_id_)*/uint64_t{0u}} {}
struct CSOPartyInviteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOPartyInviteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOPartyInviteDefaultTypeInternal() {}
  union {
    CSOPartyInvite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOPartyInviteDefaultTypeInternal _CSOPartyInvite_default_instance_;
PROTOBUF_CONSTEXPR CSOLobbyInvite::CSOLobbyInvite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/uint64_t{0u}
  , /*decltype(_impl_.sender_id_)*/uint64_t{0u}} {}
struct CSOLobbyInviteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOLobbyInviteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOLobbyInviteDefaultTypeInternal() {}
  union {
    CSOLobbyInvite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOLobbyInviteDefaultTypeInternal _CSOLobbyInvite_default_instance_;
PROTOBUF_CONSTEXPR CMsgSystemBroadcast::CMsgSystemBroadcast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgSystemBroadcastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSystemBroadcastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSystemBroadcastDefaultTypeInternal() {}
  union {
    CMsgSystemBroadcast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSystemBroadcastDefaultTypeInternal _CMsgSystemBroadcast_default_instance_;
PROTOBUF_CONSTEXPR CMsgInviteToParty::CMsgInviteToParty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.client_version_)*/0u
  , /*decltype(_impl_.team_invite_)*/0u} {}
struct CMsgInviteToPartyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgInviteToPartyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgInviteToPartyDefaultTypeInternal() {}
  union {
    CMsgInviteToParty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgInviteToPartyDefaultTypeInternal _CMsgInviteToParty_default_instance_;
PROTOBUF_CONSTEXPR CMsgInvitationCreated::CMsgInvitationCreated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_id_)*/uint64_t{0u}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}} {}
struct CMsgInvitationCreatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgInvitationCreatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgInvitationCreatedDefaultTypeInternal() {}
  union {
    CMsgInvitationCreated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgInvitationCreatedDefaultTypeInternal _CMsgInvitationCreated_default_instance_;
PROTOBUF_CONSTEXPR CMsgPartyInviteResponse::CMsgPartyInviteResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.party_id_)*/uint64_t{0u}
  , /*decltype(_impl_.accept_)*/false
  , /*decltype(_impl_.client_version_)*/0u
  , /*decltype(_impl_.team_invite_)*/0u} {}
struct CMsgPartyInviteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPartyInviteResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPartyInviteResponseDefaultTypeInternal() {}
  union {
    CMsgPartyInviteResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPartyInviteResponseDefaultTypeInternal _CMsgPartyInviteResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgKickFromParty::CMsgKickFromParty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}} {}
struct CMsgKickFromPartyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgKickFromPartyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgKickFromPartyDefaultTypeInternal() {}
  union {
    CMsgKickFromParty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgKickFromPartyDefaultTypeInternal _CMsgKickFromParty_default_instance_;
PROTOBUF_CONSTEXPR CMsgLeaveParty::CMsgLeaveParty(
    ::_pbi::ConstantInitialized) {}
struct CMsgLeavePartyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLeavePartyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLeavePartyDefaultTypeInternal() {}
  union {
    CMsgLeaveParty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLeavePartyDefaultTypeInternal _CMsgLeaveParty_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerAvailable::CMsgServerAvailable(
    ::_pbi::ConstantInitialized) {}
struct CMsgServerAvailableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerAvailableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerAvailableDefaultTypeInternal() {}
  union {
    CMsgServerAvailable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerAvailableDefaultTypeInternal _CMsgServerAvailable_default_instance_;
PROTOBUF_CONSTEXPR CMsgLANServerAvailable::CMsgLANServerAvailable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lobby_id_)*/uint64_t{0u}} {}
struct CMsgLANServerAvailableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLANServerAvailableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLANServerAvailableDefaultTypeInternal() {}
  union {
    CMsgLANServerAvailable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLANServerAvailableDefaultTypeInternal _CMsgLANServerAvailable_default_instance_;
PROTOBUF_CONSTEXPR CSOEconGameAccountClient::CSOEconGameAccountClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.additional_backpack_slots_)*/0u
  , /*decltype(_impl_.trade_ban_expiration_)*/0u
  , /*decltype(_impl_.bonus_xp_timestamp_refresh_)*/0u
  , /*decltype(_impl_.bonus_xp_usedflags_)*/0u
  , /*decltype(_impl_.elevated_state_)*/0u
  , /*decltype(_impl_.elevated_timestamp_)*/0u} {}
struct CSOEconGameAccountClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconGameAccountClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconGameAccountClientDefaultTypeInternal() {}
  union {
    CSOEconGameAccountClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconGameAccountClientDefaultTypeInternal _CSOEconGameAccountClient_default_instance_;
PROTOBUF_CONSTEXPR CSOItemCriteriaCondition::CSOItemCriteriaCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.field_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.string_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.required_)*/false
  , /*decltype(_impl_.float_value_)*/0} {}
struct CSOItemCriteriaConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOItemCriteriaConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOItemCriteriaConditionDefaultTypeInternal() {}
  union {
    CSOItemCriteriaCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOItemCriteriaConditionDefaultTypeInternal _CSOItemCriteriaCondition_default_instance_;
PROTOBUF_CONSTEXPR CSOItemCriteria::CSOItemCriteria(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.item_level_)*/0u
  , /*decltype(_impl_.item_quality_)*/0
  , /*decltype(_impl_.initial_inventory_)*/0u
  , /*decltype(_impl_.initial_quantity_)*/0u
  , /*decltype(_impl_.item_level_set_)*/false
  , /*decltype(_impl_.item_quality_set_)*/false
  , /*decltype(_impl_.ignore_enabled_flag_)*/false
  , /*decltype(_impl_.item_rarity_set_)*/false
  , /*decltype(_impl_.item_rarity_)*/0
  , /*decltype(_impl_.recent_only_)*/false} {}
struct CSOItemCriteriaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOItemCriteriaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOItemCriteriaDefaultTypeInternal() {}
  union {
    CSOItemCriteria _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOItemCriteriaDefaultTypeInternal _CSOItemCriteria_default_instance_;
PROTOBUF_CONSTEXPR CSOItemRecipe::CSOItemRecipe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.input_items_criteria_)*/{}
  , /*decltype(_impl_.output_items_criteria_)*/{}
  , /*decltype(_impl_.input_item_dupe_counts_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.n_a_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.desc_inputs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.desc_outputs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.di_a_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.di_b_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.di_c_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.do_a_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.do_b_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.do_c_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.requires_all_same_class_)*/false
  , /*decltype(_impl_.requires_all_same_slot_)*/false
  , /*decltype(_impl_.class_usage_for_output_)*/0
  , /*decltype(_impl_.slot_usage_for_output_)*/0
  , /*decltype(_impl_.set_for_output_)*/0} {}
struct CSOItemRecipeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOItemRecipeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOItemRecipeDefaultTypeInternal() {}
  union {
    CSOItemRecipe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOItemRecipeDefaultTypeInternal _CSOItemRecipe_default_instance_;
PROTOBUF_CONSTEXPR CMsgDevNewItemRequest::CMsgDevNewItemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.criteria_)*/nullptr
  , /*decltype(_impl_.receiver_)*/uint64_t{0u}} {}
struct CMsgDevNewItemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDevNewItemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDevNewItemRequestDefaultTypeInternal() {}
  union {
    CMsgDevNewItemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDevNewItemRequestDefaultTypeInternal _CMsgDevNewItemRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgIncrementKillCountAttribute::CMsgIncrementKillCountAttribute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.killer_account_id_)*/0u
  , /*decltype(_impl_.victim_account_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.event_type_)*/0u
  , /*decltype(_impl_.amount_)*/0u} {}
struct CMsgIncrementKillCountAttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgIncrementKillCountAttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgIncrementKillCountAttributeDefaultTypeInternal() {}
  union {
    CMsgIncrementKillCountAttribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgIncrementKillCountAttributeDefaultTypeInternal _CMsgIncrementKillCountAttribute_default_instance_;
PROTOBUF_CONSTEXPR CMsgApplySticker::CMsgApplySticker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sticker_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.item_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.sticker_slot_)*/0u
  , /*decltype(_impl_.baseitem_defidx_)*/0u
  , /*decltype(_impl_.sticker_wear_)*/0
  , /*decltype(_impl_.sticker_rotation_)*/0
  , /*decltype(_impl_.sticker_scale_)*/0
  , /*decltype(_impl_.sticker_offset_x_)*/0
  , /*decltype(_impl_.sticker_offset_y_)*/0
  , /*decltype(_impl_.sticker_offset_z_)*/0
  , /*decltype(_impl_.sticker_wear_target_)*/0} {}
struct CMsgApplyStickerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgApplyStickerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgApplyStickerDefaultTypeInternal() {}
  union {
    CMsgApplySticker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgApplyStickerDefaultTypeInternal _CMsgApplySticker_default_instance_;
PROTOBUF_CONSTEXPR CMsgModifyItemAttribute::CMsgModifyItemAttribute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.attr_defidx_)*/0u
  , /*decltype(_impl_.attr_value_)*/0u} {}
struct CMsgModifyItemAttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgModifyItemAttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgModifyItemAttributeDefaultTypeInternal() {}
  union {
    CMsgModifyItemAttribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgModifyItemAttributeDefaultTypeInternal _CMsgModifyItemAttribute_default_instance_;
PROTOBUF_CONSTEXPR CMsgApplyStatTrakSwap::CMsgApplyStatTrakSwap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tool_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.item_1_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.item_2_item_id_)*/uint64_t{0u}} {}
struct CMsgApplyStatTrakSwapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgApplyStatTrakSwapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgApplyStatTrakSwapDefaultTypeInternal() {}
  union {
    CMsgApplyStatTrakSwap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgApplyStatTrakSwapDefaultTypeInternal _CMsgApplyStatTrakSwap_default_instance_;
PROTOBUF_CONSTEXPR CMsgApplyStrangePart::CMsgApplyStrangePart(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.strange_part_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.item_item_id_)*/uint64_t{0u}} {}
struct CMsgApplyStrangePartDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgApplyStrangePartDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgApplyStrangePartDefaultTypeInternal() {}
  union {
    CMsgApplyStrangePart _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgApplyStrangePartDefaultTypeInternal _CMsgApplyStrangePart_default_instance_;
PROTOBUF_CONSTEXPR CMsgApplyPennantUpgrade::CMsgApplyPennantUpgrade(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.upgrade_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.pennant_item_id_)*/uint64_t{0u}} {}
struct CMsgApplyPennantUpgradeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgApplyPennantUpgradeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgApplyPennantUpgradeDefaultTypeInternal() {}
  union {
    CMsgApplyPennantUpgrade _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgApplyPennantUpgradeDefaultTypeInternal _CMsgApplyPennantUpgrade_default_instance_;
PROTOBUF_CONSTEXPR CMsgApplyEggEssence::CMsgApplyEggEssence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.essence_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.egg_item_id_)*/uint64_t{0u}} {}
struct CMsgApplyEggEssenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgApplyEggEssenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgApplyEggEssenceDefaultTypeInternal() {}
  union {
    CMsgApplyEggEssence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgApplyEggEssenceDefaultTypeInternal _CMsgApplyEggEssence_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemAttribute::CSOEconItemAttribute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_bytes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.value_)*/0u} {}
struct CSOEconItemAttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemAttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemAttributeDefaultTypeInternal() {}
  union {
    CSOEconItemAttribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemAttributeDefaultTypeInternal _CSOEconItemAttribute_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemEquipped::CSOEconItemEquipped(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_class_)*/0u
  , /*decltype(_impl_.new_slot_)*/0u} {}
struct CSOEconItemEquippedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemEquippedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemEquippedDefaultTypeInternal() {}
  union {
    CSOEconItemEquipped _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemEquippedDefaultTypeInternal _CSOEconItemEquipped_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItem::CSOEconItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attribute_)*/{}
  , /*decltype(_impl_.equipped_state_)*/{}
  , /*decltype(_impl_.custom_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.custom_desc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interior_item_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.inventory_)*/0u
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.quantity_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.quality_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.origin_)*/0u
  , /*decltype(_impl_.in_use_)*/false
  , /*decltype(_impl_.style_)*/0u
  , /*decltype(_impl_.original_id_)*/uint64_t{0u}
  , /*decltype(_impl_.rarity_)*/0u} {}
struct CSOEconItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemDefaultTypeInternal() {}
  union {
    CSOEconItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemDefaultTypeInternal _CSOEconItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgSortItems::CMsgSortItems(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sort_type_)*/0u} {}
struct CMsgSortItemsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSortItemsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSortItemsDefaultTypeInternal() {}
  union {
    CMsgSortItems _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSortItemsDefaultTypeInternal _CMsgSortItems_default_instance_;
PROTOBUF_CONSTEXPR CSOEconClaimCode::CSOEconClaimCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.code_type_)*/0u
  , /*decltype(_impl_.time_acquired_)*/0u} {}
struct CSOEconClaimCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconClaimCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconClaimCodeDefaultTypeInternal() {}
  union {
    CSOEconClaimCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconClaimCodeDefaultTypeInternal _CSOEconClaimCode_default_instance_;
PROTOBUF_CONSTEXPR CMsgStoreGetUserData::CMsgStoreGetUserData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.price_sheet_version_)*/0u
  , /*decltype(_impl_.currency_)*/0} {}
struct CMsgStoreGetUserDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStoreGetUserDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStoreGetUserDataDefaultTypeInternal() {}
  union {
    CMsgStoreGetUserData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStoreGetUserDataDefaultTypeInternal _CMsgStoreGetUserData_default_instance_;
PROTOBUF_CONSTEXPR CMsgStoreGetUserDataResponse::CMsgStoreGetUserDataResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.country_deprecated_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.price_sheet_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/0
  , /*decltype(_impl_.currency_deprecated_)*/0
  , /*decltype(_impl_.price_sheet_version_)*/0u} {}
struct CMsgStoreGetUserDataResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStoreGetUserDataResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStoreGetUserDataResponseDefaultTypeInternal() {}
  union {
    CMsgStoreGetUserDataResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStoreGetUserDataResponseDefaultTypeInternal _CMsgStoreGetUserDataResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgUpdateItemSchema::CMsgUpdateItemSchema(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_game_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.items_game_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_schema_version_)*/0u} {}
struct CMsgUpdateItemSchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgUpdateItemSchemaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgUpdateItemSchemaDefaultTypeInternal() {}
  union {
    CMsgUpdateItemSchema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgUpdateItemSchemaDefaultTypeInternal _CMsgUpdateItemSchema_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCError::CMsgGCError(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCErrorDefaultTypeInternal() {}
  union {
    CMsgGCError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCErrorDefaultTypeInternal _CMsgGCError_default_instance_;
PROTOBUF_CONSTEXPR CMsgRequestInventoryRefresh::CMsgRequestInventoryRefresh(
    ::_pbi::ConstantInitialized) {}
struct CMsgRequestInventoryRefreshDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgRequestInventoryRefreshDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgRequestInventoryRefreshDefaultTypeInternal() {}
  union {
    CMsgRequestInventoryRefresh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgRequestInventoryRefreshDefaultTypeInternal _CMsgRequestInventoryRefresh_default_instance_;
PROTOBUF_CONSTEXPR CMsgConVarValue::CMsgConVarValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgConVarValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgConVarValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgConVarValueDefaultTypeInternal() {}
  union {
    CMsgConVarValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgConVarValueDefaultTypeInternal _CMsgConVarValue_default_instance_;
PROTOBUF_CONSTEXPR CMsgReplicateConVars::CMsgReplicateConVars(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.convars_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgReplicateConVarsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgReplicateConVarsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgReplicateConVarsDefaultTypeInternal() {}
  union {
    CMsgReplicateConVars _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgReplicateConVarsDefaultTypeInternal _CMsgReplicateConVars_default_instance_;
PROTOBUF_CONSTEXPR CMsgUseItem::CMsgUseItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gift__potential_targets_)*/{}
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.target_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.initiator_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.duel__class_lock_)*/0u} {}
struct CMsgUseItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgUseItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgUseItemDefaultTypeInternal() {}
  union {
    CMsgUseItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgUseItemDefaultTypeInternal _CMsgUseItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgReplayUploadedToYouTube::CMsgReplayUploadedToYouTube(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.youtube_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.youtube_account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/uint64_t{0u}} {}
struct CMsgReplayUploadedToYouTubeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgReplayUploadedToYouTubeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgReplayUploadedToYouTubeDefaultTypeInternal() {}
  union {
    CMsgReplayUploadedToYouTube _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgReplayUploadedToYouTubeDefaultTypeInternal _CMsgReplayUploadedToYouTube_default_instance_;
PROTOBUF_CONSTEXPR CMsgConsumableExhausted::CMsgConsumableExhausted(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_id_)*/0} {}
struct CMsgConsumableExhaustedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgConsumableExhaustedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgConsumableExhaustedDefaultTypeInternal() {}
  union {
    CMsgConsumableExhausted _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgConsumableExhaustedDefaultTypeInternal _CMsgConsumableExhausted_default_instance_;
PROTOBUF_CONSTEXPR CMsgItemAcknowledged__DEPRECATED::CMsgItemAcknowledged__DEPRECATED(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.inventory_)*/0u
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.quality_)*/0u
  , /*decltype(_impl_.rarity_)*/0u
  , /*decltype(_impl_.origin_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}} {}
struct CMsgItemAcknowledged__DEPRECATEDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgItemAcknowledged__DEPRECATEDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgItemAcknowledged__DEPRECATEDDefaultTypeInternal() {}
  union {
    CMsgItemAcknowledged__DEPRECATED _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgItemAcknowledged__DEPRECATEDDefaultTypeInternal _CMsgItemAcknowledged__DEPRECATED_default_instance_;
PROTOBUF_CONSTEXPR CMsgSetItemPositions_ItemPosition::CMsgSetItemPositions_ItemPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.legacy_item_id_)*/0u
  , /*decltype(_impl_.position_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}} {}
struct CMsgSetItemPositions_ItemPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSetItemPositions_ItemPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSetItemPositions_ItemPositionDefaultTypeInternal() {}
  union {
    CMsgSetItemPositions_ItemPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSetItemPositions_ItemPositionDefaultTypeInternal _CMsgSetItemPositions_ItemPosition_default_instance_;
PROTOBUF_CONSTEXPR CMsgSetItemPositions::CMsgSetItemPositions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_positions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgSetItemPositionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSetItemPositionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSetItemPositionsDefaultTypeInternal() {}
  union {
    CMsgSetItemPositions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSetItemPositionsDefaultTypeInternal _CMsgSetItemPositions_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCReportAbuse::CMsgGCReportAbuse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.abuse_type_)*/0u
  , /*decltype(_impl_.content_type_)*/0u
  , /*decltype(_impl_.gid_)*/uint64_t{0u}
  , /*decltype(_impl_.target_game_server_ip_)*/0u
  , /*decltype(_impl_.target_game_server_port_)*/0u} {}
struct CMsgGCReportAbuseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCReportAbuseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCReportAbuseDefaultTypeInternal() {}
  union {
    CMsgGCReportAbuse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCReportAbuseDefaultTypeInternal _CMsgGCReportAbuse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCReportAbuseResponse::CMsgGCReportAbuseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.result_)*/0u} {}
struct CMsgGCReportAbuseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCReportAbuseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCReportAbuseResponseDefaultTypeInternal() {}
  union {
    CMsgGCReportAbuseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCReportAbuseResponseDefaultTypeInternal _CMsgGCReportAbuseResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCNameItemNotification::CMsgGCNameItemNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_name_custom_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.item_def_index_)*/0u} {}
struct CMsgGCNameItemNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCNameItemNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCNameItemNotificationDefaultTypeInternal() {}
  union {
    CMsgGCNameItemNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCNameItemNotificationDefaultTypeInternal _CMsgGCNameItemNotification_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCClientDisplayNotification::CMsgGCClientDisplayNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.body_substring_keys_)*/{}
  , /*decltype(_impl_.body_substring_values_)*/{}
  , /*decltype(_impl_.notification_title_localization_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.notification_body_localization_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCClientDisplayNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCClientDisplayNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCClientDisplayNotificationDefaultTypeInternal() {}
  union {
    CMsgGCClientDisplayNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCClientDisplayNotificationDefaultTypeInternal _CMsgGCClientDisplayNotification_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCShowItemsPickedUp::CMsgGCShowItemsPickedUp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_steamid_)*/uint64_t{0u}} {}
struct CMsgGCShowItemsPickedUpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCShowItemsPickedUpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCShowItemsPickedUpDefaultTypeInternal() {}
  union {
    CMsgGCShowItemsPickedUp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCShowItemsPickedUpDefaultTypeInternal _CMsgGCShowItemsPickedUp_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCIncrementKillCountResponse::CMsgGCIncrementKillCountResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.killer_account_id_)*/0u
  , /*decltype(_impl_.num_kills_)*/0u
  , /*decltype(_impl_.item_def_)*/0u
  , /*decltype(_impl_.level_type_)*/0u} {}
struct CMsgGCIncrementKillCountResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCIncrementKillCountResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCIncrementKillCountResponseDefaultTypeInternal() {}
  union {
    CMsgGCIncrementKillCountResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCIncrementKillCountResponseDefaultTypeInternal _CMsgGCIncrementKillCountResponse_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.expiration_date_)*/0u
  , /*decltype(_impl_.bonus_)*/0
  , /*decltype(_impl_.bonus_count_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.def_index_)*/0u} {}
struct CSOEconItemDropRateBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemDropRateBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemDropRateBonusDefaultTypeInternal() {}
  union {
    CSOEconItemDropRateBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemDropRateBonusDefaultTypeInternal _CSOEconItemDropRateBonus_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemLeagueViewPass::CSOEconItemLeagueViewPass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.admin_)*/0u
  , /*decltype(_impl_.itemindex_)*/0u} {}
struct CSOEconItemLeagueViewPassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemLeagueViewPassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemLeagueViewPassDefaultTypeInternal() {}
  union {
    CSOEconItemLeagueViewPass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemLeagueViewPassDefaultTypeInternal _CSOEconItemLeagueViewPass_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemEventTicket::CSOEconItemEventTicket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}} {}
struct CSOEconItemEventTicketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemEventTicketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemEventTicketDefaultTypeInternal() {}
  union {
    CSOEconItemEventTicket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemEventTicketDefaultTypeInternal _CSOEconItemEventTicket_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCItemPreviewItemBoughtNotification::CMsgGCItemPreviewItemBoughtNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_index_)*/0u} {}
struct CMsgGCItemPreviewItemBoughtNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCItemPreviewItemBoughtNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCItemPreviewItemBoughtNotificationDefaultTypeInternal() {}
  union {
    CMsgGCItemPreviewItemBoughtNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCItemPreviewItemBoughtNotificationDefaultTypeInternal _CMsgGCItemPreviewItemBoughtNotification_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseCancel::CMsgGCStorePurchaseCancel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.txn_id_)*/uint64_t{0u}} {}
struct CMsgGCStorePurchaseCancelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseCancelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseCancelDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseCancel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseCancelDefaultTypeInternal _CMsgGCStorePurchaseCancel_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseCancelResponse::CMsgGCStorePurchaseCancelResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0u} {}
struct CMsgGCStorePurchaseCancelResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseCancelResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseCancelResponseDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseCancelResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseCancelResponseDefaultTypeInternal _CMsgGCStorePurchaseCancelResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseFinalize::CMsgGCStorePurchaseFinalize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.txn_id_)*/uint64_t{0u}} {}
struct CMsgGCStorePurchaseFinalizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseFinalizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseFinalizeDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseFinalize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseFinalizeDefaultTypeInternal _CMsgGCStorePurchaseFinalize_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCStorePurchaseFinalizeResponse::CMsgGCStorePurchaseFinalizeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_ids_)*/{}
  , /*decltype(_impl_.result_)*/0u} {}
struct CMsgGCStorePurchaseFinalizeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCStorePurchaseFinalizeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCStorePurchaseFinalizeResponseDefaultTypeInternal() {}
  union {
    CMsgGCStorePurchaseFinalizeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCStorePurchaseFinalizeResponseDefaultTypeInternal _CMsgGCStorePurchaseFinalizeResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCBannedWordListRequest::CMsgGCBannedWordListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ban_list_group_id_)*/0u
  , /*decltype(_impl_.word_id_)*/0u} {}
struct CMsgGCBannedWordListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCBannedWordListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCBannedWordListRequestDefaultTypeInternal() {}
  union {
    CMsgGCBannedWordListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCBannedWordListRequestDefaultTypeInternal _CMsgGCBannedWordListRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestAnnouncements::CMsgGCRequestAnnouncements(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCRequestAnnouncementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestAnnouncementsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestAnnouncementsDefaultTypeInternal() {}
  union {
    CMsgGCRequestAnnouncements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestAnnouncementsDefaultTypeInternal _CMsgGCRequestAnnouncements_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestAnnouncementsResponse::CMsgGCRequestAnnouncementsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.announcement_title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.announcement_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nextmatch_title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nextmatch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCRequestAnnouncementsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestAnnouncementsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestAnnouncementsResponseDefaultTypeInternal() {}
  union {
    CMsgGCRequestAnnouncementsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestAnnouncementsResponseDefaultTypeInternal _CMsgGCRequestAnnouncementsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCBannedWord::CMsgGCBannedWord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.word_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.word_id_)*/0u
  , /*decltype(_impl_.word_type_)*/0} {}
struct CMsgGCBannedWordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCBannedWordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCBannedWordDefaultTypeInternal() {}
  union {
    CMsgGCBannedWord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCBannedWordDefaultTypeInternal _CMsgGCBannedWord_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCBannedWordListResponse::CMsgGCBannedWordListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.word_list_)*/{}
  , /*decltype(_impl_.ban_list_group_id_)*/0u} {}
struct CMsgGCBannedWordListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCBannedWordListResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCBannedWordListResponseDefaultTypeInternal() {}
  union {
    CMsgGCBannedWordListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCBannedWordListResponseDefaultTypeInternal _CMsgGCBannedWordListResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCBannedWordListBroadcast::CMsgGCToGCBannedWordListBroadcast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.broadcast_)*/nullptr} {}
struct CMsgGCToGCBannedWordListBroadcastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCBannedWordListBroadcastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCBannedWordListBroadcastDefaultTypeInternal() {}
  union {
    CMsgGCToGCBannedWordListBroadcast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCBannedWordListBroadcastDefaultTypeInternal _CMsgGCToGCBannedWordListBroadcast_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCBannedWordListUpdated::CMsgGCToGCBannedWordListUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_id_)*/0u} {}
struct CMsgGCToGCBannedWordListUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCBannedWordListUpdatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCBannedWordListUpdatedDefaultTypeInternal() {}
  union {
    CMsgGCToGCBannedWordListUpdated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCBannedWordListUpdatedDefaultTypeInternal _CMsgGCToGCBannedWordListUpdated_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCDirtySDOCache::CMsgGCToGCDirtySDOCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_uint64_)*/uint64_t{0u}
  , /*decltype(_impl_.sdo_type_)*/0u} {}
struct CMsgGCToGCDirtySDOCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCDirtySDOCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCDirtySDOCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCDirtySDOCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCDirtySDOCacheDefaultTypeInternal _CMsgGCToGCDirtySDOCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCDirtyMultipleSDOCache::CMsgGCToGCDirtyMultipleSDOCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_uint64_)*/{}
  , /*decltype(_impl_.sdo_type_)*/0u} {}
struct CMsgGCToGCDirtyMultipleSDOCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCDirtyMultipleSDOCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCDirtyMultipleSDOCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCDirtyMultipleSDOCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCDirtyMultipleSDOCacheDefaultTypeInternal _CMsgGCToGCDirtyMultipleSDOCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCCollectItem::CMsgGCCollectItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.collection_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.subject_item_id_)*/uint64_t{0u}} {}
struct CMsgGCCollectItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCCollectItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCCollectItemDefaultTypeInternal() {}
  union {
    CMsgGCCollectItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCCollectItemDefaultTypeInternal _CMsgGCCollectItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgSDONoMemcached::CMsgSDONoMemcached(
    ::_pbi::ConstantInitialized) {}
struct CMsgSDONoMemcachedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSDONoMemcachedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSDONoMemcachedDefaultTypeInternal() {}
  union {
    CMsgSDONoMemcached _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSDONoMemcachedDefaultTypeInternal _CMsgSDONoMemcached_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCUpdateSQLKeyValue::CMsgGCToGCUpdateSQLKeyValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCToGCUpdateSQLKeyValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCUpdateSQLKeyValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCUpdateSQLKeyValueDefaultTypeInternal() {}
  union {
    CMsgGCToGCUpdateSQLKeyValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCUpdateSQLKeyValueDefaultTypeInternal _CMsgGCToGCUpdateSQLKeyValue_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCIsTrustedServer::CMsgGCToGCIsTrustedServer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}} {}
struct CMsgGCToGCIsTrustedServerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCIsTrustedServerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCIsTrustedServerDefaultTypeInternal() {}
  union {
    CMsgGCToGCIsTrustedServer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCIsTrustedServerDefaultTypeInternal _CMsgGCToGCIsTrustedServer_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCIsTrustedServerResponse::CMsgGCToGCIsTrustedServerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.is_trusted_)*/false} {}
struct CMsgGCToGCIsTrustedServerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCIsTrustedServerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCIsTrustedServerResponseDefaultTypeInternal() {}
  union {
    CMsgGCToGCIsTrustedServerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCIsTrustedServerResponseDefaultTypeInternal _CMsgGCToGCIsTrustedServerResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCBroadcastConsoleCommand::CMsgGCToGCBroadcastConsoleCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.con_command_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCToGCBroadcastConsoleCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCBroadcastConsoleCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCBroadcastConsoleCommandDefaultTypeInternal() {}
  union {
    CMsgGCToGCBroadcastConsoleCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCBroadcastConsoleCommandDefaultTypeInternal _CMsgGCToGCBroadcastConsoleCommand_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCServerVersionUpdated::CMsgGCServerVersionUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.server_version_)*/0u} {}
struct CMsgGCServerVersionUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCServerVersionUpdatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCServerVersionUpdatedDefaultTypeInternal() {}
  union {
    CMsgGCServerVersionUpdated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCServerVersionUpdatedDefaultTypeInternal _CMsgGCServerVersionUpdated_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCClientVersionUpdated::CMsgGCClientVersionUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_version_)*/0u} {}
struct CMsgGCClientVersionUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCClientVersionUpdatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCClientVersionUpdatedDefaultTypeInternal() {}
  union {
    CMsgGCClientVersionUpdated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCClientVersionUpdatedDefaultTypeInternal _CMsgGCClientVersionUpdated_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCWebAPIAccountChanged::CMsgGCToGCWebAPIAccountChanged(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCToGCWebAPIAccountChangedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCWebAPIAccountChangedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCWebAPIAccountChangedDefaultTypeInternal() {}
  union {
    CMsgGCToGCWebAPIAccountChanged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCWebAPIAccountChangedDefaultTypeInternal _CMsgGCToGCWebAPIAccountChanged_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCRequestPassportItemGrant::CMsgGCToGCRequestPassportItemGrant(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.reward_flag_)*/0} {}
struct CMsgGCToGCRequestPassportItemGrantDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCRequestPassportItemGrantDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCRequestPassportItemGrantDefaultTypeInternal() {}
  union {
    CMsgGCToGCRequestPassportItemGrant _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCRequestPassportItemGrantDefaultTypeInternal _CMsgGCToGCRequestPassportItemGrant_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameServerInfo::CMsgGameServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.server_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_public_ip_addr_)*/0u
  , /*decltype(_impl_.server_private_ip_addr_)*/0u
  , /*decltype(_impl_.server_port_)*/0u
  , /*decltype(_impl_.server_tv_port_)*/0u
  , /*decltype(_impl_.server_hibernation_)*/false
  , /*decltype(_impl_.server_type_)*/0
  , /*decltype(_impl_.server_region_)*/0u
  , /*decltype(_impl_.server_loadavg_)*/0
  , /*decltype(_impl_.server_tv_broadcast_time_)*/0
  , /*decltype(_impl_.server_game_time_)*/0
  , /*decltype(_impl_.server_relay_connected_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.relay_slots_max_)*/0u
  , /*decltype(_impl_.relays_connected_)*/0
  , /*decltype(_impl_.relayed_game_server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.relay_clients_connected_)*/0
  , /*decltype(_impl_.parent_relay_count_)*/0u
  , /*decltype(_impl_.tv_secret_code_)*/uint64_t{0u}} {}
struct CMsgGameServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameServerInfoDefaultTypeInternal() {}
  union {
    CMsgGameServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameServerInfoDefaultTypeInternal _CMsgGameServerInfo_default_instance_;
PROTOBUF_CONSTEXPR CSOEconEquipSlot::CSOEconEquipSlot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.class_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.item_definition_)*/0u} {}
struct CSOEconEquipSlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconEquipSlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconEquipSlotDefaultTypeInternal() {}
  union {
    CSOEconEquipSlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconEquipSlotDefaultTypeInternal _CSOEconEquipSlot_default_instance_;
PROTOBUF_CONSTEXPR CMsgAdjustEquipSlot::CMsgAdjustEquipSlot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.class_id_)*/0u
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}} {}
struct CMsgAdjustEquipSlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAdjustEquipSlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAdjustEquipSlotDefaultTypeInternal() {}
  union {
    CMsgAdjustEquipSlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAdjustEquipSlotDefaultTypeInternal _CMsgAdjustEquipSlot_default_instance_;
PROTOBUF_CONSTEXPR CMsgAdjustEquipSlots::CMsgAdjustEquipSlots(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slots_)*/{}
  , /*decltype(_impl_.change_num_)*/0u} {}
struct CMsgAdjustEquipSlotsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAdjustEquipSlotsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAdjustEquipSlotsDefaultTypeInternal() {}
  union {
    CMsgAdjustEquipSlots _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAdjustEquipSlotsDefaultTypeInternal _CMsgAdjustEquipSlots_default_instance_;
PROTOBUF_CONSTEXPR CMsgOpenCrate::CMsgOpenCrate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tool_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.subject_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.for_rental_)*/false
  , /*decltype(_impl_.points_remaining_)*/0u} {}
struct CMsgOpenCrateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOpenCrateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOpenCrateDefaultTypeInternal() {}
  union {
    CMsgOpenCrate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOpenCrateDefaultTypeInternal _CMsgOpenCrate_default_instance_;
PROTOBUF_CONSTEXPR CSOEconRentalHistory::CSOEconRentalHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.crate_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.crate_def_index_)*/0u
  , /*decltype(_impl_.issue_date_)*/0u
  , /*decltype(_impl_.expiration_date_)*/0u} {}
struct CSOEconRentalHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconRentalHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconRentalHistoryDefaultTypeInternal() {}
  union {
    CSOEconRentalHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconRentalHistoryDefaultTypeInternal _CSOEconRentalHistory_default_instance_;
PROTOBUF_CONSTEXPR CMsgAcknowledgeRentalExpiration::CMsgAcknowledgeRentalExpiration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.crate_item_id_)*/uint64_t{0u}} {}
struct CMsgAcknowledgeRentalExpirationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAcknowledgeRentalExpirationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAcknowledgeRentalExpirationDefaultTypeInternal() {}
  union {
    CMsgAcknowledgeRentalExpiration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAcknowledgeRentalExpirationDefaultTypeInternal _CMsgAcknowledgeRentalExpiration_default_instance_;
static ::_pb::Metadata file_level_metadata_base_5fgcmessages_2eproto[83];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_base_5fgcmessages_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_base_5fgcmessages_2eproto = nullptr;

const uint32_t TableStruct_base_5fgcmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_.item_def_id_),
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_.cost_in_local_currency_),
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_.purchase_type_),
  PROTOBUF_FIELD_OFFSET(::CGCStorePurchaseInit_LineItem, _impl_.supplemental_data_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _impl_.country_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _impl_.currency_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInit, _impl_.line_items_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _impl_.txn_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseInitResponse, _impl_.item_ids_),
  2,
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSOPartyInvite, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOPartyInvite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOPartyInvite, _impl_.group_id_),
  PROTOBUF_FIELD_OFFSET(::CSOPartyInvite, _impl_.sender_id_),
  PROTOBUF_FIELD_OFFSET(::CSOPartyInvite, _impl_.sender_name_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSOLobbyInvite, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOLobbyInvite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOLobbyInvite, _impl_.group_id_),
  PROTOBUF_FIELD_OFFSET(::CSOLobbyInvite, _impl_.sender_id_),
  PROTOBUF_FIELD_OFFSET(::CSOLobbyInvite, _impl_.sender_name_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemBroadcast, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemBroadcast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemBroadcast, _impl_.message_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgInviteToParty, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgInviteToParty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgInviteToParty, _impl_.steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgInviteToParty, _impl_.client_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgInviteToParty, _impl_.team_invite_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgInvitationCreated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgInvitationCreated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgInvitationCreated, _impl_.group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgInvitationCreated, _impl_.steam_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _impl_.party_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _impl_.accept_),
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _impl_.client_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgPartyInviteResponse, _impl_.team_invite_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgKickFromParty, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgKickFromParty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgKickFromParty, _impl_.steam_id_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgLeaveParty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgServerAvailable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLANServerAvailable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgLANServerAvailable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLANServerAvailable, _impl_.lobby_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.additional_backpack_slots_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.trade_ban_expiration_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.bonus_xp_timestamp_refresh_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.bonus_xp_usedflags_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.elevated_state_),
  PROTOBUF_FIELD_OFFSET(::CSOEconGameAccountClient, _impl_.elevated_timestamp_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_.field_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_.float_value_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteriaCondition, _impl_.string_value_),
  2,
  0,
  3,
  4,
  1,
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_level_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_quality_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_level_set_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_quality_set_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.initial_inventory_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.initial_quantity_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.ignore_enabled_flag_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.conditions_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_rarity_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.item_rarity_set_),
  PROTOBUF_FIELD_OFFSET(::CSOItemCriteria, _impl_.recent_only_),
  0,
  1,
  4,
  5,
  2,
  3,
  6,
  ~0u,
  8,
  7,
  9,
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.n_a_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.desc_inputs_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.desc_outputs_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.di_a_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.di_b_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.di_c_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.do_a_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.do_b_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.do_c_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.requires_all_same_class_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.requires_all_same_slot_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.class_usage_for_output_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.slot_usage_for_output_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.set_for_output_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.input_items_criteria_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.output_items_criteria_),
  PROTOBUF_FIELD_OFFSET(::CSOItemRecipe, _impl_.input_item_dupe_counts_),
  10,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  11,
  12,
  13,
  14,
  15,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDevNewItemRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDevNewItemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDevNewItemRequest, _impl_.receiver_),
  PROTOBUF_FIELD_OFFSET(::CMsgDevNewItemRequest, _impl_.criteria_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_.killer_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_.victim_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_.event_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgIncrementKillCountAttribute, _impl_.amount_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.item_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.baseitem_defidx_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_wear_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_rotation_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_offset_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_offset_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_offset_z_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplySticker, _impl_.sticker_wear_target_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgModifyItemAttribute, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgModifyItemAttribute, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgModifyItemAttribute, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgModifyItemAttribute, _impl_.attr_defidx_),
  PROTOBUF_FIELD_OFFSET(::CMsgModifyItemAttribute, _impl_.attr_value_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStatTrakSwap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStatTrakSwap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStatTrakSwap, _impl_.tool_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStatTrakSwap, _impl_.item_1_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStatTrakSwap, _impl_.item_2_item_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStrangePart, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStrangePart, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStrangePart, _impl_.strange_part_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyStrangePart, _impl_.item_item_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgApplyPennantUpgrade, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyPennantUpgrade, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgApplyPennantUpgrade, _impl_.upgrade_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyPennantUpgrade, _impl_.pennant_item_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgApplyEggEssence, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyEggEssence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgApplyEggEssence, _impl_.essence_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgApplyEggEssence, _impl_.egg_item_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemAttribute, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemAttribute, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemAttribute, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemAttribute, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemAttribute, _impl_.value_bytes_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEquipped, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEquipped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEquipped, _impl_.new_class_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEquipped, _impl_.new_slot_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.inventory_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.custom_name_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.custom_desc_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.attribute_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.interior_item_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.in_use_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.original_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.equipped_state_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItem, _impl_.rarity_),
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  0,
  1,
  ~0u,
  2,
  12,
  13,
  14,
  ~0u,
  15,
  PROTOBUF_FIELD_OFFSET(::CMsgSortItems, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSortItems, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSortItems, _impl_.sort_type_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _impl_.code_type_),
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _impl_.time_acquired_),
  PROTOBUF_FIELD_OFFSET(::CSOEconClaimCode, _impl_.code_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserData, _impl_.price_sheet_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserData, _impl_.currency_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_.currency_deprecated_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_.country_deprecated_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_.price_sheet_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgStoreGetUserDataResponse, _impl_.price_sheet_),
  2,
  3,
  0,
  4,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgUpdateItemSchema, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgUpdateItemSchema, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgUpdateItemSchema, _impl_.items_game_),
  PROTOBUF_FIELD_OFFSET(::CMsgUpdateItemSchema, _impl_.item_schema_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgUpdateItemSchema, _impl_.items_game_url_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCError, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCError, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCError, _impl_.error_text_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgRequestInventoryRefresh, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgConVarValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgConVarValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgConVarValue, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgConVarValue, _impl_.value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgReplicateConVars, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgReplicateConVars, _impl_.convars_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_.target_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_.gift__potential_targets_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_.duel__class_lock_),
  PROTOBUF_FIELD_OFFSET(::CMsgUseItem, _impl_.initiator_steam_id_),
  0,
  1,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgReplayUploadedToYouTube, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgReplayUploadedToYouTube, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgReplayUploadedToYouTube, _impl_.youtube_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgReplayUploadedToYouTube, _impl_.youtube_account_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgReplayUploadedToYouTube, _impl_.session_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableExhausted, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableExhausted, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableExhausted, _impl_.item_def_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.inventory_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.rarity_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgItemAcknowledged__DEPRECATED, _impl_.item_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions_ItemPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions_ItemPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions_ItemPosition, _impl_.legacy_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions_ItemPosition, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions_ItemPosition, _impl_.item_id_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSetItemPositions, _impl_.item_positions_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.target_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.gid_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.abuse_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.content_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.target_game_server_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuse, _impl_.target_game_server_port_),
  1,
  0,
  4,
  2,
  3,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuseResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuseResponse, _impl_.target_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuseResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCReportAbuseResponse, _impl_.error_message_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCNameItemNotification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCNameItemNotification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCNameItemNotification, _impl_.player_steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCNameItemNotification, _impl_.item_def_index_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCNameItemNotification, _impl_.item_name_custom_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _impl_.notification_title_localization_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _impl_.notification_body_localization_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _impl_.body_substring_keys_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientDisplayNotification, _impl_.body_substring_values_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCShowItemsPickedUp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCShowItemsPickedUp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCShowItemsPickedUp, _impl_.player_steamid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _impl_.killer_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _impl_.num_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _impl_.item_def_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCIncrementKillCountResponse, _impl_.level_type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.expiration_date_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.bonus_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.bonus_count_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.def_index_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _impl_.admin_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemLeagueViewPass, _impl_.itemindex_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEventTicket, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEventTicket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEventTicket, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEventTicket, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemEventTicket, _impl_.item_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGCItemPreviewItemBoughtNotification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCItemPreviewItemBoughtNotification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCItemPreviewItemBoughtNotification, _impl_.item_def_index_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancel, _impl_.txn_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancelResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancelResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseCancelResponse, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalize, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalize, _impl_.txn_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalizeResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalizeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalizeResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCStorePurchaseFinalizeResponse, _impl_.item_ids_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListRequest, _impl_.ban_list_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListRequest, _impl_.word_id_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _impl_.announcement_title_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _impl_.announcement_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _impl_.nextmatch_title_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestAnnouncementsResponse, _impl_.nextmatch_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWord, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWord, _impl_.word_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWord, _impl_.word_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWord, _impl_.word_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListResponse, _impl_.ban_list_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCBannedWordListResponse, _impl_.word_list_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListBroadcast, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListBroadcast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListBroadcast, _impl_.broadcast_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListUpdated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListUpdated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBannedWordListUpdated, _impl_.group_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtySDOCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtySDOCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtySDOCache, _impl_.sdo_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtySDOCache, _impl_.key_uint64_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtyMultipleSDOCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtyMultipleSDOCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtyMultipleSDOCache, _impl_.sdo_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCDirtyMultipleSDOCache, _impl_.key_uint64_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCCollectItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCCollectItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCCollectItem, _impl_.collection_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCCollectItem, _impl_.subject_item_id_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgSDONoMemcached, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSQLKeyValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSQLKeyValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSQLKeyValue, _impl_.key_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServer, _impl_.steam_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServerResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCIsTrustedServerResponse, _impl_.is_trusted_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBroadcastConsoleCommand, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBroadcastConsoleCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCBroadcastConsoleCommand, _impl_.con_command_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCServerVersionUpdated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCServerVersionUpdated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCServerVersionUpdated, _impl_.server_version_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientVersionUpdated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientVersionUpdated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientVersionUpdated, _impl_.client_version_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCWebAPIAccountChanged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCRequestPassportItemGrant, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCRequestPassportItemGrant, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCRequestPassportItemGrant, _impl_.steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCRequestPassportItemGrant, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCRequestPassportItemGrant, _impl_.reward_flag_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_public_ip_addr_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_private_ip_addr_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_tv_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_hibernation_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_region_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_loadavg_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_tv_broadcast_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_game_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.server_relay_connected_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.relay_slots_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.relays_connected_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.relay_clients_connected_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.relayed_game_server_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.parent_relay_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameServerInfo, _impl_.tv_secret_code_),
  1,
  2,
  3,
  4,
  0,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  15,
  14,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_.class_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconEquipSlot, _impl_.item_definition_),
  0,
  1,
  3,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlot, _impl_.class_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlot, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlot, _impl_.item_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlots, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlots, _impl_.slots_),
  PROTOBUF_FIELD_OFFSET(::CMsgAdjustEquipSlots, _impl_.change_num_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _impl_.tool_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _impl_.subject_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _impl_.for_rental_),
  PROTOBUF_FIELD_OFFSET(::CMsgOpenCrate, _impl_.points_remaining_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_.crate_item_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_.crate_def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_.issue_date_),
  PROTOBUF_FIELD_OFFSET(::CSOEconRentalHistory, _impl_.expiration_date_),
  1,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgAcknowledgeRentalExpiration, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAcknowledgeRentalExpiration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAcknowledgeRentalExpiration, _impl_.crate_item_id_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::CGCStorePurchaseInit_LineItem)},
  { 16, 26, -1, sizeof(::CMsgGCStorePurchaseInit)},
  { 30, 40, -1, sizeof(::CMsgGCStorePurchaseInitResponse)},
  { 44, 53, -1, sizeof(::CSOPartyInvite)},
  { 56, 65, -1, sizeof(::CSOLobbyInvite)},
  { 68, 75, -1, sizeof(::CMsgSystemBroadcast)},
  { 76, 85, -1, sizeof(::CMsgInviteToParty)},
  { 88, 96, -1, sizeof(::CMsgInvitationCreated)},
  { 98, 108, -1, sizeof(::CMsgPartyInviteResponse)},
  { 112, 119, -1, sizeof(::CMsgKickFromParty)},
  { 120, -1, -1, sizeof(::CMsgLeaveParty)},
  { 126, -1, -1, sizeof(::CMsgServerAvailable)},
  { 132, 139, -1, sizeof(::CMsgLANServerAvailable)},
  { 140, 152, -1, sizeof(::CSOEconGameAccountClient)},
  { 158, 169, -1, sizeof(::CSOItemCriteriaCondition)},
  { 174, 191, -1, sizeof(::CSOItemCriteria)},
  { 202, 227, -1, sizeof(::CSOItemRecipe)},
  { 246, 254, -1, sizeof(::CMsgDevNewItemRequest)},
  { 256, 267, -1, sizeof(::CMsgIncrementKillCountAttribute)},
  { 272, 289, -1, sizeof(::CMsgApplySticker)},
  { 300, 309, -1, sizeof(::CMsgModifyItemAttribute)},
  { 312, 321, -1, sizeof(::CMsgApplyStatTrakSwap)},
  { 324, 332, -1, sizeof(::CMsgApplyStrangePart)},
  { 334, 342, -1, sizeof(::CMsgApplyPennantUpgrade)},
  { 344, 352, -1, sizeof(::CMsgApplyEggEssence)},
  { 354, 363, -1, sizeof(::CSOEconItemAttribute)},
  { 366, 374, -1, sizeof(::CSOEconItemEquipped)},
  { 376, 400, -1, sizeof(::CSOEconItem)},
  { 418, 425, -1, sizeof(::CMsgSortItems)},
  { 426, 436, -1, sizeof(::CSOEconClaimCode)},
  { 440, 448, -1, sizeof(::CMsgStoreGetUserData)},
  { 450, 461, -1, sizeof(::CMsgStoreGetUserDataResponse)},
  { 466, 475, -1, sizeof(::CMsgUpdateItemSchema)},
  { 478, 485, -1, sizeof(::CMsgGCError)},
  { 486, -1, -1, sizeof(::CMsgRequestInventoryRefresh)},
  { 492, 500, -1, sizeof(::CMsgConVarValue)},
  { 502, -1, -1, sizeof(::CMsgReplicateConVars)},
  { 509, 520, -1, sizeof(::CMsgUseItem)},
  { 525, 534, -1, sizeof(::CMsgReplayUploadedToYouTube)},
  { 537, 544, -1, sizeof(::CMsgConsumableExhausted)},
  { 545, 558, -1, sizeof(::CMsgItemAcknowledged__DEPRECATED)},
  { 565, 574, -1, sizeof(::CMsgSetItemPositions_ItemPosition)},
  { 577, -1, -1, sizeof(::CMsgSetItemPositions)},
  { 584, 597, -1, sizeof(::CMsgGCReportAbuse)},
  { 604, 613, -1, sizeof(::CMsgGCReportAbuseResponse)},
  { 616, 625, -1, sizeof(::CMsgGCNameItemNotification)},
  { 628, 638, -1, sizeof(::CMsgGCClientDisplayNotification)},
  { 642, 649, -1, sizeof(::CMsgGCShowItemsPickedUp)},
  { 650, 660, -1, sizeof(::CMsgGCIncrementKillCountResponse)},
  { 664, 676, -1, sizeof(::CSOEconItemDropRateBonus)},
  { 682, 692, -1, sizeof(::CSOEconItemLeagueViewPass)},
  { 696, 705, -1, sizeof(::CSOEconItemEventTicket)},
  { 708, 715, -1, sizeof(::CMsgGCItemPreviewItemBoughtNotification)},
  { 716, 723, -1, sizeof(::CMsgGCStorePurchaseCancel)},
  { 724, 731, -1, sizeof(::CMsgGCStorePurchaseCancelResponse)},
  { 732, 739, -1, sizeof(::CMsgGCStorePurchaseFinalize)},
  { 740, 748, -1, sizeof(::CMsgGCStorePurchaseFinalizeResponse)},
  { 750, 758, -1, sizeof(::CMsgGCBannedWordListRequest)},
  { 760, -1, -1, sizeof(::CMsgGCRequestAnnouncements)},
  { 766, 776, -1, sizeof(::CMsgGCRequestAnnouncementsResponse)},
  { 780, 789, -1, sizeof(::CMsgGCBannedWord)},
  { 792, 800, -1, sizeof(::CMsgGCBannedWordListResponse)},
  { 802, 809, -1, sizeof(::CMsgGCToGCBannedWordListBroadcast)},
  { 810, 817, -1, sizeof(::CMsgGCToGCBannedWordListUpdated)},
  { 818, 826, -1, sizeof(::CMsgGCToGCDirtySDOCache)},
  { 828, 836, -1, sizeof(::CMsgGCToGCDirtyMultipleSDOCache)},
  { 838, 846, -1, sizeof(::CMsgGCCollectItem)},
  { 848, -1, -1, sizeof(::CMsgSDONoMemcached)},
  { 854, 861, -1, sizeof(::CMsgGCToGCUpdateSQLKeyValue)},
  { 862, 869, -1, sizeof(::CMsgGCToGCIsTrustedServer)},
  { 870, 877, -1, sizeof(::CMsgGCToGCIsTrustedServerResponse)},
  { 878, 885, -1, sizeof(::CMsgGCToGCBroadcastConsoleCommand)},
  { 886, 893, -1, sizeof(::CMsgGCServerVersionUpdated)},
  { 894, 901, -1, sizeof(::CMsgGCClientVersionUpdated)},
  { 902, -1, -1, sizeof(::CMsgGCToGCWebAPIAccountChanged)},
  { 908, 917, -1, sizeof(::CMsgGCToGCRequestPassportItemGrant)},
  { 920, 944, -1, sizeof(::CMsgGameServerInfo)},
  { 962, 973, -1, sizeof(::CSOEconEquipSlot)},
  { 978, 987, -1, sizeof(::CMsgAdjustEquipSlot)},
  { 990, 998, -1, sizeof(::CMsgAdjustEquipSlots)},
  { 1000, 1010, -1, sizeof(::CMsgOpenCrate)},
  { 1014, 1025, -1, sizeof(::CSOEconRentalHistory)},
  { 1030, 1037, -1, sizeof(::CMsgAcknowledgeRentalExpiration)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CGCStorePurchaseInit_LineItem_default_instance_._instance,
  &::_CMsgGCStorePurchaseInit_default_instance_._instance,
  &::_CMsgGCStorePurchaseInitResponse_default_instance_._instance,
  &::_CSOPartyInvite_default_instance_._instance,
  &::_CSOLobbyInvite_default_instance_._instance,
  &::_CMsgSystemBroadcast_default_instance_._instance,
  &::_CMsgInviteToParty_default_instance_._instance,
  &::_CMsgInvitationCreated_default_instance_._instance,
  &::_CMsgPartyInviteResponse_default_instance_._instance,
  &::_CMsgKickFromParty_default_instance_._instance,
  &::_CMsgLeaveParty_default_instance_._instance,
  &::_CMsgServerAvailable_default_instance_._instance,
  &::_CMsgLANServerAvailable_default_instance_._instance,
  &::_CSOEconGameAccountClient_default_instance_._instance,
  &::_CSOItemCriteriaCondition_default_instance_._instance,
  &::_CSOItemCriteria_default_instance_._instance,
  &::_CSOItemRecipe_default_instance_._instance,
  &::_CMsgDevNewItemRequest_default_instance_._instance,
  &::_CMsgIncrementKillCountAttribute_default_instance_._instance,
  &::_CMsgApplySticker_default_instance_._instance,
  &::_CMsgModifyItemAttribute_default_instance_._instance,
  &::_CMsgApplyStatTrakSwap_default_instance_._instance,
  &::_CMsgApplyStrangePart_default_instance_._instance,
  &::_CMsgApplyPennantUpgrade_default_instance_._instance,
  &::_CMsgApplyEggEssence_default_instance_._instance,
  &::_CSOEconItemAttribute_default_instance_._instance,
  &::_CSOEconItemEquipped_default_instance_._instance,
  &::_CSOEconItem_default_instance_._instance,
  &::_CMsgSortItems_default_instance_._instance,
  &::_CSOEconClaimCode_default_instance_._instance,
  &::_CMsgStoreGetUserData_default_instance_._instance,
  &::_CMsgStoreGetUserDataResponse_default_instance_._instance,
  &::_CMsgUpdateItemSchema_default_instance_._instance,
  &::_CMsgGCError_default_instance_._instance,
  &::_CMsgRequestInventoryRefresh_default_instance_._instance,
  &::_CMsgConVarValue_default_instance_._instance,
  &::_CMsgReplicateConVars_default_instance_._instance,
  &::_CMsgUseItem_default_instance_._instance,
  &::_CMsgReplayUploadedToYouTube_default_instance_._instance,
  &::_CMsgConsumableExhausted_default_instance_._instance,
  &::_CMsgItemAcknowledged__DEPRECATED_default_instance_._instance,
  &::_CMsgSetItemPositions_ItemPosition_default_instance_._instance,
  &::_CMsgSetItemPositions_default_instance_._instance,
  &::_CMsgGCReportAbuse_default_instance_._instance,
  &::_CMsgGCReportAbuseResponse_default_instance_._instance,
  &::_CMsgGCNameItemNotification_default_instance_._instance,
  &::_CMsgGCClientDisplayNotification_default_instance_._instance,
  &::_CMsgGCShowItemsPickedUp_default_instance_._instance,
  &::_CMsgGCIncrementKillCountResponse_default_instance_._instance,
  &::_CSOEconItemDropRateBonus_default_instance_._instance,
  &::_CSOEconItemLeagueViewPass_default_instance_._instance,
  &::_CSOEconItemEventTicket_default_instance_._instance,
  &::_CMsgGCItemPreviewItemBoughtNotification_default_instance_._instance,
  &::_CMsgGCStorePurchaseCancel_default_instance_._instance,
  &::_CMsgGCStorePurchaseCancelResponse_default_instance_._instance,
  &::_CMsgGCStorePurchaseFinalize_default_instance_._instance,
  &::_CMsgGCStorePurchaseFinalizeResponse_default_instance_._instance,
  &::_CMsgGCBannedWordListRequest_default_instance_._instance,
  &::_CMsgGCRequestAnnouncements_default_instance_._instance,
  &::_CMsgGCRequestAnnouncementsResponse_default_instance_._instance,
  &::_CMsgGCBannedWord_default_instance_._instance,
  &::_CMsgGCBannedWordListResponse_default_instance_._instance,
  &::_CMsgGCToGCBannedWordListBroadcast_default_instance_._instance,
  &::_CMsgGCToGCBannedWordListUpdated_default_instance_._instance,
  &::_CMsgGCToGCDirtySDOCache_default_instance_._instance,
  &::_CMsgGCToGCDirtyMultipleSDOCache_default_instance_._instance,
  &::_CMsgGCCollectItem_default_instance_._instance,
  &::_CMsgSDONoMemcached_default_instance_._instance,
  &::_CMsgGCToGCUpdateSQLKeyValue_default_instance_._instance,
  &::_CMsgGCToGCIsTrustedServer_default_instance_._instance,
  &::_CMsgGCToGCIsTrustedServerResponse_default_instance_._instance,
  &::_CMsgGCToGCBroadcastConsoleCommand_default_instance_._instance,
  &::_CMsgGCServerVersionUpdated_default_instance_._instance,
  &::_CMsgGCClientVersionUpdated_default_instance_._instance,
  &::_CMsgGCToGCWebAPIAccountChanged_default_instance_._instance,
  &::_CMsgGCToGCRequestPassportItemGrant_default_instance_._instance,
  &::_CMsgGameServerInfo_default_instance_._instance,
  &::_CSOEconEquipSlot_default_instance_._instance,
  &::_CMsgAdjustEquipSlot_default_instance_._instance,
  &::_CMsgAdjustEquipSlots_default_instance_._instance,
  &::_CMsgOpenCrate_default_instance_._instance,
  &::_CSOEconRentalHistory_default_instance_._instance,
  &::_CMsgAcknowledgeRentalExpiration_default_instance_._instance,
};

const char descriptor_table_protodef_base_5fgcmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025base_gcmessages.proto\032\023steammessages.p"
  "roto\"\230\001\n\035CGCStorePurchaseInit_LineItem\022\023"
  "\n\013item_def_id\030\001 \001(\r\022\020\n\010quantity\030\002 \001(\r\022\036\n"
  "\026cost_in_local_currency\030\003 \001(\r\022\025\n\rpurchas"
  "e_type\030\004 \001(\r\022\031\n\021supplemental_data\030\005 \001(\004\""
  "\202\001\n\027CMsgGCStorePurchaseInit\022\017\n\007country\030\001"
  " \001(\t\022\020\n\010language\030\002 \001(\005\022\020\n\010currency\030\003 \001(\005"
  "\0222\n\nline_items\030\004 \003(\0132\036.CGCStorePurchaseI"
  "nit_LineItem\"`\n\037CMsgGCStorePurchaseInitR"
  "esponse\022\016\n\006result\030\001 \001(\005\022\016\n\006txn_id\030\002 \001(\004\022"
  "\013\n\003url\030\003 \001(\t\022\020\n\010item_ids\030\004 \003(\004\"P\n\016CSOPar"
  "tyInvite\022\026\n\010group_id\030\001 \001(\004B\004\200\246\035\001\022\021\n\tsend"
  "er_id\030\002 \001(\006\022\023\n\013sender_name\030\003 \001(\t\"P\n\016CSOL"
  "obbyInvite\022\026\n\010group_id\030\001 \001(\004B\004\200\246\035\001\022\021\n\tse"
  "nder_id\030\002 \001(\006\022\023\n\013sender_name\030\003 \001(\t\"&\n\023CM"
  "sgSystemBroadcast\022\017\n\007message\030\001 \001(\t\"R\n\021CM"
  "sgInviteToParty\022\020\n\010steam_id\030\001 \001(\006\022\026\n\016cli"
  "ent_version\030\002 \001(\r\022\023\n\013team_invite\030\003 \001(\r\";"
  "\n\025CMsgInvitationCreated\022\020\n\010group_id\030\001 \001("
  "\004\022\020\n\010steam_id\030\002 \001(\006\"h\n\027CMsgPartyInviteRe"
  "sponse\022\020\n\010party_id\030\001 \001(\004\022\016\n\006accept\030\002 \001(\010"
  "\022\026\n\016client_version\030\003 \001(\r\022\023\n\013team_invite\030"
  "\004 \001(\r\"%\n\021CMsgKickFromParty\022\020\n\010steam_id\030\001"
  " \001(\006\"\020\n\016CMsgLeaveParty\"\025\n\023CMsgServerAvai"
  "lable\"*\n\026CMsgLANServerAvailable\022\020\n\010lobby"
  "_id\030\001 \001(\006\"\322\001\n\030CSOEconGameAccountClient\022$"
  "\n\031additional_backpack_slots\030\001 \001(\r:\0010\022\034\n\024"
  "trade_ban_expiration\030\006 \001(\007\022\"\n\032bonus_xp_t"
  "imestamp_refresh\030\014 \001(\007\022\032\n\022bonus_xp_usedf"
  "lags\030\r \001(\r\022\026\n\016elevated_state\030\016 \001(\r\022\032\n\022el"
  "evated_timestamp\030\017 \001(\r\"r\n\030CSOItemCriteri"
  "aCondition\022\n\n\002op\030\001 \001(\005\022\r\n\005field\030\002 \001(\t\022\020\n"
  "\010required\030\003 \001(\010\022\023\n\013float_value\030\004 \001(\002\022\024\n\014"
  "string_value\030\005 \001(\t\"\261\002\n\017CSOItemCriteria\022\022"
  "\n\nitem_level\030\001 \001(\r\022\024\n\014item_quality\030\002 \001(\005"
  "\022\026\n\016item_level_set\030\003 \001(\010\022\030\n\020item_quality"
  "_set\030\004 \001(\010\022\031\n\021initial_inventory\030\005 \001(\r\022\030\n"
  "\020initial_quantity\030\006 \001(\r\022\033\n\023ignore_enable"
  "d_flag\030\010 \001(\010\022-\n\nconditions\030\t \003(\0132\031.CSOIt"
  "emCriteriaCondition\022\023\n\013item_rarity\030\n \001(\005"
  "\022\027\n\017item_rarity_set\030\013 \001(\010\022\023\n\013recent_only"
  "\030\014 \001(\010\"\325\003\n\rCSOItemRecipe\022\021\n\tdef_index\030\001 "
  "\001(\r\022\014\n\004name\030\002 \001(\t\022\013\n\003n_a\030\003 \001(\t\022\023\n\013desc_i"
  "nputs\030\004 \001(\t\022\024\n\014desc_outputs\030\005 \001(\t\022\014\n\004di_"
  "a\030\006 \001(\t\022\014\n\004di_b\030\007 \001(\t\022\014\n\004di_c\030\010 \001(\t\022\014\n\004d"
  "o_a\030\t \001(\t\022\014\n\004do_b\030\n \001(\t\022\014\n\004do_c\030\013 \001(\t\022\037\n"
  "\027requires_all_same_class\030\014 \001(\010\022\036\n\026requir"
  "es_all_same_slot\030\r \001(\010\022\036\n\026class_usage_fo"
  "r_output\030\016 \001(\005\022\035\n\025slot_usage_for_output\030"
  "\017 \001(\005\022\026\n\016set_for_output\030\020 \001(\005\022.\n\024input_i"
  "tems_criteria\030\024 \003(\0132\020.CSOItemCriteria\022/\n"
  "\025output_items_criteria\030\025 \003(\0132\020.CSOItemCr"
  "iteria\022\036\n\026input_item_dupe_counts\030\026 \003(\r\"M"
  "\n\025CMsgDevNewItemRequest\022\020\n\010receiver\030\001 \001("
  "\006\022\"\n\010criteria\030\002 \001(\0132\020.CSOItemCriteria\"\214\001"
  "\n\037CMsgIncrementKillCountAttribute\022\031\n\021kil"
  "ler_account_id\030\001 \001(\007\022\031\n\021victim_account_i"
  "d\030\002 \001(\007\022\017\n\007item_id\030\003 \001(\004\022\022\n\nevent_type\030\004"
  " \001(\r\022\016\n\006amount\030\005 \001(\r\"\242\002\n\020CMsgApplySticke"
  "r\022\027\n\017sticker_item_id\030\001 \001(\004\022\024\n\014item_item_"
  "id\030\002 \001(\004\022\024\n\014sticker_slot\030\003 \001(\r\022\027\n\017baseit"
  "em_defidx\030\004 \001(\r\022\024\n\014sticker_wear\030\005 \001(\002\022\030\n"
  "\020sticker_rotation\030\006 \001(\002\022\025\n\rsticker_scale"
  "\030\007 \001(\002\022\030\n\020sticker_offset_x\030\010 \001(\002\022\030\n\020stic"
  "ker_offset_y\030\t \001(\002\022\030\n\020sticker_offset_z\030\n"
  " \001(\002\022\033\n\023sticker_wear_target\030\013 \001(\002\"S\n\027CMs"
  "gModifyItemAttribute\022\017\n\007item_id\030\001 \001(\004\022\023\n"
  "\013attr_defidx\030\002 \001(\r\022\022\n\nattr_value\030\003 \001(\r\"]"
  "\n\025CMsgApplyStatTrakSwap\022\024\n\014tool_item_id\030"
  "\001 \001(\004\022\026\n\016item_1_item_id\030\002 \001(\004\022\026\n\016item_2_"
  "item_id\030\003 \001(\004\"J\n\024CMsgApplyStrangePart\022\034\n"
  "\024strange_part_item_id\030\001 \001(\004\022\024\n\014item_item"
  "_id\030\002 \001(\004\"K\n\027CMsgApplyPennantUpgrade\022\027\n\017"
  "upgrade_item_id\030\001 \001(\004\022\027\n\017pennant_item_id"
  "\030\002 \001(\004\"C\n\023CMsgApplyEggEssence\022\027\n\017essence"
  "_item_id\030\001 \001(\004\022\023\n\013egg_item_id\030\002 \001(\004\"M\n\024C"
  "SOEconItemAttribute\022\021\n\tdef_index\030\001 \001(\r\022\r"
  "\n\005value\030\002 \001(\r\022\023\n\013value_bytes\030\003 \001(\014\":\n\023CS"
  "OEconItemEquipped\022\021\n\tnew_class\030\001 \001(\r\022\020\n\010"
  "new_slot\030\002 \001(\r\"\237\003\n\013CSOEconItem\022\n\n\002id\030\001 \001"
  "(\004\022\022\n\naccount_id\030\002 \001(\r\022\021\n\tinventory\030\003 \001("
  "\r\022\021\n\tdef_index\030\004 \001(\r\022\020\n\010quantity\030\005 \001(\r\022\r"
  "\n\005level\030\006 \001(\r\022\017\n\007quality\030\007 \001(\r\022\020\n\005flags\030"
  "\010 \001(\r:\0010\022\016\n\006origin\030\t \001(\r\022\023\n\013custom_name\030"
  "\n \001(\t\022\023\n\013custom_desc\030\013 \001(\t\022(\n\tattribute\030"
  "\014 \003(\0132\025.CSOEconItemAttribute\022#\n\rinterior"
  "_item\030\r \001(\0132\014.CSOEconItem\022\025\n\006in_use\030\016 \001("
  "\010:\005false\022\020\n\005style\030\017 \001(\r:\0010\022\026\n\013original_i"
  "d\030\020 \001(\004:\0010\022,\n\016equipped_state\030\022 \003(\0132\024.CSO"
  "EconItemEquipped\022\016\n\006rarity\030\023 \001(\r\"\"\n\rCMsg"
  "SortItems\022\021\n\tsort_type\030\001 \001(\r\"^\n\020CSOEconC"
  "laimCode\022\022\n\naccount_id\030\001 \001(\r\022\021\n\tcode_typ"
  "e\030\002 \001(\r\022\025\n\rtime_acquired\030\003 \001(\r\022\014\n\004code\030\004"
  " \001(\t\"E\n\024CMsgStoreGetUserData\022\033\n\023price_sh"
  "eet_version\030\001 \001(\007\022\020\n\010currency\030\002 \001(\005\"\231\001\n\034"
  "CMsgStoreGetUserDataResponse\022\016\n\006result\030\001"
  " \001(\005\022\033\n\023currency_deprecated\030\002 \001(\005\022\032\n\022cou"
  "ntry_deprecated\030\003 \001(\t\022\033\n\023price_sheet_ver"
  "sion\030\004 \001(\007\022\023\n\013price_sheet\030\010 \001(\014\"_\n\024CMsgU"
  "pdateItemSchema\022\022\n\nitems_game\030\001 \001(\014\022\033\n\023i"
  "tem_schema_version\030\002 \001(\007\022\026\n\016items_game_u"
  "rl\030\004 \001(\t\"!\n\013CMsgGCError\022\022\n\nerror_text\030\001 "
  "\001(\t\"\035\n\033CMsgRequestInventoryRefresh\".\n\017CM"
  "sgConVarValue\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001"
  "(\t\"9\n\024CMsgReplicateConVars\022!\n\007convars\030\001 "
  "\003(\0132\020.CMsgConVarValue\"\216\001\n\013CMsgUseItem\022\017\n"
  "\007item_id\030\001 \001(\004\022\027\n\017target_steam_id\030\002 \001(\006\022"
  "\037\n\027gift__potential_targets\030\003 \003(\r\022\030\n\020duel"
  "__class_lock\030\004 \001(\r\022\032\n\022initiator_steam_id"
  "\030\005 \001(\006\"d\n\033CMsgReplayUploadedToYouTube\022\023\n"
  "\013youtube_url\030\001 \001(\t\022\034\n\024youtube_account_na"
  "me\030\002 \001(\t\022\022\n\nsession_id\030\003 \001(\004\".\n\027CMsgCons"
  "umableExhausted\022\023\n\013item_def_id\030\001 \001(\005\"\236\001\n"
  " CMsgItemAcknowledged__DEPRECATED\022\022\n\nacc"
  "ount_id\030\001 \001(\r\022\021\n\tinventory\030\002 \001(\r\022\021\n\tdef_"
  "index\030\003 \001(\r\022\017\n\007quality\030\004 \001(\r\022\016\n\006rarity\030\005"
  " \001(\r\022\016\n\006origin\030\006 \001(\r\022\017\n\007item_id\030\007 \001(\004\"\235\001"
  "\n\024CMsgSetItemPositions\022:\n\016item_positions"
  "\030\001 \003(\0132\".CMsgSetItemPositions.ItemPositi"
  "on\032I\n\014ItemPosition\022\026\n\016legacy_item_id\030\001 \001"
  "(\r\022\020\n\010position\030\002 \001(\r\022\017\n\007item_id\030\003 \001(\004\"\270\001"
  "\n\021CMsgGCReportAbuse\022\027\n\017target_steam_id\030\001"
  " \001(\006\022\023\n\013description\030\004 \001(\t\022\013\n\003gid\030\005 \001(\004\022\022"
  "\n\nabuse_type\030\002 \001(\r\022\024\n\014content_type\030\003 \001(\r"
  "\022\035\n\025target_game_server_ip\030\006 \001(\007\022\037\n\027targe"
  "t_game_server_port\030\007 \001(\r\"[\n\031CMsgGCReport"
  "AbuseResponse\022\027\n\017target_steam_id\030\001 \001(\006\022\016"
  "\n\006result\030\002 \001(\r\022\025\n\rerror_message\030\003 \001(\t\"f\n"
  "\032CMsgGCNameItemNotification\022\026\n\016player_st"
  "eamid\030\001 \001(\006\022\026\n\016item_def_index\030\002 \001(\r\022\030\n\020i"
  "tem_name_custom\030\003 \001(\t\"\266\001\n\037CMsgGCClientDi"
  "splayNotification\022+\n#notification_title_"
  "localization_key\030\001 \001(\t\022*\n\"notification_b"
  "ody_localization_key\030\002 \001(\t\022\033\n\023body_subst"
  "ring_keys\030\003 \003(\t\022\035\n\025body_substring_values"
  "\030\004 \003(\t\"1\n\027CMsgGCShowItemsPickedUp\022\026\n\016pla"
  "yer_steamid\030\001 \001(\006\"|\n CMsgGCIncrementKill"
  "CountResponse\022\037\n\021killer_account_id\030\001 \001(\r"
  "B\004\200\246\035\001\022\021\n\tnum_kills\030\002 \001(\r\022\020\n\010item_def\030\003 "
  "\001(\r\022\022\n\nlevel_type\030\004 \001(\r\"\217\001\n\030CSOEconItemD"
  "ropRateBonus\022\022\n\naccount_id\030\001 \001(\r\022\027\n\017expi"
  "ration_date\030\002 \001(\007\022\r\n\005bonus\030\003 \001(\002\022\023\n\013bonu"
  "s_count\030\004 \001(\r\022\017\n\007item_id\030\005 \001(\004\022\021\n\tdef_in"
  "dex\030\006 \001(\r\"p\n\031CSOEconItemLeagueViewPass\022\030"
  "\n\naccount_id\030\001 \001(\rB\004\200\246\035\001\022\027\n\tleague_id\030\002 "
  "\001(\rB\004\200\246\035\001\022\r\n\005admin\030\003 \001(\r\022\021\n\titemindex\030\004 "
  "\001(\r\"O\n\026CSOEconItemEventTicket\022\022\n\naccount"
  "_id\030\001 \001(\r\022\020\n\010event_id\030\002 \001(\r\022\017\n\007item_id\030\003"
  " \001(\004\"A\n\'CMsgGCItemPreviewItemBoughtNotif"
  "ication\022\026\n\016item_def_index\030\001 \001(\r\"+\n\031CMsgG"
  "CStorePurchaseCancel\022\016\n\006txn_id\030\001 \001(\004\"3\n!"
  "CMsgGCStorePurchaseCancelResponse\022\016\n\006res"
  "ult\030\001 \001(\r\"-\n\033CMsgGCStorePurchaseFinalize"
  "\022\016\n\006txn_id\030\001 \001(\004\"G\n#CMsgGCStorePurchaseF"
  "inalizeResponse\022\016\n\006result\030\001 \001(\r\022\020\n\010item_"
  "ids\030\002 \003(\004\"I\n\033CMsgGCBannedWordListRequest"
  "\022\031\n\021ban_list_group_id\030\001 \001(\r\022\017\n\007word_id\030\002"
  " \001(\r\"\034\n\032CMsgGCRequestAnnouncements\"\202\001\n\"C"
  "MsgGCRequestAnnouncementsResponse\022\032\n\022ann"
  "ouncement_title\030\001 \001(\t\022\024\n\014announcement\030\002 "
  "\001(\t\022\027\n\017nextmatch_title\030\003 \001(\t\022\021\n\tnextmatc"
  "h\030\004 \001(\t\"u\n\020CMsgGCBannedWord\022\017\n\007word_id\030\001"
  " \001(\r\022B\n\tword_type\030\002 \001(\0162\022.GC_BannedWordT"
  "ype:\033GC_BANNED_WORD_DISABLE_WORD\022\014\n\004word"
  "\030\003 \001(\t\"_\n\034CMsgGCBannedWordListResponse\022\031"
  "\n\021ban_list_group_id\030\001 \001(\r\022$\n\tword_list\030\002"
  " \003(\0132\021.CMsgGCBannedWord\"U\n!CMsgGCToGCBan"
  "nedWordListBroadcast\0220\n\tbroadcast\030\001 \001(\0132"
  "\035.CMsgGCBannedWordListResponse\"3\n\037CMsgGC"
  "ToGCBannedWordListUpdated\022\020\n\010group_id\030\001 "
  "\001(\r\"\?\n\027CMsgGCToGCDirtySDOCache\022\020\n\010sdo_ty"
  "pe\030\001 \001(\r\022\022\n\nkey_uint64\030\002 \001(\004\"G\n\037CMsgGCTo"
  "GCDirtyMultipleSDOCache\022\020\n\010sdo_type\030\001 \001("
  "\r\022\022\n\nkey_uint64\030\002 \003(\004\"H\n\021CMsgGCCollectIt"
  "em\022\032\n\022collection_item_id\030\001 \001(\004\022\027\n\017subjec"
  "t_item_id\030\002 \001(\004\"\024\n\022CMsgSDONoMemcached\"/\n"
  "\033CMsgGCToGCUpdateSQLKeyValue\022\020\n\010key_name"
  "\030\001 \001(\t\"-\n\031CMsgGCToGCIsTrustedServer\022\020\n\010s"
  "team_id\030\001 \001(\006\"7\n!CMsgGCToGCIsTrustedServ"
  "erResponse\022\022\n\nis_trusted\030\001 \001(\010\"8\n!CMsgGC"
  "ToGCBroadcastConsoleCommand\022\023\n\013con_comma"
  "nd\030\001 \001(\t\"4\n\032CMsgGCServerVersionUpdated\022\026"
  "\n\016server_version\030\001 \001(\r\"4\n\032CMsgGCClientVe"
  "rsionUpdated\022\026\n\016client_version\030\001 \001(\r\" \n\036"
  "CMsgGCToGCWebAPIAccountChanged\"^\n\"CMsgGC"
  "ToGCRequestPassportItemGrant\022\020\n\010steam_id"
  "\030\001 \001(\006\022\021\n\tleague_id\030\002 \001(\r\022\023\n\013reward_flag"
  "\030\003 \001(\005\"\350\004\n\022CMsgGameServerInfo\022\035\n\025server_"
  "public_ip_addr\030\001 \001(\007\022\036\n\026server_private_i"
  "p_addr\030\002 \001(\007\022\023\n\013server_port\030\003 \001(\r\022\026\n\016ser"
  "ver_tv_port\030\004 \001(\r\022\022\n\nserver_key\030\005 \001(\t\022\032\n"
  "\022server_hibernation\030\006 \001(\010\022@\n\013server_type"
  "\030\007 \001(\0162\036.CMsgGameServerInfo.ServerType:\013"
  "UNSPECIFIED\022\025\n\rserver_region\030\010 \001(\r\022\026\n\016se"
  "rver_loadavg\030\t \001(\002\022 \n\030server_tv_broadcas"
  "t_time\030\n \001(\002\022\030\n\020server_game_time\030\013 \001(\002\022\'"
  "\n\037server_relay_connected_steam_id\030\014 \001(\006\022"
  "\027\n\017relay_slots_max\030\r \001(\r\022\030\n\020relays_conne"
  "cted\030\016 \001(\005\022\037\n\027relay_clients_connected\030\017 "
  "\001(\005\022$\n\034relayed_game_server_steam_id\030\020 \001("
  "\006\022\032\n\022parent_relay_count\030\021 \001(\r\022\026\n\016tv_secr"
  "et_code\030\022 \001(\006\"2\n\nServerType\022\017\n\013UNSPECIFI"
  "ED\020\000\022\010\n\004GAME\020\001\022\t\n\005PROXY\020\002\"\205\001\n\020CSOEconEqu"
  "ipSlot\022\030\n\naccount_id\030\001 \001(\rB\004\200\246\035\001\022\026\n\010clas"
  "s_id\030\002 \001(\rB\004\200\246\035\001\022\025\n\007slot_id\030\003 \001(\rB\004\200\246\035\001\022"
  "\017\n\007item_id\030\004 \001(\004\022\027\n\017item_definition\030\005 \001("
  "\r\"I\n\023CMsgAdjustEquipSlot\022\020\n\010class_id\030\001 \001"
  "(\r\022\017\n\007slot_id\030\002 \001(\r\022\017\n\007item_id\030\003 \001(\004\"O\n\024"
  "CMsgAdjustEquipSlots\022#\n\005slots\030\001 \003(\0132\024.CM"
  "sgAdjustEquipSlot\022\022\n\nchange_num\030\002 \001(\r\"l\n"
  "\rCMsgOpenCrate\022\024\n\014tool_item_id\030\001 \001(\004\022\027\n\017"
  "subject_item_id\030\002 \001(\004\022\022\n\nfor_rental\030\003 \001("
  "\010\022\030\n\020points_remaining\030\004 \001(\r\"\223\001\n\024CSOEconR"
  "entalHistory\022\030\n\naccount_id\030\001 \001(\rB\004\200\246\035\001\022\033"
  "\n\rcrate_item_id\030\002 \001(\004B\004\200\246\035\001\022\027\n\017crate_def"
  "_index\030\003 \001(\r\022\022\n\nissue_date\030\004 \001(\r\022\027\n\017expi"
  "ration_date\030\005 \001(\r\"8\n\037CMsgAcknowledgeRent"
  "alExpiration\022\025\n\rcrate_item_id\030\001 \001(\004*\307\003\n\n"
  "EGCBaseMsg\022\032\n\025k_EMsgGCSystemMessage\020\241\037\022\035"
  "\n\030k_EMsgGCReplicateConVars\020\242\037\022\032\n\025k_EMsgG"
  "CConVarUpdated\020\243\037\022\024\n\017k_EMsgGCInQueue\020\250\037\022"
  "\032\n\025k_EMsgGCInviteToParty\020\225#\022\036\n\031k_EMsgGCI"
  "nvitationCreated\020\226#\022 \n\033k_EMsgGCPartyInvi"
  "teResponse\020\227#\022\032\n\025k_EMsgGCKickFromParty\020\230"
  "#\022\027\n\022k_EMsgGCLeaveParty\020\231#\022\034\n\027k_EMsgGCSe"
  "rverAvailable\020\232#\022\"\n\035k_EMsgGCClientConnec"
  "tToServer\020\233#\022\033\n\026k_EMsgGCGameServerInfo\020\234"
  "#\022\022\n\rk_EMsgGCError\020\235#\022%\n k_EMsgGCReplay_"
  "UploadedToYouTube\020\236#\022\037\n\032k_EMsgGCLANServe"
  "rAvailable\020\237#*Y\n\027EGCBaseProtoObjectTypes"
  "\022\036\n\031k_EProtoObjectPartyInvite\020\351\007\022\036\n\031k_EP"
  "rotoObjectLobbyInvite\020\352\007*T\n\021GC_BannedWor"
  "dType\022\037\n\033GC_BANNED_WORD_DISABLE_WORD\020\000\022\036"
  "\n\032GC_BANNED_WORD_ENABLE_WORD\020\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_base_5fgcmessages_2eproto_deps[1] = {
  &::descriptor_table_steammessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_base_5fgcmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_base_5fgcmessages_2eproto = {
    false, false, 9350, descriptor_table_protodef_base_5fgcmessages_2eproto,
    "base_gcmessages.proto",
    &descriptor_table_base_5fgcmessages_2eproto_once, descriptor_table_base_5fgcmessages_2eproto_deps, 1, 83,
    schemas, file_default_instances, TableStruct_base_5fgcmessages_2eproto::offsets,
    file_level_metadata_base_5fgcmessages_2eproto, file_level_enum_descriptors_base_5fgcmessages_2eproto,
    file_level_service_descriptors_base_5fgcmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_base_5fgcmessages_2eproto_getter() {
  return &descriptor_table_base_5fgcmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_base_5fgcmessages_2eproto(&descriptor_table_base_5fgcmessages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgGameServerInfo_ServerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_base_5fgcmessages_2eproto);
  return file_level_enum_descriptors_base_5fgcmessages_2eproto[0];
}
bool CMsgGameServerInfo_ServerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgGameServerInfo_ServerType CMsgGameServerInfo::UNSPECIFIED;
constexpr CMsgGameServerInfo_ServerType CMsgGameServerInfo::GAME;
constexpr CMsgGameServerInfo_ServerType CMsgGameServerInfo::PROXY;
constexpr CMsgGameServerInfo_ServerType CMsgGameServerInfo::ServerType_MIN;
constexpr CMsgGameServerInfo_ServerType CMsgGameServerInfo::ServerType_MAX;
constexpr int CMsgGameServerInfo::ServerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGCBaseMsg_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_base_5fgcmessages_2eproto);
  return file_level_enum_descriptors_base_5fgcmessages_2eproto[1];
}
bool EGCBaseMsg_IsValid(int value) {
  switch (value) {
    case 4001:
    case 4002:
    case 4003:
    case 4008:
    case 4501:
    case 4502:
    case 4503:
    case 4504:
    case 4505:
    case 4506:
    case 4507:
    case 4508:
    case 4509:
    case 4510:
    case 4511:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGCBaseProtoObjectTypes_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_base_5fgcmessages_2eproto);
  return file_level_enum_descriptors_base_5fgcmessages_2eproto[2];
}
bool EGCBaseProtoObjectTypes_IsValid(int value) {
  switch (value) {
    case 1001:
    case 1002:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GC_BannedWordType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_base_5fgcmessages_2eproto);
  return file_level_enum_descriptors_base_5fgcmessages_2eproto[3];
}
bool GC_BannedWordType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CGCStorePurchaseInit_LineItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCStorePurchaseInit_LineItem>()._impl_._has_bits_);
  static void set_has_item_def_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cost_in_local_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_purchase_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_supplemental_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CGCStorePurchaseInit_LineItem::CGCStorePurchaseInit_LineItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCStorePurchaseInit_LineItem)
}
CGCStorePurchaseInit_LineItem::CGCStorePurchaseInit_LineItem(const CGCStorePurchaseInit_LineItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCStorePurchaseInit_LineItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.cost_in_local_currency_){}
    , decltype(_impl_.purchase_type_){}
    , decltype(_impl_.supplemental_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_def_id_, &from._impl_.item_def_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.supplemental_data_) -
    reinterpret_cast<char*>(&_impl_.item_def_id_)) + sizeof(_impl_.supplemental_data_));
  // @@protoc_insertion_point(copy_constructor:CGCStorePurchaseInit_LineItem)
}

inline void CGCStorePurchaseInit_LineItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){0u}
    , decltype(_impl_.quantity_){0u}
    , decltype(_impl_.cost_in_local_currency_){0u}
    , decltype(_impl_.purchase_type_){0u}
    , decltype(_impl_.supplemental_data_){uint64_t{0u}}
  };
}

CGCStorePurchaseInit_LineItem::~CGCStorePurchaseInit_LineItem() {
  // @@protoc_insertion_point(destructor:CGCStorePurchaseInit_LineItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCStorePurchaseInit_LineItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCStorePurchaseInit_LineItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCStorePurchaseInit_LineItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCStorePurchaseInit_LineItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.item_def_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.supplemental_data_) -
        reinterpret_cast<char*>(&_impl_.item_def_id_)) + sizeof(_impl_.supplemental_data_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCStorePurchaseInit_LineItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_def_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def_id(&has_bits);
          _impl_.item_def_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cost_in_local_currency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cost_in_local_currency(&has_bits);
          _impl_.cost_in_local_currency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 purchase_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_purchase_type(&has_bits);
          _impl_.purchase_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 supplemental_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_supplemental_data(&has_bits);
          _impl_.supplemental_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCStorePurchaseInit_LineItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCStorePurchaseInit_LineItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_def_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_def_id(), target);
  }

  // optional uint32 quantity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_quantity(), target);
  }

  // optional uint32 cost_in_local_currency = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_cost_in_local_currency(), target);
  }

  // optional uint32 purchase_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_purchase_type(), target);
  }

  // optional uint64 supplemental_data = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_supplemental_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCStorePurchaseInit_LineItem)
  return target;
}

size_t CGCStorePurchaseInit_LineItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCStorePurchaseInit_LineItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 item_def_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def_id());
    }

    // optional uint32 quantity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quantity());
    }

    // optional uint32 cost_in_local_currency = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost_in_local_currency());
    }

    // optional uint32 purchase_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_purchase_type());
    }

    // optional uint64 supplemental_data = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_supplemental_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCStorePurchaseInit_LineItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCStorePurchaseInit_LineItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCStorePurchaseInit_LineItem::GetClassData() const { return &_class_data_; }


void CGCStorePurchaseInit_LineItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCStorePurchaseInit_LineItem*>(&to_msg);
  auto& from = static_cast<const CGCStorePurchaseInit_LineItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCStorePurchaseInit_LineItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_def_id_ = from._impl_.item_def_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cost_in_local_currency_ = from._impl_.cost_in_local_currency_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.purchase_type_ = from._impl_.purchase_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.supplemental_data_ = from._impl_.supplemental_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCStorePurchaseInit_LineItem::CopyFrom(const CGCStorePurchaseInit_LineItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCStorePurchaseInit_LineItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCStorePurchaseInit_LineItem::IsInitialized() const {
  return true;
}

void CGCStorePurchaseInit_LineItem::InternalSwap(CGCStorePurchaseInit_LineItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCStorePurchaseInit_LineItem, _impl_.supplemental_data_)
      + sizeof(CGCStorePurchaseInit_LineItem::_impl_.supplemental_data_)
      - PROTOBUF_FIELD_OFFSET(CGCStorePurchaseInit_LineItem, _impl_.item_def_id_)>(
          reinterpret_cast<char*>(&_impl_.item_def_id_),
          reinterpret_cast<char*>(&other->_impl_.item_def_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCStorePurchaseInit_LineItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[0]);
}

// ===================================================================

class CMsgGCStorePurchaseInit::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseInit>()._impl_._has_bits_);
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCStorePurchaseInit::CMsgGCStorePurchaseInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseInit)
}
CMsgGCStorePurchaseInit::CMsgGCStorePurchaseInit(const CMsgGCStorePurchaseInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseInit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.line_items_){from._impl_.line_items_}
    , decltype(_impl_.country_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.currency_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    _this->_impl_.country_.Set(from._internal_country(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.language_, &from._impl_.language_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currency_) -
    reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.currency_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseInit)
}

inline void CMsgGCStorePurchaseInit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.line_items_){arena}
    , decltype(_impl_.country_){}
    , decltype(_impl_.language_){0}
    , decltype(_impl_.currency_){0}
  };
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCStorePurchaseInit::~CMsgGCStorePurchaseInit() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.line_items_.~RepeatedPtrField();
  _impl_.country_.Destroy();
}

void CMsgGCStorePurchaseInit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseInit::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.line_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.country_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.language_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currency_) -
        reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.currency_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string country = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCStorePurchaseInit.country");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 currency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_currency(&has_bits);
          _impl_.currency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CGCStorePurchaseInit_LineItem line_items = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_line_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string country = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCStorePurchaseInit.country");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country(), target);
  }

  // optional int32 language = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_language(), target);
  }

  // optional int32 currency = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_currency(), target);
  }

  // repeated .CGCStorePurchaseInit_LineItem line_items = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_line_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_line_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseInit)
  return target;
}

size_t CMsgGCStorePurchaseInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGCStorePurchaseInit_LineItem line_items = 4;
  total_size += 1UL * this->_internal_line_items_size();
  for (const auto& msg : this->_impl_.line_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string country = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional int32 language = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_language());
    }

    // optional int32 currency = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currency());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseInit::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseInit*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseInit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseInit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.line_items_.MergeFrom(from._impl_.line_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.currency_ = from._impl_.currency_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseInit::CopyFrom(const CMsgGCStorePurchaseInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseInit::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseInit::InternalSwap(CMsgGCStorePurchaseInit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.line_items_.InternalSwap(&other->_impl_.line_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_, lhs_arena,
      &other->_impl_.country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCStorePurchaseInit, _impl_.currency_)
      + sizeof(CMsgGCStorePurchaseInit::_impl_.currency_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCStorePurchaseInit, _impl_.language_)>(
          reinterpret_cast<char*>(&_impl_.language_),
          reinterpret_cast<char*>(&other->_impl_.language_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[1]);
}

// ===================================================================

class CMsgGCStorePurchaseInitResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseInitResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCStorePurchaseInitResponse::CMsgGCStorePurchaseInitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseInitResponse)
}
CMsgGCStorePurchaseInitResponse::CMsgGCStorePurchaseInitResponse(const CMsgGCStorePurchaseInitResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseInitResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_ids_){from._impl_.item_ids_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.txn_id_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.txn_id_, &from._impl_.txn_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_) -
    reinterpret_cast<char*>(&_impl_.txn_id_)) + sizeof(_impl_.result_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseInitResponse)
}

inline void CMsgGCStorePurchaseInitResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_ids_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.txn_id_){uint64_t{0u}}
    , decltype(_impl_.result_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCStorePurchaseInitResponse::~CMsgGCStorePurchaseInitResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseInitResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseInitResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_ids_.~RepeatedField();
  _impl_.url_.Destroy();
}

void CMsgGCStorePurchaseInitResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseInitResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseInitResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.txn_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.result_) -
        reinterpret_cast<char*>(&_impl_.txn_id_)) + sizeof(_impl_.result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseInitResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 txn_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_txn_id(&has_bits);
          _impl_.txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCStorePurchaseInitResponse.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 item_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseInitResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseInitResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 result = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  // optional uint64 txn_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txn_id(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCStorePurchaseInitResponse.url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  // repeated uint64 item_ids = 4;
  for (int i = 0, n = this->_internal_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_item_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseInitResponse)
  return target;
}

size_t CMsgGCStorePurchaseInitResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseInitResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 item_ids = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_item_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional uint64 txn_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());
    }

    // optional int32 result = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseInitResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseInitResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseInitResponse::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseInitResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseInitResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseInitResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseInitResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_ids_.MergeFrom(from._impl_.item_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txn_id_ = from._impl_.txn_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseInitResponse::CopyFrom(const CMsgGCStorePurchaseInitResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseInitResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseInitResponse::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseInitResponse::InternalSwap(CMsgGCStorePurchaseInitResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.item_ids_.InternalSwap(&other->_impl_.item_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCStorePurchaseInitResponse, _impl_.result_)
      + sizeof(CMsgGCStorePurchaseInitResponse::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCStorePurchaseInitResponse, _impl_.txn_id_)>(
          reinterpret_cast<char*>(&_impl_.txn_id_),
          reinterpret_cast<char*>(&other->_impl_.txn_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseInitResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[2]);
}

// ===================================================================

class CSOPartyInvite::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOPartyInvite>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sender_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSOPartyInvite::CSOPartyInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOPartyInvite)
}
CSOPartyInvite::CSOPartyInvite(const CSOPartyInvite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOPartyInvite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_name_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.sender_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sender_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sender_name()) {
    _this->_impl_.sender_name_.Set(from._internal_sender_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sender_id_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.sender_id_));
  // @@protoc_insertion_point(copy_constructor:CSOPartyInvite)
}

inline void CSOPartyInvite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_name_){}
    , decltype(_impl_.group_id_){uint64_t{0u}}
    , decltype(_impl_.sender_id_){uint64_t{0u}}
  };
  _impl_.sender_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOPartyInvite::~CSOPartyInvite() {
  // @@protoc_insertion_point(destructor:CSOPartyInvite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOPartyInvite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sender_name_.Destroy();
}

void CSOPartyInvite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOPartyInvite::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOPartyInvite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.sender_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sender_id_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.sender_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOPartyInvite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 group_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sender_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_sender_id(&has_bits);
          _impl_.sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string sender_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sender_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOPartyInvite.sender_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOPartyInvite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOPartyInvite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 group_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_group_id(), target);
  }

  // optional fixed64 sender_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_sender_id(), target);
  }

  // optional string sender_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sender_name().data(), static_cast<int>(this->_internal_sender_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOPartyInvite.sender_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sender_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOPartyInvite)
  return target;
}

size_t CSOPartyInvite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOPartyInvite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sender_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sender_name());
    }

    // optional uint64 group_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_group_id());
    }

    // optional fixed64 sender_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOPartyInvite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOPartyInvite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOPartyInvite::GetClassData() const { return &_class_data_; }


void CSOPartyInvite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOPartyInvite*>(&to_msg);
  auto& from = static_cast<const CSOPartyInvite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOPartyInvite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sender_name(from._internal_sender_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sender_id_ = from._impl_.sender_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOPartyInvite::CopyFrom(const CSOPartyInvite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOPartyInvite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOPartyInvite::IsInitialized() const {
  return true;
}

void CSOPartyInvite::InternalSwap(CSOPartyInvite* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sender_name_, lhs_arena,
      &other->_impl_.sender_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOPartyInvite, _impl_.sender_id_)
      + sizeof(CSOPartyInvite::_impl_.sender_id_)
      - PROTOBUF_FIELD_OFFSET(CSOPartyInvite, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOPartyInvite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[3]);
}

// ===================================================================

class CSOLobbyInvite::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOLobbyInvite>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sender_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSOLobbyInvite::CSOLobbyInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOLobbyInvite)
}
CSOLobbyInvite::CSOLobbyInvite(const CSOLobbyInvite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOLobbyInvite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_name_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.sender_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sender_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sender_name()) {
    _this->_impl_.sender_name_.Set(from._internal_sender_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sender_id_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.sender_id_));
  // @@protoc_insertion_point(copy_constructor:CSOLobbyInvite)
}

inline void CSOLobbyInvite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_name_){}
    , decltype(_impl_.group_id_){uint64_t{0u}}
    , decltype(_impl_.sender_id_){uint64_t{0u}}
  };
  _impl_.sender_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOLobbyInvite::~CSOLobbyInvite() {
  // @@protoc_insertion_point(destructor:CSOLobbyInvite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOLobbyInvite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sender_name_.Destroy();
}

void CSOLobbyInvite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOLobbyInvite::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOLobbyInvite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.sender_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sender_id_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.sender_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOLobbyInvite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 group_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sender_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_sender_id(&has_bits);
          _impl_.sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string sender_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sender_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOLobbyInvite.sender_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOLobbyInvite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOLobbyInvite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 group_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_group_id(), target);
  }

  // optional fixed64 sender_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_sender_id(), target);
  }

  // optional string sender_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sender_name().data(), static_cast<int>(this->_internal_sender_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOLobbyInvite.sender_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sender_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOLobbyInvite)
  return target;
}

size_t CSOLobbyInvite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOLobbyInvite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sender_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sender_name());
    }

    // optional uint64 group_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_group_id());
    }

    // optional fixed64 sender_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOLobbyInvite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOLobbyInvite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOLobbyInvite::GetClassData() const { return &_class_data_; }


void CSOLobbyInvite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOLobbyInvite*>(&to_msg);
  auto& from = static_cast<const CSOLobbyInvite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOLobbyInvite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sender_name(from._internal_sender_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sender_id_ = from._impl_.sender_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOLobbyInvite::CopyFrom(const CSOLobbyInvite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOLobbyInvite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOLobbyInvite::IsInitialized() const {
  return true;
}

void CSOLobbyInvite::InternalSwap(CSOLobbyInvite* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sender_name_, lhs_arena,
      &other->_impl_.sender_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOLobbyInvite, _impl_.sender_id_)
      + sizeof(CSOLobbyInvite::_impl_.sender_id_)
      - PROTOBUF_FIELD_OFFSET(CSOLobbyInvite, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOLobbyInvite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[4]);
}

// ===================================================================

class CMsgSystemBroadcast::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemBroadcast>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSystemBroadcast::CMsgSystemBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSystemBroadcast)
}
CMsgSystemBroadcast::CMsgSystemBroadcast(const CMsgSystemBroadcast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSystemBroadcast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemBroadcast)
}

inline void CMsgSystemBroadcast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSystemBroadcast::~CMsgSystemBroadcast() {
  // @@protoc_insertion_point(destructor:CMsgSystemBroadcast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSystemBroadcast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void CMsgSystemBroadcast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSystemBroadcast::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemBroadcast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemBroadcast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSystemBroadcast.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemBroadcast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemBroadcast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemBroadcast.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemBroadcast)
  return target;
}

size_t CMsgSystemBroadcast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemBroadcast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemBroadcast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSystemBroadcast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemBroadcast::GetClassData() const { return &_class_data_; }


void CMsgSystemBroadcast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSystemBroadcast*>(&to_msg);
  auto& from = static_cast<const CMsgSystemBroadcast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemBroadcast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemBroadcast::CopyFrom(const CMsgSystemBroadcast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemBroadcast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemBroadcast::IsInitialized() const {
  return true;
}

void CMsgSystemBroadcast::InternalSwap(CMsgSystemBroadcast* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemBroadcast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[5]);
}

// ===================================================================

class CMsgInviteToParty::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgInviteToParty>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_invite(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgInviteToParty::CMsgInviteToParty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgInviteToParty)
}
CMsgInviteToParty::CMsgInviteToParty(const CMsgInviteToParty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgInviteToParty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.team_invite_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_invite_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.team_invite_));
  // @@protoc_insertion_point(copy_constructor:CMsgInviteToParty)
}

inline void CMsgInviteToParty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.client_version_){0u}
    , decltype(_impl_.team_invite_){0u}
  };
}

CMsgInviteToParty::~CMsgInviteToParty() {
  // @@protoc_insertion_point(destructor:CMsgInviteToParty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgInviteToParty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgInviteToParty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgInviteToParty::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgInviteToParty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_invite_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.team_invite_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgInviteToParty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_version(&has_bits);
          _impl_.client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_invite = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_invite(&has_bits);
          _impl_.team_invite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgInviteToParty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgInviteToParty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional uint32 client_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_version(), target);
  }

  // optional uint32 team_invite = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_invite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgInviteToParty)
  return target;
}

size_t CMsgInviteToParty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgInviteToParty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 client_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 team_invite = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_invite());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgInviteToParty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgInviteToParty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgInviteToParty::GetClassData() const { return &_class_data_; }


void CMsgInviteToParty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgInviteToParty*>(&to_msg);
  auto& from = static_cast<const CMsgInviteToParty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgInviteToParty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.client_version_ = from._impl_.client_version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_invite_ = from._impl_.team_invite_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgInviteToParty::CopyFrom(const CMsgInviteToParty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgInviteToParty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgInviteToParty::IsInitialized() const {
  return true;
}

void CMsgInviteToParty::InternalSwap(CMsgInviteToParty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgInviteToParty, _impl_.team_invite_)
      + sizeof(CMsgInviteToParty::_impl_.team_invite_)
      - PROTOBUF_FIELD_OFFSET(CMsgInviteToParty, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgInviteToParty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[6]);
}

// ===================================================================

class CMsgInvitationCreated::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgInvitationCreated>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgInvitationCreated::CMsgInvitationCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgInvitationCreated)
}
CMsgInvitationCreated::CMsgInvitationCreated(const CMsgInvitationCreated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgInvitationCreated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.steam_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.steam_id_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.steam_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgInvitationCreated)
}

inline void CMsgInvitationCreated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){uint64_t{0u}}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
  };
}

CMsgInvitationCreated::~CMsgInvitationCreated() {
  // @@protoc_insertion_point(destructor:CMsgInvitationCreated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgInvitationCreated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgInvitationCreated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgInvitationCreated::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgInvitationCreated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.steam_id_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.steam_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgInvitationCreated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steam_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgInvitationCreated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgInvitationCreated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_group_id(), target);
  }

  // optional fixed64 steam_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgInvitationCreated)
  return target;
}

size_t CMsgInvitationCreated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgInvitationCreated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 group_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_group_id());
    }

    // optional fixed64 steam_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgInvitationCreated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgInvitationCreated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgInvitationCreated::GetClassData() const { return &_class_data_; }


void CMsgInvitationCreated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgInvitationCreated*>(&to_msg);
  auto& from = static_cast<const CMsgInvitationCreated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgInvitationCreated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgInvitationCreated::CopyFrom(const CMsgInvitationCreated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgInvitationCreated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgInvitationCreated::IsInitialized() const {
  return true;
}

void CMsgInvitationCreated::InternalSwap(CMsgInvitationCreated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgInvitationCreated, _impl_.steam_id_)
      + sizeof(CMsgInvitationCreated::_impl_.steam_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgInvitationCreated, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgInvitationCreated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[7]);
}

// ===================================================================

class CMsgPartyInviteResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPartyInviteResponse>()._impl_._has_bits_);
  static void set_has_party_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_accept(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_team_invite(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgPartyInviteResponse::CMsgPartyInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPartyInviteResponse)
}
CMsgPartyInviteResponse::CMsgPartyInviteResponse(const CMsgPartyInviteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPartyInviteResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.party_id_){}
    , decltype(_impl_.accept_){}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.team_invite_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.party_id_, &from._impl_.party_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_invite_) -
    reinterpret_cast<char*>(&_impl_.party_id_)) + sizeof(_impl_.team_invite_));
  // @@protoc_insertion_point(copy_constructor:CMsgPartyInviteResponse)
}

inline void CMsgPartyInviteResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.party_id_){uint64_t{0u}}
    , decltype(_impl_.accept_){false}
    , decltype(_impl_.client_version_){0u}
    , decltype(_impl_.team_invite_){0u}
  };
}

CMsgPartyInviteResponse::~CMsgPartyInviteResponse() {
  // @@protoc_insertion_point(destructor:CMsgPartyInviteResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPartyInviteResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPartyInviteResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPartyInviteResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPartyInviteResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.party_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_invite_) -
        reinterpret_cast<char*>(&_impl_.party_id_)) + sizeof(_impl_.team_invite_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPartyInviteResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 party_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_party_id(&has_bits);
          _impl_.party_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool accept = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_accept(&has_bits);
          _impl_.accept_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_client_version(&has_bits);
          _impl_.client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_invite = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_invite(&has_bits);
          _impl_.team_invite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPartyInviteResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPartyInviteResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 party_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_party_id(), target);
  }

  // optional bool accept = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_accept(), target);
  }

  // optional uint32 client_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_client_version(), target);
  }

  // optional uint32 team_invite = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team_invite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPartyInviteResponse)
  return target;
}

size_t CMsgPartyInviteResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPartyInviteResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 party_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_party_id());
    }

    // optional bool accept = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 client_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 team_invite = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_invite());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPartyInviteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPartyInviteResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPartyInviteResponse::GetClassData() const { return &_class_data_; }


void CMsgPartyInviteResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPartyInviteResponse*>(&to_msg);
  auto& from = static_cast<const CMsgPartyInviteResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPartyInviteResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.party_id_ = from._impl_.party_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accept_ = from._impl_.accept_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_version_ = from._impl_.client_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_invite_ = from._impl_.team_invite_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPartyInviteResponse::CopyFrom(const CMsgPartyInviteResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPartyInviteResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPartyInviteResponse::IsInitialized() const {
  return true;
}

void CMsgPartyInviteResponse::InternalSwap(CMsgPartyInviteResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPartyInviteResponse, _impl_.team_invite_)
      + sizeof(CMsgPartyInviteResponse::_impl_.team_invite_)
      - PROTOBUF_FIELD_OFFSET(CMsgPartyInviteResponse, _impl_.party_id_)>(
          reinterpret_cast<char*>(&_impl_.party_id_),
          reinterpret_cast<char*>(&other->_impl_.party_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPartyInviteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[8]);
}

// ===================================================================

class CMsgKickFromParty::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgKickFromParty>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgKickFromParty::CMsgKickFromParty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgKickFromParty)
}
CMsgKickFromParty::CMsgKickFromParty(const CMsgKickFromParty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgKickFromParty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.steam_id_ = from._impl_.steam_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgKickFromParty)
}

inline void CMsgKickFromParty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
  };
}

CMsgKickFromParty::~CMsgKickFromParty() {
  // @@protoc_insertion_point(destructor:CMsgKickFromParty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgKickFromParty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgKickFromParty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgKickFromParty::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgKickFromParty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgKickFromParty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgKickFromParty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgKickFromParty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgKickFromParty)
  return target;
}

size_t CMsgKickFromParty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgKickFromParty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steam_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgKickFromParty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgKickFromParty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgKickFromParty::GetClassData() const { return &_class_data_; }


void CMsgKickFromParty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgKickFromParty*>(&to_msg);
  auto& from = static_cast<const CMsgKickFromParty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgKickFromParty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steam_id()) {
    _this->_internal_set_steam_id(from._internal_steam_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgKickFromParty::CopyFrom(const CMsgKickFromParty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgKickFromParty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgKickFromParty::IsInitialized() const {
  return true;
}

void CMsgKickFromParty::InternalSwap(CMsgKickFromParty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steam_id_, other->_impl_.steam_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgKickFromParty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[9]);
}

// ===================================================================

class CMsgLeaveParty::_Internal {
 public:
};

CMsgLeaveParty::CMsgLeaveParty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgLeaveParty)
}
CMsgLeaveParty::CMsgLeaveParty(const CMsgLeaveParty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgLeaveParty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgLeaveParty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLeaveParty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLeaveParty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgLeaveParty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[10]);
}

// ===================================================================

class CMsgServerAvailable::_Internal {
 public:
};

CMsgServerAvailable::CMsgServerAvailable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgServerAvailable)
}
CMsgServerAvailable::CMsgServerAvailable(const CMsgServerAvailable& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgServerAvailable* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgServerAvailable)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerAvailable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerAvailable::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerAvailable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[11]);
}

// ===================================================================

class CMsgLANServerAvailable::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgLANServerAvailable>()._impl_._has_bits_);
  static void set_has_lobby_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgLANServerAvailable::CMsgLANServerAvailable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLANServerAvailable)
}
CMsgLANServerAvailable::CMsgLANServerAvailable(const CMsgLANServerAvailable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLANServerAvailable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lobby_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.lobby_id_ = from._impl_.lobby_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgLANServerAvailable)
}

inline void CMsgLANServerAvailable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lobby_id_){uint64_t{0u}}
  };
}

CMsgLANServerAvailable::~CMsgLANServerAvailable() {
  // @@protoc_insertion_point(destructor:CMsgLANServerAvailable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLANServerAvailable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgLANServerAvailable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLANServerAvailable::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLANServerAvailable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lobby_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLANServerAvailable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 lobby_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_lobby_id(&has_bits);
          _impl_.lobby_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLANServerAvailable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLANServerAvailable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 lobby_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_lobby_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLANServerAvailable)
  return target;
}

size_t CMsgLANServerAvailable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLANServerAvailable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 lobby_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLANServerAvailable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLANServerAvailable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLANServerAvailable::GetClassData() const { return &_class_data_; }


void CMsgLANServerAvailable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLANServerAvailable*>(&to_msg);
  auto& from = static_cast<const CMsgLANServerAvailable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLANServerAvailable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lobby_id()) {
    _this->_internal_set_lobby_id(from._internal_lobby_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLANServerAvailable::CopyFrom(const CMsgLANServerAvailable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLANServerAvailable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLANServerAvailable::IsInitialized() const {
  return true;
}

void CMsgLANServerAvailable::InternalSwap(CMsgLANServerAvailable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lobby_id_, other->_impl_.lobby_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLANServerAvailable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[12]);
}

// ===================================================================

class CSOEconGameAccountClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconGameAccountClient>()._impl_._has_bits_);
  static void set_has_additional_backpack_slots(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trade_ban_expiration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonus_xp_timestamp_refresh(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bonus_xp_usedflags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_elevated_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_elevated_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CSOEconGameAccountClient::CSOEconGameAccountClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconGameAccountClient)
}
CSOEconGameAccountClient::CSOEconGameAccountClient(const CSOEconGameAccountClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconGameAccountClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_backpack_slots_){}
    , decltype(_impl_.trade_ban_expiration_){}
    , decltype(_impl_.bonus_xp_timestamp_refresh_){}
    , decltype(_impl_.bonus_xp_usedflags_){}
    , decltype(_impl_.elevated_state_){}
    , decltype(_impl_.elevated_timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.additional_backpack_slots_, &from._impl_.additional_backpack_slots_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elevated_timestamp_) -
    reinterpret_cast<char*>(&_impl_.additional_backpack_slots_)) + sizeof(_impl_.elevated_timestamp_));
  // @@protoc_insertion_point(copy_constructor:CSOEconGameAccountClient)
}

inline void CSOEconGameAccountClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_backpack_slots_){0u}
    , decltype(_impl_.trade_ban_expiration_){0u}
    , decltype(_impl_.bonus_xp_timestamp_refresh_){0u}
    , decltype(_impl_.bonus_xp_usedflags_){0u}
    , decltype(_impl_.elevated_state_){0u}
    , decltype(_impl_.elevated_timestamp_){0u}
  };
}

CSOEconGameAccountClient::~CSOEconGameAccountClient() {
  // @@protoc_insertion_point(destructor:CSOEconGameAccountClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconGameAccountClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconGameAccountClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconGameAccountClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconGameAccountClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.additional_backpack_slots_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.elevated_timestamp_) -
        reinterpret_cast<char*>(&_impl_.additional_backpack_slots_)) + sizeof(_impl_.elevated_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconGameAccountClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 additional_backpack_slots = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_additional_backpack_slots(&has_bits);
          _impl_.additional_backpack_slots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 trade_ban_expiration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_trade_ban_expiration(&has_bits);
          _impl_.trade_ban_expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 bonus_xp_timestamp_refresh = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_bonus_xp_timestamp_refresh(&has_bits);
          _impl_.bonus_xp_timestamp_refresh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonus_xp_usedflags = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_bonus_xp_usedflags(&has_bits);
          _impl_.bonus_xp_usedflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 elevated_state = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_elevated_state(&has_bits);
          _impl_.elevated_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 elevated_timestamp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_elevated_timestamp(&has_bits);
          _impl_.elevated_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconGameAccountClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconGameAccountClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 additional_backpack_slots = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_additional_backpack_slots(), target);
  }

  // optional fixed32 trade_ban_expiration = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_trade_ban_expiration(), target);
  }

  // optional fixed32 bonus_xp_timestamp_refresh = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(12, this->_internal_bonus_xp_timestamp_refresh(), target);
  }

  // optional uint32 bonus_xp_usedflags = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_bonus_xp_usedflags(), target);
  }

  // optional uint32 elevated_state = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_elevated_state(), target);
  }

  // optional uint32 elevated_timestamp = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_elevated_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconGameAccountClient)
  return target;
}

size_t CSOEconGameAccountClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconGameAccountClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 additional_backpack_slots = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_additional_backpack_slots());
    }

    // optional fixed32 trade_ban_expiration = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 bonus_xp_timestamp_refresh = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 bonus_xp_usedflags = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_xp_usedflags());
    }

    // optional uint32 elevated_state = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_elevated_state());
    }

    // optional uint32 elevated_timestamp = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_elevated_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconGameAccountClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconGameAccountClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconGameAccountClient::GetClassData() const { return &_class_data_; }


void CSOEconGameAccountClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconGameAccountClient*>(&to_msg);
  auto& from = static_cast<const CSOEconGameAccountClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconGameAccountClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.additional_backpack_slots_ = from._impl_.additional_backpack_slots_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.trade_ban_expiration_ = from._impl_.trade_ban_expiration_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bonus_xp_timestamp_refresh_ = from._impl_.bonus_xp_timestamp_refresh_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bonus_xp_usedflags_ = from._impl_.bonus_xp_usedflags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.elevated_state_ = from._impl_.elevated_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.elevated_timestamp_ = from._impl_.elevated_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconGameAccountClient::CopyFrom(const CSOEconGameAccountClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconGameAccountClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconGameAccountClient::IsInitialized() const {
  return true;
}

void CSOEconGameAccountClient::InternalSwap(CSOEconGameAccountClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconGameAccountClient, _impl_.elevated_timestamp_)
      + sizeof(CSOEconGameAccountClient::_impl_.elevated_timestamp_)
      - PROTOBUF_FIELD_OFFSET(CSOEconGameAccountClient, _impl_.additional_backpack_slots_)>(
          reinterpret_cast<char*>(&_impl_.additional_backpack_slots_),
          reinterpret_cast<char*>(&other->_impl_.additional_backpack_slots_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconGameAccountClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[13]);
}

// ===================================================================

class CSOItemCriteriaCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOItemCriteriaCondition>()._impl_._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_float_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_string_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSOItemCriteriaCondition::CSOItemCriteriaCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOItemCriteriaCondition)
}
CSOItemCriteriaCondition::CSOItemCriteriaCondition(const CSOItemCriteriaCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOItemCriteriaCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.field_){}
    , decltype(_impl_.string_value_){}
    , decltype(_impl_.op_){}
    , decltype(_impl_.required_){}
    , decltype(_impl_.float_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_field()) {
    _this->_impl_.field_.Set(from._internal_field(), 
      _this->GetArenaForAllocation());
  }
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_value()) {
    _this->_impl_.string_value_.Set(from._internal_string_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.op_, &from._impl_.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.float_value_) -
    reinterpret_cast<char*>(&_impl_.op_)) + sizeof(_impl_.float_value_));
  // @@protoc_insertion_point(copy_constructor:CSOItemCriteriaCondition)
}

inline void CSOItemCriteriaCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.field_){}
    , decltype(_impl_.string_value_){}
    , decltype(_impl_.op_){0}
    , decltype(_impl_.required_){false}
    , decltype(_impl_.float_value_){0}
  };
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOItemCriteriaCondition::~CSOItemCriteriaCondition() {
  // @@protoc_insertion_point(destructor:CSOItemCriteriaCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOItemCriteriaCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.field_.Destroy();
  _impl_.string_value_.Destroy();
}

void CSOItemCriteriaCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOItemCriteriaCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOItemCriteriaCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.field_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.string_value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.op_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.float_value_) -
        reinterpret_cast<char*>(&_impl_.op_)) + sizeof(_impl_.float_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOItemCriteriaCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_op(&has_bits);
          _impl_.op_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_field();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemCriteriaCondition.field");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool required = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_required(&has_bits);
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float float_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_float_value(&has_bits);
          _impl_.float_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string string_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_string_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemCriteriaCondition.string_value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOItemCriteriaCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOItemCriteriaCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 op = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_op(), target);
  }

  // optional string field = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_field().data(), static_cast<int>(this->_internal_field().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemCriteriaCondition.field");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_field(), target);
  }

  // optional bool required = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_required(), target);
  }

  // optional float float_value = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_float_value(), target);
  }

  // optional string string_value = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemCriteriaCondition.string_value");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_string_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOItemCriteriaCondition)
  return target;
}

size_t CSOItemCriteriaCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOItemCriteriaCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string field = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_field());
    }

    // optional string string_value = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
    }

    // optional int32 op = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_op());
    }

    // optional bool required = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional float float_value = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOItemCriteriaCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOItemCriteriaCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOItemCriteriaCondition::GetClassData() const { return &_class_data_; }


void CSOItemCriteriaCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOItemCriteriaCondition*>(&to_msg);
  auto& from = static_cast<const CSOItemCriteriaCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOItemCriteriaCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_field(from._internal_field());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_string_value(from._internal_string_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.op_ = from._impl_.op_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.float_value_ = from._impl_.float_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOItemCriteriaCondition::CopyFrom(const CSOItemCriteriaCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOItemCriteriaCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOItemCriteriaCondition::IsInitialized() const {
  return true;
}

void CSOItemCriteriaCondition::InternalSwap(CSOItemCriteriaCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.field_, lhs_arena,
      &other->_impl_.field_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_value_, lhs_arena,
      &other->_impl_.string_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOItemCriteriaCondition, _impl_.float_value_)
      + sizeof(CSOItemCriteriaCondition::_impl_.float_value_)
      - PROTOBUF_FIELD_OFFSET(CSOItemCriteriaCondition, _impl_.op_)>(
          reinterpret_cast<char*>(&_impl_.op_),
          reinterpret_cast<char*>(&other->_impl_.op_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOItemCriteriaCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[14]);
}

// ===================================================================

class CSOItemCriteria::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOItemCriteria>()._impl_._has_bits_);
  static void set_has_item_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_level_set(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_item_quality_set(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_initial_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_initial_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ignore_enabled_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_item_rarity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_item_rarity_set(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_recent_only(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CSOItemCriteria::CSOItemCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOItemCriteria)
}
CSOItemCriteria::CSOItemCriteria(const CSOItemCriteria& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOItemCriteria* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.item_level_){}
    , decltype(_impl_.item_quality_){}
    , decltype(_impl_.initial_inventory_){}
    , decltype(_impl_.initial_quantity_){}
    , decltype(_impl_.item_level_set_){}
    , decltype(_impl_.item_quality_set_){}
    , decltype(_impl_.ignore_enabled_flag_){}
    , decltype(_impl_.item_rarity_set_){}
    , decltype(_impl_.item_rarity_){}
    , decltype(_impl_.recent_only_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_level_, &from._impl_.item_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.recent_only_) -
    reinterpret_cast<char*>(&_impl_.item_level_)) + sizeof(_impl_.recent_only_));
  // @@protoc_insertion_point(copy_constructor:CSOItemCriteria)
}

inline void CSOItemCriteria::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.item_level_){0u}
    , decltype(_impl_.item_quality_){0}
    , decltype(_impl_.initial_inventory_){0u}
    , decltype(_impl_.initial_quantity_){0u}
    , decltype(_impl_.item_level_set_){false}
    , decltype(_impl_.item_quality_set_){false}
    , decltype(_impl_.ignore_enabled_flag_){false}
    , decltype(_impl_.item_rarity_set_){false}
    , decltype(_impl_.item_rarity_){0}
    , decltype(_impl_.recent_only_){false}
  };
}

CSOItemCriteria::~CSOItemCriteria() {
  // @@protoc_insertion_point(destructor:CSOItemCriteria)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOItemCriteria::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
}

void CSOItemCriteria::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOItemCriteria::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOItemCriteria)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.item_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_rarity_set_) -
        reinterpret_cast<char*>(&_impl_.item_level_)) + sizeof(_impl_.item_rarity_set_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.item_rarity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.recent_only_) -
        reinterpret_cast<char*>(&_impl_.item_rarity_)) + sizeof(_impl_.recent_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOItemCriteria::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_level(&has_bits);
          _impl_.item_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_quality = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_quality(&has_bits);
          _impl_.item_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool item_level_set = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_level_set(&has_bits);
          _impl_.item_level_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool item_quality_set = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_quality_set(&has_bits);
          _impl_.item_quality_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_inventory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_initial_inventory(&has_bits);
          _impl_.initial_inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_quantity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_initial_quantity(&has_bits);
          _impl_.initial_quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_enabled_flag = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_enabled_flag(&has_bits);
          _impl_.ignore_enabled_flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSOItemCriteriaCondition conditions = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_rarity = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_item_rarity(&has_bits);
          _impl_.item_rarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool item_rarity_set = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_item_rarity_set(&has_bits);
          _impl_.item_rarity_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool recent_only = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_recent_only(&has_bits);
          _impl_.recent_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOItemCriteria::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOItemCriteria)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_level = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_level(), target);
  }

  // optional int32 item_quality = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_item_quality(), target);
  }

  // optional bool item_level_set = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_item_level_set(), target);
  }

  // optional bool item_quality_set = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_item_quality_set(), target);
  }

  // optional uint32 initial_inventory = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_initial_inventory(), target);
  }

  // optional uint32 initial_quantity = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_initial_quantity(), target);
  }

  // optional bool ignore_enabled_flag = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_enabled_flag(), target);
  }

  // repeated .CSOItemCriteriaCondition conditions = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 item_rarity = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_item_rarity(), target);
  }

  // optional bool item_rarity_set = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_item_rarity_set(), target);
  }

  // optional bool recent_only = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_recent_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOItemCriteria)
  return target;
}

size_t CSOItemCriteria::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOItemCriteria)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSOItemCriteriaCondition conditions = 9;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 item_level = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_level());
    }

    // optional int32 item_quality = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_quality());
    }

    // optional uint32 initial_inventory = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_inventory());
    }

    // optional uint32 initial_quantity = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_quantity());
    }

    // optional bool item_level_set = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool item_quality_set = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool ignore_enabled_flag = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool item_rarity_set = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 item_rarity = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_rarity());
    }

    // optional bool recent_only = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOItemCriteria::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOItemCriteria::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOItemCriteria::GetClassData() const { return &_class_data_; }


void CSOItemCriteria::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOItemCriteria*>(&to_msg);
  auto& from = static_cast<const CSOItemCriteria&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOItemCriteria)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_level_ = from._impl_.item_level_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_quality_ = from._impl_.item_quality_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.initial_inventory_ = from._impl_.initial_inventory_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.initial_quantity_ = from._impl_.initial_quantity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_level_set_ = from._impl_.item_level_set_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.item_quality_set_ = from._impl_.item_quality_set_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ignore_enabled_flag_ = from._impl_.ignore_enabled_flag_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.item_rarity_set_ = from._impl_.item_rarity_set_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.item_rarity_ = from._impl_.item_rarity_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.recent_only_ = from._impl_.recent_only_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOItemCriteria::CopyFrom(const CSOItemCriteria& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOItemCriteria)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOItemCriteria::IsInitialized() const {
  return true;
}

void CSOItemCriteria::InternalSwap(CSOItemCriteria* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOItemCriteria, _impl_.recent_only_)
      + sizeof(CSOItemCriteria::_impl_.recent_only_)
      - PROTOBUF_FIELD_OFFSET(CSOItemCriteria, _impl_.item_level_)>(
          reinterpret_cast<char*>(&_impl_.item_level_),
          reinterpret_cast<char*>(&other->_impl_.item_level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOItemCriteria::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[15]);
}

// ===================================================================

class CSOItemRecipe::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOItemRecipe>()._impl_._has_bits_);
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_n_a(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_desc_inputs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_desc_outputs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_di_a(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_di_b(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_di_c(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_do_a(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_do_b(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_do_c(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_requires_all_same_class(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_requires_all_same_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_class_usage_for_output(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_slot_usage_for_output(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_set_for_output(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

CSOItemRecipe::CSOItemRecipe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOItemRecipe)
}
CSOItemRecipe::CSOItemRecipe(const CSOItemRecipe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOItemRecipe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_items_criteria_){from._impl_.input_items_criteria_}
    , decltype(_impl_.output_items_criteria_){from._impl_.output_items_criteria_}
    , decltype(_impl_.input_item_dupe_counts_){from._impl_.input_item_dupe_counts_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.n_a_){}
    , decltype(_impl_.desc_inputs_){}
    , decltype(_impl_.desc_outputs_){}
    , decltype(_impl_.di_a_){}
    , decltype(_impl_.di_b_){}
    , decltype(_impl_.di_c_){}
    , decltype(_impl_.do_a_){}
    , decltype(_impl_.do_b_){}
    , decltype(_impl_.do_c_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.requires_all_same_class_){}
    , decltype(_impl_.requires_all_same_slot_){}
    , decltype(_impl_.class_usage_for_output_){}
    , decltype(_impl_.slot_usage_for_output_){}
    , decltype(_impl_.set_for_output_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.n_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.n_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_n_a()) {
    _this->_impl_.n_a_.Set(from._internal_n_a(), 
      _this->GetArenaForAllocation());
  }
  _impl_.desc_inputs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_inputs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_desc_inputs()) {
    _this->_impl_.desc_inputs_.Set(from._internal_desc_inputs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.desc_outputs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_outputs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_desc_outputs()) {
    _this->_impl_.desc_outputs_.Set(from._internal_desc_outputs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.di_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_di_a()) {
    _this->_impl_.di_a_.Set(from._internal_di_a(), 
      _this->GetArenaForAllocation());
  }
  _impl_.di_b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_di_b()) {
    _this->_impl_.di_b_.Set(from._internal_di_b(), 
      _this->GetArenaForAllocation());
  }
  _impl_.di_c_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_c_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_di_c()) {
    _this->_impl_.di_c_.Set(from._internal_di_c(), 
      _this->GetArenaForAllocation());
  }
  _impl_.do_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_do_a()) {
    _this->_impl_.do_a_.Set(from._internal_do_a(), 
      _this->GetArenaForAllocation());
  }
  _impl_.do_b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_do_b()) {
    _this->_impl_.do_b_.Set(from._internal_do_b(), 
      _this->GetArenaForAllocation());
  }
  _impl_.do_c_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_c_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_do_c()) {
    _this->_impl_.do_c_.Set(from._internal_do_c(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.def_index_, &from._impl_.def_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.set_for_output_) -
    reinterpret_cast<char*>(&_impl_.def_index_)) + sizeof(_impl_.set_for_output_));
  // @@protoc_insertion_point(copy_constructor:CSOItemRecipe)
}

inline void CSOItemRecipe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_items_criteria_){arena}
    , decltype(_impl_.output_items_criteria_){arena}
    , decltype(_impl_.input_item_dupe_counts_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.n_a_){}
    , decltype(_impl_.desc_inputs_){}
    , decltype(_impl_.desc_outputs_){}
    , decltype(_impl_.di_a_){}
    , decltype(_impl_.di_b_){}
    , decltype(_impl_.di_c_){}
    , decltype(_impl_.do_a_){}
    , decltype(_impl_.do_b_){}
    , decltype(_impl_.do_c_){}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.requires_all_same_class_){false}
    , decltype(_impl_.requires_all_same_slot_){false}
    , decltype(_impl_.class_usage_for_output_){0}
    , decltype(_impl_.slot_usage_for_output_){0}
    , decltype(_impl_.set_for_output_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.n_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.n_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_inputs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_inputs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_outputs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_outputs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.di_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.di_b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.di_c_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.di_c_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.do_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.do_b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.do_c_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.do_c_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOItemRecipe::~CSOItemRecipe() {
  // @@protoc_insertion_point(destructor:CSOItemRecipe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOItemRecipe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_items_criteria_.~RepeatedPtrField();
  _impl_.output_items_criteria_.~RepeatedPtrField();
  _impl_.input_item_dupe_counts_.~RepeatedField();
  _impl_.name_.Destroy();
  _impl_.n_a_.Destroy();
  _impl_.desc_inputs_.Destroy();
  _impl_.desc_outputs_.Destroy();
  _impl_.di_a_.Destroy();
  _impl_.di_b_.Destroy();
  _impl_.di_c_.Destroy();
  _impl_.do_a_.Destroy();
  _impl_.do_b_.Destroy();
  _impl_.do_c_.Destroy();
}

void CSOItemRecipe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOItemRecipe::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOItemRecipe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_items_criteria_.Clear();
  _impl_.output_items_criteria_.Clear();
  _impl_.input_item_dupe_counts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.n_a_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.desc_inputs_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.desc_outputs_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.di_a_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.di_b_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.di_c_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.do_a_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.do_b_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.do_c_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000fc00u) {
    ::memset(&_impl_.def_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.set_for_output_) -
        reinterpret_cast<char*>(&_impl_.def_index_)) + sizeof(_impl_.set_for_output_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOItemRecipe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 def_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string n_a = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_n_a();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.n_a");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string desc_inputs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_desc_inputs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.desc_inputs");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string desc_outputs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_desc_outputs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.desc_outputs");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string di_a = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_di_a();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.di_a");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string di_b = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_di_b();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.di_b");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string di_c = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_di_c();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.di_c");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string do_a = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_do_a();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.do_a");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string do_b = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_do_b();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.do_b");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string do_c = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_do_c();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOItemRecipe.do_c");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool requires_all_same_class = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_requires_all_same_class(&has_bits);
          _impl_.requires_all_same_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool requires_all_same_slot = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_requires_all_same_slot(&has_bits);
          _impl_.requires_all_same_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 class_usage_for_output = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_class_usage_for_output(&has_bits);
          _impl_.class_usage_for_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot_usage_for_output = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_slot_usage_for_output(&has_bits);
          _impl_.slot_usage_for_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 set_for_output = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_set_for_output(&has_bits);
          _impl_.set_for_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSOItemCriteria input_items_criteria = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_input_items_criteria(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CSOItemCriteria output_items_criteria = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_output_items_criteria(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 input_item_dupe_counts = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_input_item_dupe_counts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<176>(ptr));
        } else if (static_cast<uint8_t>(tag) == 178) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_input_item_dupe_counts(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOItemRecipe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOItemRecipe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 def_index = 1;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_def_index(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string n_a = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_n_a().data(), static_cast<int>(this->_internal_n_a().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.n_a");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_n_a(), target);
  }

  // optional string desc_inputs = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_desc_inputs().data(), static_cast<int>(this->_internal_desc_inputs().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.desc_inputs");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_desc_inputs(), target);
  }

  // optional string desc_outputs = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_desc_outputs().data(), static_cast<int>(this->_internal_desc_outputs().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.desc_outputs");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_desc_outputs(), target);
  }

  // optional string di_a = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_di_a().data(), static_cast<int>(this->_internal_di_a().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.di_a");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_di_a(), target);
  }

  // optional string di_b = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_di_b().data(), static_cast<int>(this->_internal_di_b().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.di_b");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_di_b(), target);
  }

  // optional string di_c = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_di_c().data(), static_cast<int>(this->_internal_di_c().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.di_c");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_di_c(), target);
  }

  // optional string do_a = 9;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_do_a().data(), static_cast<int>(this->_internal_do_a().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.do_a");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_do_a(), target);
  }

  // optional string do_b = 10;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_do_b().data(), static_cast<int>(this->_internal_do_b().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.do_b");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_do_b(), target);
  }

  // optional string do_c = 11;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_do_c().data(), static_cast<int>(this->_internal_do_c().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOItemRecipe.do_c");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_do_c(), target);
  }

  // optional bool requires_all_same_class = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_requires_all_same_class(), target);
  }

  // optional bool requires_all_same_slot = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_requires_all_same_slot(), target);
  }

  // optional int32 class_usage_for_output = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_class_usage_for_output(), target);
  }

  // optional int32 slot_usage_for_output = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_slot_usage_for_output(), target);
  }

  // optional int32 set_for_output = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_set_for_output(), target);
  }

  // repeated .CSOItemCriteria input_items_criteria = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_items_criteria_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_items_criteria(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CSOItemCriteria output_items_criteria = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_output_items_criteria_size()); i < n; i++) {
    const auto& repfield = this->_internal_output_items_criteria(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 input_item_dupe_counts = 22;
  for (int i = 0, n = this->_internal_input_item_dupe_counts_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_input_item_dupe_counts(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOItemRecipe)
  return target;
}

size_t CSOItemRecipe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOItemRecipe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSOItemCriteria input_items_criteria = 20;
  total_size += 2UL * this->_internal_input_items_criteria_size();
  for (const auto& msg : this->_impl_.input_items_criteria_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CSOItemCriteria output_items_criteria = 21;
  total_size += 2UL * this->_internal_output_items_criteria_size();
  for (const auto& msg : this->_impl_.output_items_criteria_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 input_item_dupe_counts = 22;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.input_item_dupe_counts_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_input_item_dupe_counts_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string n_a = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_n_a());
    }

    // optional string desc_inputs = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_desc_inputs());
    }

    // optional string desc_outputs = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_desc_outputs());
    }

    // optional string di_a = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_di_a());
    }

    // optional string di_b = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_di_b());
    }

    // optional string di_c = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_di_c());
    }

    // optional string do_a = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_do_a());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string do_b = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_do_b());
    }

    // optional string do_c = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_do_c());
    }

    // optional uint32 def_index = 1;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional bool requires_all_same_class = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool requires_all_same_slot = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional int32 class_usage_for_output = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_class_usage_for_output());
    }

    // optional int32 slot_usage_for_output = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot_usage_for_output());
    }

    // optional int32 set_for_output = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_set_for_output());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOItemRecipe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOItemRecipe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOItemRecipe::GetClassData() const { return &_class_data_; }


void CSOItemRecipe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOItemRecipe*>(&to_msg);
  auto& from = static_cast<const CSOItemRecipe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOItemRecipe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_items_criteria_.MergeFrom(from._impl_.input_items_criteria_);
  _this->_impl_.output_items_criteria_.MergeFrom(from._impl_.output_items_criteria_);
  _this->_impl_.input_item_dupe_counts_.MergeFrom(from._impl_.input_item_dupe_counts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_n_a(from._internal_n_a());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_desc_inputs(from._internal_desc_inputs());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_desc_outputs(from._internal_desc_outputs());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_di_a(from._internal_di_a());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_di_b(from._internal_di_b());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_di_c(from._internal_di_c());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_do_a(from._internal_do_a());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_do_b(from._internal_do_b());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_do_c(from._internal_do_c());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.requires_all_same_class_ = from._impl_.requires_all_same_class_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.requires_all_same_slot_ = from._impl_.requires_all_same_slot_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.class_usage_for_output_ = from._impl_.class_usage_for_output_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.slot_usage_for_output_ = from._impl_.slot_usage_for_output_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.set_for_output_ = from._impl_.set_for_output_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOItemRecipe::CopyFrom(const CSOItemRecipe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOItemRecipe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOItemRecipe::IsInitialized() const {
  return true;
}

void CSOItemRecipe::InternalSwap(CSOItemRecipe* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.input_items_criteria_.InternalSwap(&other->_impl_.input_items_criteria_);
  _impl_.output_items_criteria_.InternalSwap(&other->_impl_.output_items_criteria_);
  _impl_.input_item_dupe_counts_.InternalSwap(&other->_impl_.input_item_dupe_counts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.n_a_, lhs_arena,
      &other->_impl_.n_a_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.desc_inputs_, lhs_arena,
      &other->_impl_.desc_inputs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.desc_outputs_, lhs_arena,
      &other->_impl_.desc_outputs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.di_a_, lhs_arena,
      &other->_impl_.di_a_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.di_b_, lhs_arena,
      &other->_impl_.di_b_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.di_c_, lhs_arena,
      &other->_impl_.di_c_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.do_a_, lhs_arena,
      &other->_impl_.do_a_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.do_b_, lhs_arena,
      &other->_impl_.do_b_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.do_c_, lhs_arena,
      &other->_impl_.do_c_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOItemRecipe, _impl_.set_for_output_)
      + sizeof(CSOItemRecipe::_impl_.set_for_output_)
      - PROTOBUF_FIELD_OFFSET(CSOItemRecipe, _impl_.def_index_)>(
          reinterpret_cast<char*>(&_impl_.def_index_),
          reinterpret_cast<char*>(&other->_impl_.def_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOItemRecipe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[16]);
}

// ===================================================================

class CMsgDevNewItemRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDevNewItemRequest>()._impl_._has_bits_);
  static void set_has_receiver(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CSOItemCriteria& criteria(const CMsgDevNewItemRequest* msg);
  static void set_has_criteria(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CSOItemCriteria&
CMsgDevNewItemRequest::_Internal::criteria(const CMsgDevNewItemRequest* msg) {
  return *msg->_impl_.criteria_;
}
CMsgDevNewItemRequest::CMsgDevNewItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDevNewItemRequest)
}
CMsgDevNewItemRequest::CMsgDevNewItemRequest(const CMsgDevNewItemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDevNewItemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.criteria_){nullptr}
    , decltype(_impl_.receiver_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_criteria()) {
    _this->_impl_.criteria_ = new ::CSOItemCriteria(*from._impl_.criteria_);
  }
  _this->_impl_.receiver_ = from._impl_.receiver_;
  // @@protoc_insertion_point(copy_constructor:CMsgDevNewItemRequest)
}

inline void CMsgDevNewItemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.criteria_){nullptr}
    , decltype(_impl_.receiver_){uint64_t{0u}}
  };
}

CMsgDevNewItemRequest::~CMsgDevNewItemRequest() {
  // @@protoc_insertion_point(destructor:CMsgDevNewItemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDevNewItemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.criteria_;
}

void CMsgDevNewItemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDevNewItemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDevNewItemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.criteria_ != nullptr);
    _impl_.criteria_->Clear();
  }
  _impl_.receiver_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDevNewItemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 receiver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_receiver(&has_bits);
          _impl_.receiver_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CSOItemCriteria criteria = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_criteria(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDevNewItemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDevNewItemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 receiver = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_receiver(), target);
  }

  // optional .CSOItemCriteria criteria = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::criteria(this),
        _Internal::criteria(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDevNewItemRequest)
  return target;
}

size_t CMsgDevNewItemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDevNewItemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CSOItemCriteria criteria = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.criteria_);
    }

    // optional fixed64 receiver = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDevNewItemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDevNewItemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDevNewItemRequest::GetClassData() const { return &_class_data_; }


void CMsgDevNewItemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDevNewItemRequest*>(&to_msg);
  auto& from = static_cast<const CMsgDevNewItemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDevNewItemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_criteria()->::CSOItemCriteria::MergeFrom(
          from._internal_criteria());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.receiver_ = from._impl_.receiver_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDevNewItemRequest::CopyFrom(const CMsgDevNewItemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDevNewItemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDevNewItemRequest::IsInitialized() const {
  return true;
}

void CMsgDevNewItemRequest::InternalSwap(CMsgDevNewItemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDevNewItemRequest, _impl_.receiver_)
      + sizeof(CMsgDevNewItemRequest::_impl_.receiver_)
      - PROTOBUF_FIELD_OFFSET(CMsgDevNewItemRequest, _impl_.criteria_)>(
          reinterpret_cast<char*>(&_impl_.criteria_),
          reinterpret_cast<char*>(&other->_impl_.criteria_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDevNewItemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[17]);
}

// ===================================================================

class CMsgIncrementKillCountAttribute::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgIncrementKillCountAttribute>()._impl_._has_bits_);
  static void set_has_killer_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_victim_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgIncrementKillCountAttribute::CMsgIncrementKillCountAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgIncrementKillCountAttribute)
}
CMsgIncrementKillCountAttribute::CMsgIncrementKillCountAttribute(const CMsgIncrementKillCountAttribute& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgIncrementKillCountAttribute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.killer_account_id_){}
    , decltype(_impl_.victim_account_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.event_type_){}
    , decltype(_impl_.amount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.killer_account_id_, &from._impl_.killer_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.amount_) -
    reinterpret_cast<char*>(&_impl_.killer_account_id_)) + sizeof(_impl_.amount_));
  // @@protoc_insertion_point(copy_constructor:CMsgIncrementKillCountAttribute)
}

inline void CMsgIncrementKillCountAttribute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.killer_account_id_){0u}
    , decltype(_impl_.victim_account_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.event_type_){0u}
    , decltype(_impl_.amount_){0u}
  };
}

CMsgIncrementKillCountAttribute::~CMsgIncrementKillCountAttribute() {
  // @@protoc_insertion_point(destructor:CMsgIncrementKillCountAttribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgIncrementKillCountAttribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgIncrementKillCountAttribute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgIncrementKillCountAttribute::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgIncrementKillCountAttribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.killer_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.amount_) -
        reinterpret_cast<char*>(&_impl_.killer_account_id_)) + sizeof(_impl_.amount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgIncrementKillCountAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 killer_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_killer_account_id(&has_bits);
          _impl_.killer_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 victim_account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_victim_account_id(&has_bits);
          _impl_.victim_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_event_type(&has_bits);
          _impl_.event_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_amount(&has_bits);
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgIncrementKillCountAttribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgIncrementKillCountAttribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 killer_account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_killer_account_id(), target);
  }

  // optional fixed32 victim_account_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_victim_account_id(), target);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  // optional uint32 event_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_event_type(), target);
  }

  // optional uint32 amount = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgIncrementKillCountAttribute)
  return target;
}

size_t CMsgIncrementKillCountAttribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgIncrementKillCountAttribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed32 killer_account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 victim_account_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 event_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_type());
    }

    // optional uint32 amount = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_amount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgIncrementKillCountAttribute::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgIncrementKillCountAttribute::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgIncrementKillCountAttribute::GetClassData() const { return &_class_data_; }


void CMsgIncrementKillCountAttribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgIncrementKillCountAttribute*>(&to_msg);
  auto& from = static_cast<const CMsgIncrementKillCountAttribute&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgIncrementKillCountAttribute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.killer_account_id_ = from._impl_.killer_account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.victim_account_id_ = from._impl_.victim_account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgIncrementKillCountAttribute::CopyFrom(const CMsgIncrementKillCountAttribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgIncrementKillCountAttribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgIncrementKillCountAttribute::IsInitialized() const {
  return true;
}

void CMsgIncrementKillCountAttribute::InternalSwap(CMsgIncrementKillCountAttribute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgIncrementKillCountAttribute, _impl_.amount_)
      + sizeof(CMsgIncrementKillCountAttribute::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(CMsgIncrementKillCountAttribute, _impl_.killer_account_id_)>(
          reinterpret_cast<char*>(&_impl_.killer_account_id_),
          reinterpret_cast<char*>(&other->_impl_.killer_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgIncrementKillCountAttribute::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[18]);
}

// ===================================================================

class CMsgApplySticker::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgApplySticker>()._impl_._has_bits_);
  static void set_has_sticker_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sticker_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_baseitem_defidx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sticker_wear(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sticker_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sticker_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sticker_offset_x(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sticker_offset_y(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sticker_offset_z(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_sticker_wear_target(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgApplySticker::CMsgApplySticker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgApplySticker)
}
CMsgApplySticker::CMsgApplySticker(const CMsgApplySticker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgApplySticker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sticker_item_id_){}
    , decltype(_impl_.item_item_id_){}
    , decltype(_impl_.sticker_slot_){}
    , decltype(_impl_.baseitem_defidx_){}
    , decltype(_impl_.sticker_wear_){}
    , decltype(_impl_.sticker_rotation_){}
    , decltype(_impl_.sticker_scale_){}
    , decltype(_impl_.sticker_offset_x_){}
    , decltype(_impl_.sticker_offset_y_){}
    , decltype(_impl_.sticker_offset_z_){}
    , decltype(_impl_.sticker_wear_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sticker_item_id_, &from._impl_.sticker_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sticker_wear_target_) -
    reinterpret_cast<char*>(&_impl_.sticker_item_id_)) + sizeof(_impl_.sticker_wear_target_));
  // @@protoc_insertion_point(copy_constructor:CMsgApplySticker)
}

inline void CMsgApplySticker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sticker_item_id_){uint64_t{0u}}
    , decltype(_impl_.item_item_id_){uint64_t{0u}}
    , decltype(_impl_.sticker_slot_){0u}
    , decltype(_impl_.baseitem_defidx_){0u}
    , decltype(_impl_.sticker_wear_){0}
    , decltype(_impl_.sticker_rotation_){0}
    , decltype(_impl_.sticker_scale_){0}
    , decltype(_impl_.sticker_offset_x_){0}
    , decltype(_impl_.sticker_offset_y_){0}
    , decltype(_impl_.sticker_offset_z_){0}
    , decltype(_impl_.sticker_wear_target_){0}
  };
}

CMsgApplySticker::~CMsgApplySticker() {
  // @@protoc_insertion_point(destructor:CMsgApplySticker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgApplySticker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgApplySticker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgApplySticker::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgApplySticker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.sticker_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sticker_offset_x_) -
        reinterpret_cast<char*>(&_impl_.sticker_item_id_)) + sizeof(_impl_.sticker_offset_x_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.sticker_offset_y_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sticker_wear_target_) -
        reinterpret_cast<char*>(&_impl_.sticker_offset_y_)) + sizeof(_impl_.sticker_wear_target_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgApplySticker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sticker_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sticker_item_id(&has_bits);
          _impl_.sticker_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_item_id(&has_bits);
          _impl_.item_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sticker_slot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sticker_slot(&has_bits);
          _impl_.sticker_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 baseitem_defidx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_baseitem_defidx(&has_bits);
          _impl_.baseitem_defidx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_wear = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_sticker_wear(&has_bits);
          _impl_.sticker_wear_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_rotation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_sticker_rotation(&has_bits);
          _impl_.sticker_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_sticker_scale(&has_bits);
          _impl_.sticker_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_offset_x = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_sticker_offset_x(&has_bits);
          _impl_.sticker_offset_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_offset_y = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_sticker_offset_y(&has_bits);
          _impl_.sticker_offset_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_offset_z = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_sticker_offset_z(&has_bits);
          _impl_.sticker_offset_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sticker_wear_target = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_sticker_wear_target(&has_bits);
          _impl_.sticker_wear_target_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgApplySticker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgApplySticker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 sticker_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sticker_item_id(), target);
  }

  // optional uint64 item_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_item_id(), target);
  }

  // optional uint32 sticker_slot = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sticker_slot(), target);
  }

  // optional uint32 baseitem_defidx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_baseitem_defidx(), target);
  }

  // optional float sticker_wear = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_sticker_wear(), target);
  }

  // optional float sticker_rotation = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_sticker_rotation(), target);
  }

  // optional float sticker_scale = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_sticker_scale(), target);
  }

  // optional float sticker_offset_x = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_sticker_offset_x(), target);
  }

  // optional float sticker_offset_y = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_sticker_offset_y(), target);
  }

  // optional float sticker_offset_z = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_sticker_offset_z(), target);
  }

  // optional float sticker_wear_target = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_sticker_wear_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgApplySticker)
  return target;
}

size_t CMsgApplySticker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgApplySticker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 sticker_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sticker_item_id());
    }

    // optional uint64 item_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_item_id());
    }

    // optional uint32 sticker_slot = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sticker_slot());
    }

    // optional uint32 baseitem_defidx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_baseitem_defidx());
    }

    // optional float sticker_wear = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float sticker_rotation = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float sticker_scale = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float sticker_offset_x = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float sticker_offset_y = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float sticker_offset_z = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float sticker_wear_target = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgApplySticker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgApplySticker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgApplySticker::GetClassData() const { return &_class_data_; }


void CMsgApplySticker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgApplySticker*>(&to_msg);
  auto& from = static_cast<const CMsgApplySticker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgApplySticker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sticker_item_id_ = from._impl_.sticker_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_item_id_ = from._impl_.item_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sticker_slot_ = from._impl_.sticker_slot_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.baseitem_defidx_ = from._impl_.baseitem_defidx_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sticker_wear_ = from._impl_.sticker_wear_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sticker_rotation_ = from._impl_.sticker_rotation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.sticker_scale_ = from._impl_.sticker_scale_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.sticker_offset_x_ = from._impl_.sticker_offset_x_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sticker_offset_y_ = from._impl_.sticker_offset_y_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.sticker_offset_z_ = from._impl_.sticker_offset_z_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sticker_wear_target_ = from._impl_.sticker_wear_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgApplySticker::CopyFrom(const CMsgApplySticker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgApplySticker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgApplySticker::IsInitialized() const {
  return true;
}

void CMsgApplySticker::InternalSwap(CMsgApplySticker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgApplySticker, _impl_.sticker_wear_target_)
      + sizeof(CMsgApplySticker::_impl_.sticker_wear_target_)
      - PROTOBUF_FIELD_OFFSET(CMsgApplySticker, _impl_.sticker_item_id_)>(
          reinterpret_cast<char*>(&_impl_.sticker_item_id_),
          reinterpret_cast<char*>(&other->_impl_.sticker_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgApplySticker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[19]);
}

// ===================================================================

class CMsgModifyItemAttribute::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgModifyItemAttribute>()._impl_._has_bits_);
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attr_defidx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attr_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgModifyItemAttribute::CMsgModifyItemAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgModifyItemAttribute)
}
CMsgModifyItemAttribute::CMsgModifyItemAttribute(const CMsgModifyItemAttribute& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgModifyItemAttribute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.attr_defidx_){}
    , decltype(_impl_.attr_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_id_, &from._impl_.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attr_value_) -
    reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.attr_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgModifyItemAttribute)
}

inline void CMsgModifyItemAttribute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.attr_defidx_){0u}
    , decltype(_impl_.attr_value_){0u}
  };
}

CMsgModifyItemAttribute::~CMsgModifyItemAttribute() {
  // @@protoc_insertion_point(destructor:CMsgModifyItemAttribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgModifyItemAttribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgModifyItemAttribute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgModifyItemAttribute::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgModifyItemAttribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.attr_value_) -
        reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.attr_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgModifyItemAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attr_defidx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_attr_defidx(&has_bits);
          _impl_.attr_defidx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attr_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_attr_value(&has_bits);
          _impl_.attr_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgModifyItemAttribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgModifyItemAttribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_item_id(), target);
  }

  // optional uint32 attr_defidx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_attr_defidx(), target);
  }

  // optional uint32 attr_value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_attr_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgModifyItemAttribute)
  return target;
}

size_t CMsgModifyItemAttribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgModifyItemAttribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 attr_defidx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attr_defidx());
    }

    // optional uint32 attr_value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attr_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgModifyItemAttribute::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgModifyItemAttribute::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgModifyItemAttribute::GetClassData() const { return &_class_data_; }


void CMsgModifyItemAttribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgModifyItemAttribute*>(&to_msg);
  auto& from = static_cast<const CMsgModifyItemAttribute&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgModifyItemAttribute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.attr_defidx_ = from._impl_.attr_defidx_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.attr_value_ = from._impl_.attr_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgModifyItemAttribute::CopyFrom(const CMsgModifyItemAttribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgModifyItemAttribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgModifyItemAttribute::IsInitialized() const {
  return true;
}

void CMsgModifyItemAttribute::InternalSwap(CMsgModifyItemAttribute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgModifyItemAttribute, _impl_.attr_value_)
      + sizeof(CMsgModifyItemAttribute::_impl_.attr_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgModifyItemAttribute, _impl_.item_id_)>(
          reinterpret_cast<char*>(&_impl_.item_id_),
          reinterpret_cast<char*>(&other->_impl_.item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgModifyItemAttribute::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[20]);
}

// ===================================================================

class CMsgApplyStatTrakSwap::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgApplyStatTrakSwap>()._impl_._has_bits_);
  static void set_has_tool_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_1_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_2_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgApplyStatTrakSwap::CMsgApplyStatTrakSwap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgApplyStatTrakSwap)
}
CMsgApplyStatTrakSwap::CMsgApplyStatTrakSwap(const CMsgApplyStatTrakSwap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgApplyStatTrakSwap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tool_item_id_){}
    , decltype(_impl_.item_1_item_id_){}
    , decltype(_impl_.item_2_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tool_item_id_, &from._impl_.tool_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_2_item_id_) -
    reinterpret_cast<char*>(&_impl_.tool_item_id_)) + sizeof(_impl_.item_2_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgApplyStatTrakSwap)
}

inline void CMsgApplyStatTrakSwap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tool_item_id_){uint64_t{0u}}
    , decltype(_impl_.item_1_item_id_){uint64_t{0u}}
    , decltype(_impl_.item_2_item_id_){uint64_t{0u}}
  };
}

CMsgApplyStatTrakSwap::~CMsgApplyStatTrakSwap() {
  // @@protoc_insertion_point(destructor:CMsgApplyStatTrakSwap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgApplyStatTrakSwap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgApplyStatTrakSwap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgApplyStatTrakSwap::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgApplyStatTrakSwap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.tool_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_2_item_id_) -
        reinterpret_cast<char*>(&_impl_.tool_item_id_)) + sizeof(_impl_.item_2_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgApplyStatTrakSwap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 tool_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tool_item_id(&has_bits);
          _impl_.tool_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_1_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_1_item_id(&has_bits);
          _impl_.item_1_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_2_item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_2_item_id(&has_bits);
          _impl_.item_2_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgApplyStatTrakSwap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgApplyStatTrakSwap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 tool_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tool_item_id(), target);
  }

  // optional uint64 item_1_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_1_item_id(), target);
  }

  // optional uint64 item_2_item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_2_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgApplyStatTrakSwap)
  return target;
}

size_t CMsgApplyStatTrakSwap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgApplyStatTrakSwap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 tool_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tool_item_id());
    }

    // optional uint64 item_1_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_1_item_id());
    }

    // optional uint64 item_2_item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_2_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgApplyStatTrakSwap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgApplyStatTrakSwap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgApplyStatTrakSwap::GetClassData() const { return &_class_data_; }


void CMsgApplyStatTrakSwap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgApplyStatTrakSwap*>(&to_msg);
  auto& from = static_cast<const CMsgApplyStatTrakSwap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgApplyStatTrakSwap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tool_item_id_ = from._impl_.tool_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_1_item_id_ = from._impl_.item_1_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_2_item_id_ = from._impl_.item_2_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgApplyStatTrakSwap::CopyFrom(const CMsgApplyStatTrakSwap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgApplyStatTrakSwap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgApplyStatTrakSwap::IsInitialized() const {
  return true;
}

void CMsgApplyStatTrakSwap::InternalSwap(CMsgApplyStatTrakSwap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgApplyStatTrakSwap, _impl_.item_2_item_id_)
      + sizeof(CMsgApplyStatTrakSwap::_impl_.item_2_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgApplyStatTrakSwap, _impl_.tool_item_id_)>(
          reinterpret_cast<char*>(&_impl_.tool_item_id_),
          reinterpret_cast<char*>(&other->_impl_.tool_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgApplyStatTrakSwap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[21]);
}

// ===================================================================

class CMsgApplyStrangePart::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgApplyStrangePart>()._impl_._has_bits_);
  static void set_has_strange_part_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgApplyStrangePart::CMsgApplyStrangePart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgApplyStrangePart)
}
CMsgApplyStrangePart::CMsgApplyStrangePart(const CMsgApplyStrangePart& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgApplyStrangePart* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strange_part_item_id_){}
    , decltype(_impl_.item_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.strange_part_item_id_, &from._impl_.strange_part_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_item_id_) -
    reinterpret_cast<char*>(&_impl_.strange_part_item_id_)) + sizeof(_impl_.item_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgApplyStrangePart)
}

inline void CMsgApplyStrangePart::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strange_part_item_id_){uint64_t{0u}}
    , decltype(_impl_.item_item_id_){uint64_t{0u}}
  };
}

CMsgApplyStrangePart::~CMsgApplyStrangePart() {
  // @@protoc_insertion_point(destructor:CMsgApplyStrangePart)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgApplyStrangePart::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgApplyStrangePart::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgApplyStrangePart::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgApplyStrangePart)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.strange_part_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_item_id_) -
        reinterpret_cast<char*>(&_impl_.strange_part_item_id_)) + sizeof(_impl_.item_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgApplyStrangePart::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 strange_part_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_strange_part_item_id(&has_bits);
          _impl_.strange_part_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_item_id(&has_bits);
          _impl_.item_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgApplyStrangePart::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgApplyStrangePart)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 strange_part_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_strange_part_item_id(), target);
  }

  // optional uint64 item_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgApplyStrangePart)
  return target;
}

size_t CMsgApplyStrangePart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgApplyStrangePart)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 strange_part_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_strange_part_item_id());
    }

    // optional uint64 item_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgApplyStrangePart::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgApplyStrangePart::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgApplyStrangePart::GetClassData() const { return &_class_data_; }


void CMsgApplyStrangePart::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgApplyStrangePart*>(&to_msg);
  auto& from = static_cast<const CMsgApplyStrangePart&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgApplyStrangePart)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.strange_part_item_id_ = from._impl_.strange_part_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_item_id_ = from._impl_.item_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgApplyStrangePart::CopyFrom(const CMsgApplyStrangePart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgApplyStrangePart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgApplyStrangePart::IsInitialized() const {
  return true;
}

void CMsgApplyStrangePart::InternalSwap(CMsgApplyStrangePart* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgApplyStrangePart, _impl_.item_item_id_)
      + sizeof(CMsgApplyStrangePart::_impl_.item_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgApplyStrangePart, _impl_.strange_part_item_id_)>(
          reinterpret_cast<char*>(&_impl_.strange_part_item_id_),
          reinterpret_cast<char*>(&other->_impl_.strange_part_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgApplyStrangePart::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[22]);
}

// ===================================================================

class CMsgApplyPennantUpgrade::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgApplyPennantUpgrade>()._impl_._has_bits_);
  static void set_has_upgrade_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pennant_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgApplyPennantUpgrade::CMsgApplyPennantUpgrade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgApplyPennantUpgrade)
}
CMsgApplyPennantUpgrade::CMsgApplyPennantUpgrade(const CMsgApplyPennantUpgrade& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgApplyPennantUpgrade* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.upgrade_item_id_){}
    , decltype(_impl_.pennant_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.upgrade_item_id_, &from._impl_.upgrade_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pennant_item_id_) -
    reinterpret_cast<char*>(&_impl_.upgrade_item_id_)) + sizeof(_impl_.pennant_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgApplyPennantUpgrade)
}

inline void CMsgApplyPennantUpgrade::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.upgrade_item_id_){uint64_t{0u}}
    , decltype(_impl_.pennant_item_id_){uint64_t{0u}}
  };
}

CMsgApplyPennantUpgrade::~CMsgApplyPennantUpgrade() {
  // @@protoc_insertion_point(destructor:CMsgApplyPennantUpgrade)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgApplyPennantUpgrade::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgApplyPennantUpgrade::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgApplyPennantUpgrade::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgApplyPennantUpgrade)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.upgrade_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pennant_item_id_) -
        reinterpret_cast<char*>(&_impl_.upgrade_item_id_)) + sizeof(_impl_.pennant_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgApplyPennantUpgrade::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 upgrade_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_upgrade_item_id(&has_bits);
          _impl_.upgrade_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pennant_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pennant_item_id(&has_bits);
          _impl_.pennant_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgApplyPennantUpgrade::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgApplyPennantUpgrade)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 upgrade_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_upgrade_item_id(), target);
  }

  // optional uint64 pennant_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_pennant_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgApplyPennantUpgrade)
  return target;
}

size_t CMsgApplyPennantUpgrade::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgApplyPennantUpgrade)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 upgrade_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_upgrade_item_id());
    }

    // optional uint64 pennant_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pennant_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgApplyPennantUpgrade::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgApplyPennantUpgrade::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgApplyPennantUpgrade::GetClassData() const { return &_class_data_; }


void CMsgApplyPennantUpgrade::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgApplyPennantUpgrade*>(&to_msg);
  auto& from = static_cast<const CMsgApplyPennantUpgrade&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgApplyPennantUpgrade)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.upgrade_item_id_ = from._impl_.upgrade_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pennant_item_id_ = from._impl_.pennant_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgApplyPennantUpgrade::CopyFrom(const CMsgApplyPennantUpgrade& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgApplyPennantUpgrade)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgApplyPennantUpgrade::IsInitialized() const {
  return true;
}

void CMsgApplyPennantUpgrade::InternalSwap(CMsgApplyPennantUpgrade* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgApplyPennantUpgrade, _impl_.pennant_item_id_)
      + sizeof(CMsgApplyPennantUpgrade::_impl_.pennant_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgApplyPennantUpgrade, _impl_.upgrade_item_id_)>(
          reinterpret_cast<char*>(&_impl_.upgrade_item_id_),
          reinterpret_cast<char*>(&other->_impl_.upgrade_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgApplyPennantUpgrade::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[23]);
}

// ===================================================================

class CMsgApplyEggEssence::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgApplyEggEssence>()._impl_._has_bits_);
  static void set_has_essence_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_egg_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgApplyEggEssence::CMsgApplyEggEssence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgApplyEggEssence)
}
CMsgApplyEggEssence::CMsgApplyEggEssence(const CMsgApplyEggEssence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgApplyEggEssence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.essence_item_id_){}
    , decltype(_impl_.egg_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.essence_item_id_, &from._impl_.essence_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.egg_item_id_) -
    reinterpret_cast<char*>(&_impl_.essence_item_id_)) + sizeof(_impl_.egg_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgApplyEggEssence)
}

inline void CMsgApplyEggEssence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.essence_item_id_){uint64_t{0u}}
    , decltype(_impl_.egg_item_id_){uint64_t{0u}}
  };
}

CMsgApplyEggEssence::~CMsgApplyEggEssence() {
  // @@protoc_insertion_point(destructor:CMsgApplyEggEssence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgApplyEggEssence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgApplyEggEssence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgApplyEggEssence::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgApplyEggEssence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.essence_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.egg_item_id_) -
        reinterpret_cast<char*>(&_impl_.essence_item_id_)) + sizeof(_impl_.egg_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgApplyEggEssence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 essence_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_essence_item_id(&has_bits);
          _impl_.essence_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 egg_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_egg_item_id(&has_bits);
          _impl_.egg_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgApplyEggEssence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgApplyEggEssence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 essence_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_essence_item_id(), target);
  }

  // optional uint64 egg_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_egg_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgApplyEggEssence)
  return target;
}

size_t CMsgApplyEggEssence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgApplyEggEssence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 essence_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_essence_item_id());
    }

    // optional uint64 egg_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_egg_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgApplyEggEssence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgApplyEggEssence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgApplyEggEssence::GetClassData() const { return &_class_data_; }


void CMsgApplyEggEssence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgApplyEggEssence*>(&to_msg);
  auto& from = static_cast<const CMsgApplyEggEssence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgApplyEggEssence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.essence_item_id_ = from._impl_.essence_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.egg_item_id_ = from._impl_.egg_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgApplyEggEssence::CopyFrom(const CMsgApplyEggEssence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgApplyEggEssence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgApplyEggEssence::IsInitialized() const {
  return true;
}

void CMsgApplyEggEssence::InternalSwap(CMsgApplyEggEssence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgApplyEggEssence, _impl_.egg_item_id_)
      + sizeof(CMsgApplyEggEssence::_impl_.egg_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgApplyEggEssence, _impl_.essence_item_id_)>(
          reinterpret_cast<char*>(&_impl_.essence_item_id_),
          reinterpret_cast<char*>(&other->_impl_.essence_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgApplyEggEssence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[24]);
}

// ===================================================================

class CSOEconItemAttribute::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemAttribute>()._impl_._has_bits_);
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_value_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSOEconItemAttribute::CSOEconItemAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemAttribute)
}
CSOEconItemAttribute::CSOEconItemAttribute(const CSOEconItemAttribute& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemAttribute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_bytes_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value_bytes()) {
    _this->_impl_.value_bytes_.Set(from._internal_value_bytes(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.def_index_, &from._impl_.def_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.def_index_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemAttribute)
}

inline void CSOEconItemAttribute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_bytes_){}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.value_){0u}
  };
  _impl_.value_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOEconItemAttribute::~CSOEconItemAttribute() {
  // @@protoc_insertion_point(destructor:CSOEconItemAttribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemAttribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_bytes_.Destroy();
}

void CSOEconItemAttribute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemAttribute::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemAttribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.value_bytes_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.def_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.def_index_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 def_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemAttribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemAttribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 def_index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_def_index(), target);
  }

  // optional uint32 value = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  // optional bytes value_bytes = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemAttribute)
  return target;
}

size_t CSOEconItemAttribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemAttribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes value_bytes = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value_bytes());
    }

    // optional uint32 def_index = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 value = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemAttribute::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemAttribute::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemAttribute::GetClassData() const { return &_class_data_; }


void CSOEconItemAttribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemAttribute*>(&to_msg);
  auto& from = static_cast<const CSOEconItemAttribute&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemAttribute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value_bytes(from._internal_value_bytes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemAttribute::CopyFrom(const CSOEconItemAttribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemAttribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemAttribute::IsInitialized() const {
  return true;
}

void CSOEconItemAttribute::InternalSwap(CSOEconItemAttribute* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_bytes_, lhs_arena,
      &other->_impl_.value_bytes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemAttribute, _impl_.value_)
      + sizeof(CSOEconItemAttribute::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemAttribute, _impl_.def_index_)>(
          reinterpret_cast<char*>(&_impl_.def_index_),
          reinterpret_cast<char*>(&other->_impl_.def_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemAttribute::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[25]);
}

// ===================================================================

class CSOEconItemEquipped::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemEquipped>()._impl_._has_bits_);
  static void set_has_new_class(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSOEconItemEquipped::CSOEconItemEquipped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemEquipped)
}
CSOEconItemEquipped::CSOEconItemEquipped(const CSOEconItemEquipped& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemEquipped* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_class_){}
    , decltype(_impl_.new_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.new_class_, &from._impl_.new_class_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_slot_) -
    reinterpret_cast<char*>(&_impl_.new_class_)) + sizeof(_impl_.new_slot_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemEquipped)
}

inline void CSOEconItemEquipped::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_class_){0u}
    , decltype(_impl_.new_slot_){0u}
  };
}

CSOEconItemEquipped::~CSOEconItemEquipped() {
  // @@protoc_insertion_point(destructor:CSOEconItemEquipped)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemEquipped::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemEquipped::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemEquipped::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemEquipped)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.new_class_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_slot_) -
        reinterpret_cast<char*>(&_impl_.new_class_)) + sizeof(_impl_.new_slot_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemEquipped::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 new_class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_new_class(&has_bits);
          _impl_.new_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 new_slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_new_slot(&has_bits);
          _impl_.new_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemEquipped::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemEquipped)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 new_class = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_new_class(), target);
  }

  // optional uint32 new_slot = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_new_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemEquipped)
  return target;
}

size_t CSOEconItemEquipped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemEquipped)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 new_class = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_class());
    }

    // optional uint32 new_slot = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemEquipped::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemEquipped::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemEquipped::GetClassData() const { return &_class_data_; }


void CSOEconItemEquipped::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemEquipped*>(&to_msg);
  auto& from = static_cast<const CSOEconItemEquipped&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemEquipped)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.new_class_ = from._impl_.new_class_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.new_slot_ = from._impl_.new_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemEquipped::CopyFrom(const CSOEconItemEquipped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemEquipped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemEquipped::IsInitialized() const {
  return true;
}

void CSOEconItemEquipped::InternalSwap(CSOEconItemEquipped* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemEquipped, _impl_.new_slot_)
      + sizeof(CSOEconItemEquipped::_impl_.new_slot_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemEquipped, _impl_.new_class_)>(
          reinterpret_cast<char*>(&_impl_.new_class_),
          reinterpret_cast<char*>(&other->_impl_.new_class_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemEquipped::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[26]);
}

// ===================================================================

class CSOEconItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItem>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_custom_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_custom_desc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CSOEconItem& interior_item(const CSOEconItem* msg);
  static void set_has_interior_item(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_in_use(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_original_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_rarity(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::CSOEconItem&
CSOEconItem::_Internal::interior_item(const CSOEconItem* msg) {
  return *msg->_impl_.interior_item_;
}
CSOEconItem::CSOEconItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItem)
}
CSOEconItem::CSOEconItem(const CSOEconItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attribute_){from._impl_.attribute_}
    , decltype(_impl_.equipped_state_){from._impl_.equipped_state_}
    , decltype(_impl_.custom_name_){}
    , decltype(_impl_.custom_desc_){}
    , decltype(_impl_.interior_item_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.inventory_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.in_use_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.original_id_){}
    , decltype(_impl_.rarity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.custom_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_name()) {
    _this->_impl_.custom_name_.Set(from._internal_custom_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.custom_desc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_desc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_desc()) {
    _this->_impl_.custom_desc_.Set(from._internal_custom_desc(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_interior_item()) {
    _this->_impl_.interior_item_ = new ::CSOEconItem(*from._impl_.interior_item_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rarity_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.rarity_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItem)
}

inline void CSOEconItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attribute_){arena}
    , decltype(_impl_.equipped_state_){arena}
    , decltype(_impl_.custom_name_){}
    , decltype(_impl_.custom_desc_){}
    , decltype(_impl_.interior_item_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.inventory_){0u}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.quantity_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.quality_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.origin_){0u}
    , decltype(_impl_.in_use_){false}
    , decltype(_impl_.style_){0u}
    , decltype(_impl_.original_id_){uint64_t{0u}}
    , decltype(_impl_.rarity_){0u}
  };
  _impl_.custom_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.custom_desc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_desc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOEconItem::~CSOEconItem() {
  // @@protoc_insertion_point(destructor:CSOEconItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attribute_.~RepeatedPtrField();
  _impl_.equipped_state_.~RepeatedPtrField();
  _impl_.custom_name_.Destroy();
  _impl_.custom_desc_.Destroy();
  if (this != internal_default_instance()) delete _impl_.interior_item_;
}

void CSOEconItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attribute_.Clear();
  _impl_.equipped_state_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.custom_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.custom_desc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.interior_item_ != nullptr);
      _impl_.interior_item_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quantity_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.quantity_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rarity_) -
        reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.rarity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 inventory = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_inventory(&has_bits);
          _impl_.inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quantity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quality = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 origin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_origin(&has_bits);
          _impl_.origin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string custom_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_custom_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOEconItem.custom_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string custom_desc = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_custom_desc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOEconItem.custom_desc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CSOEconItemAttribute attribute = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attribute(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CSOEconItem interior_item = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_interior_item(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool in_use = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_in_use(&has_bits);
          _impl_.in_use_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 style = 15 [default = 0];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_style(&has_bits);
          _impl_.style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_id = 16 [default = 0];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_original_id(&has_bits);
          _impl_.original_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSOEconItemEquipped equipped_state = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_equipped_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rarity = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_rarity(&has_bits);
          _impl_.rarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional uint32 account_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_account_id(), target);
  }

  // optional uint32 inventory = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_inventory(), target);
  }

  // optional uint32 def_index = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_def_index(), target);
  }

  // optional uint32 quantity = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_quantity(), target);
  }

  // optional uint32 level = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_level(), target);
  }

  // optional uint32 quality = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_quality(), target);
  }

  // optional uint32 flags = 8 [default = 0];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_flags(), target);
  }

  // optional uint32 origin = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_origin(), target);
  }

  // optional string custom_name = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_custom_name().data(), static_cast<int>(this->_internal_custom_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOEconItem.custom_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_custom_name(), target);
  }

  // optional string custom_desc = 11;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_custom_desc().data(), static_cast<int>(this->_internal_custom_desc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOEconItem.custom_desc");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_custom_desc(), target);
  }

  // repeated .CSOEconItemAttribute attribute = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attribute_size()); i < n; i++) {
    const auto& repfield = this->_internal_attribute(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CSOEconItem interior_item = 13;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::interior_item(this),
        _Internal::interior_item(this).GetCachedSize(), target, stream);
  }

  // optional bool in_use = 14 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_in_use(), target);
  }

  // optional uint32 style = 15 [default = 0];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_style(), target);
  }

  // optional uint64 original_id = 16 [default = 0];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(16, this->_internal_original_id(), target);
  }

  // repeated .CSOEconItemEquipped equipped_state = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_equipped_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_equipped_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 rarity = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_rarity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItem)
  return target;
}

size_t CSOEconItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSOEconItemAttribute attribute = 12;
  total_size += 1UL * this->_internal_attribute_size();
  for (const auto& msg : this->_impl_.attribute_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CSOEconItemEquipped equipped_state = 18;
  total_size += 2UL * this->_internal_equipped_state_size();
  for (const auto& msg : this->_impl_.equipped_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string custom_name = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_name());
    }

    // optional string custom_desc = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_desc());
    }

    // optional .CSOEconItem interior_item = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.interior_item_);
    }

    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional uint32 account_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 inventory = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inventory());
    }

    // optional uint32 def_index = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 quantity = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quantity());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 level = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint32 quality = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quality());
    }

    // optional uint32 flags = 8 [default = 0];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 origin = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_origin());
    }

    // optional bool in_use = 14 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 style = 15 [default = 0];
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_style());
    }

    // optional uint64 original_id = 16 [default = 0];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_original_id());
    }

    // optional uint32 rarity = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rarity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItem::GetClassData() const { return &_class_data_; }


void CSOEconItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItem*>(&to_msg);
  auto& from = static_cast<const CSOEconItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attribute_.MergeFrom(from._impl_.attribute_);
  _this->_impl_.equipped_state_.MergeFrom(from._impl_.equipped_state_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_custom_name(from._internal_custom_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_custom_desc(from._internal_custom_desc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_interior_item()->::CSOEconItem::MergeFrom(
          from._internal_interior_item());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.inventory_ = from._impl_.inventory_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.origin_ = from._impl_.origin_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.in_use_ = from._impl_.in_use_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.style_ = from._impl_.style_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.original_id_ = from._impl_.original_id_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.rarity_ = from._impl_.rarity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItem::CopyFrom(const CSOEconItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItem::IsInitialized() const {
  return true;
}

void CSOEconItem::InternalSwap(CSOEconItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attribute_.InternalSwap(&other->_impl_.attribute_);
  _impl_.equipped_state_.InternalSwap(&other->_impl_.equipped_state_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.custom_name_, lhs_arena,
      &other->_impl_.custom_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.custom_desc_, lhs_arena,
      &other->_impl_.custom_desc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItem, _impl_.rarity_)
      + sizeof(CSOEconItem::_impl_.rarity_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItem, _impl_.interior_item_)>(
          reinterpret_cast<char*>(&_impl_.interior_item_),
          reinterpret_cast<char*>(&other->_impl_.interior_item_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[27]);
}

// ===================================================================

class CMsgSortItems::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSortItems>()._impl_._has_bits_);
  static void set_has_sort_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSortItems::CMsgSortItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSortItems)
}
CMsgSortItems::CMsgSortItems(const CMsgSortItems& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSortItems* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sort_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sort_type_ = from._impl_.sort_type_;
  // @@protoc_insertion_point(copy_constructor:CMsgSortItems)
}

inline void CMsgSortItems::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sort_type_){0u}
  };
}

CMsgSortItems::~CMsgSortItems() {
  // @@protoc_insertion_point(destructor:CMsgSortItems)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSortItems::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSortItems::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSortItems::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSortItems)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sort_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSortItems::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sort_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sort_type(&has_bits);
          _impl_.sort_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSortItems::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSortItems)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 sort_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sort_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSortItems)
  return target;
}

size_t CMsgSortItems::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSortItems)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 sort_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sort_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSortItems::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSortItems::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSortItems::GetClassData() const { return &_class_data_; }


void CMsgSortItems::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSortItems*>(&to_msg);
  auto& from = static_cast<const CMsgSortItems&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSortItems)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sort_type()) {
    _this->_internal_set_sort_type(from._internal_sort_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSortItems::CopyFrom(const CMsgSortItems& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSortItems)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSortItems::IsInitialized() const {
  return true;
}

void CMsgSortItems::InternalSwap(CMsgSortItems* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.sort_type_, other->_impl_.sort_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSortItems::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[28]);
}

// ===================================================================

class CSOEconClaimCode::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconClaimCode>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_code_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_acquired(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSOEconClaimCode::CSOEconClaimCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconClaimCode)
}
CSOEconClaimCode::CSOEconClaimCode(const CSOEconClaimCode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconClaimCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.code_type_){}
    , decltype(_impl_.time_acquired_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    _this->_impl_.code_.Set(from._internal_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_acquired_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.time_acquired_));
  // @@protoc_insertion_point(copy_constructor:CSOEconClaimCode)
}

inline void CSOEconClaimCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.code_type_){0u}
    , decltype(_impl_.time_acquired_){0u}
  };
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSOEconClaimCode::~CSOEconClaimCode() {
  // @@protoc_insertion_point(destructor:CSOEconClaimCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconClaimCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.code_.Destroy();
}

void CSOEconClaimCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconClaimCode::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconClaimCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.code_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_acquired_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.time_acquired_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconClaimCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 code_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_code_type(&has_bits);
          _impl_.code_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_acquired = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time_acquired(&has_bits);
          _impl_.time_acquired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSOEconClaimCode.code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconClaimCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconClaimCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 code_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_code_type(), target);
  }

  // optional uint32 time_acquired = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_time_acquired(), target);
  }

  // optional string code = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_code().data(), static_cast<int>(this->_internal_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSOEconClaimCode.code");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconClaimCode)
  return target;
}

size_t CSOEconClaimCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconClaimCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string code = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 code_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_code_type());
    }

    // optional uint32 time_acquired = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_acquired());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconClaimCode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconClaimCode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconClaimCode::GetClassData() const { return &_class_data_; }


void CSOEconClaimCode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconClaimCode*>(&to_msg);
  auto& from = static_cast<const CSOEconClaimCode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconClaimCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.code_type_ = from._impl_.code_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_acquired_ = from._impl_.time_acquired_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconClaimCode::CopyFrom(const CSOEconClaimCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconClaimCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconClaimCode::IsInitialized() const {
  return true;
}

void CSOEconClaimCode::InternalSwap(CSOEconClaimCode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.code_, lhs_arena,
      &other->_impl_.code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconClaimCode, _impl_.time_acquired_)
      + sizeof(CSOEconClaimCode::_impl_.time_acquired_)
      - PROTOBUF_FIELD_OFFSET(CSOEconClaimCode, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconClaimCode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[29]);
}

// ===================================================================

class CMsgStoreGetUserData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStoreGetUserData>()._impl_._has_bits_);
  static void set_has_price_sheet_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgStoreGetUserData::CMsgStoreGetUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStoreGetUserData)
}
CMsgStoreGetUserData::CMsgStoreGetUserData(const CMsgStoreGetUserData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStoreGetUserData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.price_sheet_version_){}
    , decltype(_impl_.currency_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.price_sheet_version_, &from._impl_.price_sheet_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currency_) -
    reinterpret_cast<char*>(&_impl_.price_sheet_version_)) + sizeof(_impl_.currency_));
  // @@protoc_insertion_point(copy_constructor:CMsgStoreGetUserData)
}

inline void CMsgStoreGetUserData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.price_sheet_version_){0u}
    , decltype(_impl_.currency_){0}
  };
}

CMsgStoreGetUserData::~CMsgStoreGetUserData() {
  // @@protoc_insertion_point(destructor:CMsgStoreGetUserData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStoreGetUserData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgStoreGetUserData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStoreGetUserData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStoreGetUserData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.price_sheet_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currency_) -
        reinterpret_cast<char*>(&_impl_.price_sheet_version_)) + sizeof(_impl_.currency_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStoreGetUserData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 price_sheet_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_price_sheet_version(&has_bits);
          _impl_.price_sheet_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 currency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_currency(&has_bits);
          _impl_.currency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStoreGetUserData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStoreGetUserData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 price_sheet_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_price_sheet_version(), target);
  }

  // optional int32 currency = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_currency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStoreGetUserData)
  return target;
}

size_t CMsgStoreGetUserData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStoreGetUserData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed32 price_sheet_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 currency = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currency());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStoreGetUserData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStoreGetUserData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStoreGetUserData::GetClassData() const { return &_class_data_; }


void CMsgStoreGetUserData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStoreGetUserData*>(&to_msg);
  auto& from = static_cast<const CMsgStoreGetUserData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStoreGetUserData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.price_sheet_version_ = from._impl_.price_sheet_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.currency_ = from._impl_.currency_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStoreGetUserData::CopyFrom(const CMsgStoreGetUserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStoreGetUserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStoreGetUserData::IsInitialized() const {
  return true;
}

void CMsgStoreGetUserData::InternalSwap(CMsgStoreGetUserData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStoreGetUserData, _impl_.currency_)
      + sizeof(CMsgStoreGetUserData::_impl_.currency_)
      - PROTOBUF_FIELD_OFFSET(CMsgStoreGetUserData, _impl_.price_sheet_version_)>(
          reinterpret_cast<char*>(&_impl_.price_sheet_version_),
          reinterpret_cast<char*>(&other->_impl_.price_sheet_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStoreGetUserData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[30]);
}

// ===================================================================

class CMsgStoreGetUserDataResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStoreGetUserDataResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_currency_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_country_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_price_sheet_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_price_sheet(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgStoreGetUserDataResponse::CMsgStoreGetUserDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStoreGetUserDataResponse)
}
CMsgStoreGetUserDataResponse::CMsgStoreGetUserDataResponse(const CMsgStoreGetUserDataResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStoreGetUserDataResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_deprecated_){}
    , decltype(_impl_.price_sheet_){}
    , decltype(_impl_.result_){}
    , decltype(_impl_.currency_deprecated_){}
    , decltype(_impl_.price_sheet_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.country_deprecated_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_deprecated_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country_deprecated()) {
    _this->_impl_.country_deprecated_.Set(from._internal_country_deprecated(), 
      _this->GetArenaForAllocation());
  }
  _impl_.price_sheet_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.price_sheet_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_price_sheet()) {
    _this->_impl_.price_sheet_.Set(from._internal_price_sheet(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.result_, &from._impl_.result_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.price_sheet_version_) -
    reinterpret_cast<char*>(&_impl_.result_)) + sizeof(_impl_.price_sheet_version_));
  // @@protoc_insertion_point(copy_constructor:CMsgStoreGetUserDataResponse)
}

inline void CMsgStoreGetUserDataResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_deprecated_){}
    , decltype(_impl_.price_sheet_){}
    , decltype(_impl_.result_){0}
    , decltype(_impl_.currency_deprecated_){0}
    , decltype(_impl_.price_sheet_version_){0u}
  };
  _impl_.country_deprecated_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_deprecated_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.price_sheet_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.price_sheet_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgStoreGetUserDataResponse::~CMsgStoreGetUserDataResponse() {
  // @@protoc_insertion_point(destructor:CMsgStoreGetUserDataResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStoreGetUserDataResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_deprecated_.Destroy();
  _impl_.price_sheet_.Destroy();
}

void CMsgStoreGetUserDataResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStoreGetUserDataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStoreGetUserDataResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.country_deprecated_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.price_sheet_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.result_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.price_sheet_version_) -
        reinterpret_cast<char*>(&_impl_.result_)) + sizeof(_impl_.price_sheet_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStoreGetUserDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 currency_deprecated = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_currency_deprecated(&has_bits);
          _impl_.currency_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country_deprecated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_country_deprecated();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgStoreGetUserDataResponse.country_deprecated");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 price_sheet_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_price_sheet_version(&has_bits);
          _impl_.price_sheet_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes price_sheet = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_price_sheet();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStoreGetUserDataResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStoreGetUserDataResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 result = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  // optional int32 currency_deprecated = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_currency_deprecated(), target);
  }

  // optional string country_deprecated = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country_deprecated().data(), static_cast<int>(this->_internal_country_deprecated().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStoreGetUserDataResponse.country_deprecated");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_country_deprecated(), target);
  }

  // optional fixed32 price_sheet_version = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_price_sheet_version(), target);
  }

  // optional bytes price_sheet = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_price_sheet(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStoreGetUserDataResponse)
  return target;
}

size_t CMsgStoreGetUserDataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStoreGetUserDataResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string country_deprecated = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_deprecated());
    }

    // optional bytes price_sheet = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_price_sheet());
    }

    // optional int32 result = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
    }

    // optional int32 currency_deprecated = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currency_deprecated());
    }

    // optional fixed32 price_sheet_version = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStoreGetUserDataResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStoreGetUserDataResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStoreGetUserDataResponse::GetClassData() const { return &_class_data_; }


void CMsgStoreGetUserDataResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStoreGetUserDataResponse*>(&to_msg);
  auto& from = static_cast<const CMsgStoreGetUserDataResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStoreGetUserDataResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country_deprecated(from._internal_country_deprecated());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_price_sheet(from._internal_price_sheet());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.currency_deprecated_ = from._impl_.currency_deprecated_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.price_sheet_version_ = from._impl_.price_sheet_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStoreGetUserDataResponse::CopyFrom(const CMsgStoreGetUserDataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStoreGetUserDataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStoreGetUserDataResponse::IsInitialized() const {
  return true;
}

void CMsgStoreGetUserDataResponse::InternalSwap(CMsgStoreGetUserDataResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_deprecated_, lhs_arena,
      &other->_impl_.country_deprecated_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.price_sheet_, lhs_arena,
      &other->_impl_.price_sheet_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStoreGetUserDataResponse, _impl_.price_sheet_version_)
      + sizeof(CMsgStoreGetUserDataResponse::_impl_.price_sheet_version_)
      - PROTOBUF_FIELD_OFFSET(CMsgStoreGetUserDataResponse, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStoreGetUserDataResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[31]);
}

// ===================================================================

class CMsgUpdateItemSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgUpdateItemSchema>()._impl_._has_bits_);
  static void set_has_items_game(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_items_game_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgUpdateItemSchema::CMsgUpdateItemSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgUpdateItemSchema)
}
CMsgUpdateItemSchema::CMsgUpdateItemSchema(const CMsgUpdateItemSchema& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgUpdateItemSchema* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_game_){}
    , decltype(_impl_.items_game_url_){}
    , decltype(_impl_.item_schema_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.items_game_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.items_game_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_items_game()) {
    _this->_impl_.items_game_.Set(from._internal_items_game(), 
      _this->GetArenaForAllocation());
  }
  _impl_.items_game_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.items_game_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_items_game_url()) {
    _this->_impl_.items_game_url_.Set(from._internal_items_game_url(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.item_schema_version_ = from._impl_.item_schema_version_;
  // @@protoc_insertion_point(copy_constructor:CMsgUpdateItemSchema)
}

inline void CMsgUpdateItemSchema::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_game_){}
    , decltype(_impl_.items_game_url_){}
    , decltype(_impl_.item_schema_version_){0u}
  };
  _impl_.items_game_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.items_game_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.items_game_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.items_game_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgUpdateItemSchema::~CMsgUpdateItemSchema() {
  // @@protoc_insertion_point(destructor:CMsgUpdateItemSchema)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgUpdateItemSchema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_game_.Destroy();
  _impl_.items_game_url_.Destroy();
}

void CMsgUpdateItemSchema::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgUpdateItemSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgUpdateItemSchema)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.items_game_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.items_game_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.item_schema_version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgUpdateItemSchema::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes items_game = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_items_game();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 item_schema_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_item_schema_version(&has_bits);
          _impl_.item_schema_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string items_game_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_items_game_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgUpdateItemSchema.items_game_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgUpdateItemSchema::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgUpdateItemSchema)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes items_game = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_items_game(), target);
  }

  // optional fixed32 item_schema_version = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_item_schema_version(), target);
  }

  // optional string items_game_url = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_items_game_url().data(), static_cast<int>(this->_internal_items_game_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgUpdateItemSchema.items_game_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_items_game_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgUpdateItemSchema)
  return target;
}

size_t CMsgUpdateItemSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgUpdateItemSchema)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes items_game = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_items_game());
    }

    // optional string items_game_url = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_items_game_url());
    }

    // optional fixed32 item_schema_version = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgUpdateItemSchema::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgUpdateItemSchema::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgUpdateItemSchema::GetClassData() const { return &_class_data_; }


void CMsgUpdateItemSchema::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgUpdateItemSchema*>(&to_msg);
  auto& from = static_cast<const CMsgUpdateItemSchema&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgUpdateItemSchema)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_items_game(from._internal_items_game());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_items_game_url(from._internal_items_game_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_schema_version_ = from._impl_.item_schema_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgUpdateItemSchema::CopyFrom(const CMsgUpdateItemSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgUpdateItemSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgUpdateItemSchema::IsInitialized() const {
  return true;
}

void CMsgUpdateItemSchema::InternalSwap(CMsgUpdateItemSchema* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.items_game_, lhs_arena,
      &other->_impl_.items_game_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.items_game_url_, lhs_arena,
      &other->_impl_.items_game_url_, rhs_arena
  );
  swap(_impl_.item_schema_version_, other->_impl_.item_schema_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgUpdateItemSchema::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[32]);
}

// ===================================================================

class CMsgGCError::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCError>()._impl_._has_bits_);
  static void set_has_error_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCError::CMsgGCError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCError)
}
CMsgGCError::CMsgGCError(const CMsgGCError& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCError* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_text_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_text()) {
    _this->_impl_.error_text_.Set(from._internal_error_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCError)
}

inline void CMsgGCError::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_text_){}
  };
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCError::~CMsgGCError() {
  // @@protoc_insertion_point(destructor:CMsgGCError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_text_.Destroy();
}

void CMsgGCError::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCError::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_text_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCError.error_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string error_text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCError.error_text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCError)
  return target;
}

size_t CMsgGCError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error_text = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCError::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCError::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCError::GetClassData() const { return &_class_data_; }


void CMsgGCError::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCError*>(&to_msg);
  auto& from = static_cast<const CMsgGCError&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCError)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error_text()) {
    _this->_internal_set_error_text(from._internal_error_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCError::CopyFrom(const CMsgGCError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCError::IsInitialized() const {
  return true;
}

void CMsgGCError::InternalSwap(CMsgGCError* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_text_, lhs_arena,
      &other->_impl_.error_text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCError::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[33]);
}

// ===================================================================

class CMsgRequestInventoryRefresh::_Internal {
 public:
};

CMsgRequestInventoryRefresh::CMsgRequestInventoryRefresh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgRequestInventoryRefresh)
}
CMsgRequestInventoryRefresh::CMsgRequestInventoryRefresh(const CMsgRequestInventoryRefresh& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgRequestInventoryRefresh* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgRequestInventoryRefresh)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRequestInventoryRefresh::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRequestInventoryRefresh::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgRequestInventoryRefresh::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[34]);
}

// ===================================================================

class CMsgConVarValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgConVarValue>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgConVarValue::CMsgConVarValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgConVarValue)
}
CMsgConVarValue::CMsgConVarValue(const CMsgConVarValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgConVarValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgConVarValue)
}

inline void CMsgConVarValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgConVarValue::~CMsgConVarValue() {
  // @@protoc_insertion_point(destructor:CMsgConVarValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgConVarValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgConVarValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgConVarValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgConVarValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgConVarValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgConVarValue.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgConVarValue.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgConVarValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgConVarValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgConVarValue.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgConVarValue.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgConVarValue)
  return target;
}

size_t CMsgConVarValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgConVarValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgConVarValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgConVarValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgConVarValue::GetClassData() const { return &_class_data_; }


void CMsgConVarValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgConVarValue*>(&to_msg);
  auto& from = static_cast<const CMsgConVarValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgConVarValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgConVarValue::CopyFrom(const CMsgConVarValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgConVarValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgConVarValue::IsInitialized() const {
  return true;
}

void CMsgConVarValue::InternalSwap(CMsgConVarValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgConVarValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[35]);
}

// ===================================================================

class CMsgReplicateConVars::_Internal {
 public:
};

CMsgReplicateConVars::CMsgReplicateConVars(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgReplicateConVars)
}
CMsgReplicateConVars::CMsgReplicateConVars(const CMsgReplicateConVars& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgReplicateConVars* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.convars_){from._impl_.convars_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgReplicateConVars)
}

inline void CMsgReplicateConVars::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.convars_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgReplicateConVars::~CMsgReplicateConVars() {
  // @@protoc_insertion_point(destructor:CMsgReplicateConVars)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgReplicateConVars::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.convars_.~RepeatedPtrField();
}

void CMsgReplicateConVars::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgReplicateConVars::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgReplicateConVars)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.convars_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgReplicateConVars::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgConVarValue convars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_convars(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgReplicateConVars::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgReplicateConVars)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgConVarValue convars = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_convars_size()); i < n; i++) {
    const auto& repfield = this->_internal_convars(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgReplicateConVars)
  return target;
}

size_t CMsgReplicateConVars::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgReplicateConVars)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgConVarValue convars = 1;
  total_size += 1UL * this->_internal_convars_size();
  for (const auto& msg : this->_impl_.convars_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgReplicateConVars::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgReplicateConVars::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgReplicateConVars::GetClassData() const { return &_class_data_; }


void CMsgReplicateConVars::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgReplicateConVars*>(&to_msg);
  auto& from = static_cast<const CMsgReplicateConVars&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgReplicateConVars)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.convars_.MergeFrom(from._impl_.convars_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgReplicateConVars::CopyFrom(const CMsgReplicateConVars& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgReplicateConVars)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgReplicateConVars::IsInitialized() const {
  return true;
}

void CMsgReplicateConVars::InternalSwap(CMsgReplicateConVars* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.convars_.InternalSwap(&other->_impl_.convars_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgReplicateConVars::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[36]);
}

// ===================================================================

class CMsgUseItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgUseItem>()._impl_._has_bits_);
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duel__class_lock(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_initiator_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgUseItem::CMsgUseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgUseItem)
}
CMsgUseItem::CMsgUseItem(const CMsgUseItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgUseItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gift__potential_targets_){from._impl_.gift__potential_targets_}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.target_steam_id_){}
    , decltype(_impl_.initiator_steam_id_){}
    , decltype(_impl_.duel__class_lock_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_id_, &from._impl_.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.duel__class_lock_) -
    reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.duel__class_lock_));
  // @@protoc_insertion_point(copy_constructor:CMsgUseItem)
}

inline void CMsgUseItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gift__potential_targets_){arena}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.target_steam_id_){uint64_t{0u}}
    , decltype(_impl_.initiator_steam_id_){uint64_t{0u}}
    , decltype(_impl_.duel__class_lock_){0u}
  };
}

CMsgUseItem::~CMsgUseItem() {
  // @@protoc_insertion_point(destructor:CMsgUseItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgUseItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gift__potential_targets_.~RepeatedField();
}

void CMsgUseItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgUseItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgUseItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gift__potential_targets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.duel__class_lock_) -
        reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.duel__class_lock_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgUseItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 target_steam_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_target_steam_id(&has_bits);
          _impl_.target_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 gift__potential_targets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_gift__potential_targets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_gift__potential_targets(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duel__class_lock = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_duel__class_lock(&has_bits);
          _impl_.duel__class_lock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 initiator_steam_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_initiator_steam_id(&has_bits);
          _impl_.initiator_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgUseItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgUseItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_item_id(), target);
  }

  // optional fixed64 target_steam_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_target_steam_id(), target);
  }

  // repeated uint32 gift__potential_targets = 3;
  for (int i = 0, n = this->_internal_gift__potential_targets_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_gift__potential_targets(i), target);
  }

  // optional uint32 duel__class_lock = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_duel__class_lock(), target);
  }

  // optional fixed64 initiator_steam_id = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(5, this->_internal_initiator_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgUseItem)
  return target;
}

size_t CMsgUseItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgUseItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 gift__potential_targets = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.gift__potential_targets_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_gift__potential_targets_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional fixed64 target_steam_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 initiator_steam_id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 duel__class_lock = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duel__class_lock());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgUseItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgUseItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgUseItem::GetClassData() const { return &_class_data_; }


void CMsgUseItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgUseItem*>(&to_msg);
  auto& from = static_cast<const CMsgUseItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgUseItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gift__potential_targets_.MergeFrom(from._impl_.gift__potential_targets_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_steam_id_ = from._impl_.target_steam_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.initiator_steam_id_ = from._impl_.initiator_steam_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.duel__class_lock_ = from._impl_.duel__class_lock_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgUseItem::CopyFrom(const CMsgUseItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgUseItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgUseItem::IsInitialized() const {
  return true;
}

void CMsgUseItem::InternalSwap(CMsgUseItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.gift__potential_targets_.InternalSwap(&other->_impl_.gift__potential_targets_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgUseItem, _impl_.duel__class_lock_)
      + sizeof(CMsgUseItem::_impl_.duel__class_lock_)
      - PROTOBUF_FIELD_OFFSET(CMsgUseItem, _impl_.item_id_)>(
          reinterpret_cast<char*>(&_impl_.item_id_),
          reinterpret_cast<char*>(&other->_impl_.item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgUseItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[37]);
}

// ===================================================================

class CMsgReplayUploadedToYouTube::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgReplayUploadedToYouTube>()._impl_._has_bits_);
  static void set_has_youtube_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_youtube_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgReplayUploadedToYouTube::CMsgReplayUploadedToYouTube(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgReplayUploadedToYouTube)
}
CMsgReplayUploadedToYouTube::CMsgReplayUploadedToYouTube(const CMsgReplayUploadedToYouTube& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgReplayUploadedToYouTube* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.youtube_url_){}
    , decltype(_impl_.youtube_account_name_){}
    , decltype(_impl_.session_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.youtube_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.youtube_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_youtube_url()) {
    _this->_impl_.youtube_url_.Set(from._internal_youtube_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.youtube_account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.youtube_account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_youtube_account_name()) {
    _this->_impl_.youtube_account_name_.Set(from._internal_youtube_account_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.session_id_ = from._impl_.session_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgReplayUploadedToYouTube)
}

inline void CMsgReplayUploadedToYouTube::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.youtube_url_){}
    , decltype(_impl_.youtube_account_name_){}
    , decltype(_impl_.session_id_){uint64_t{0u}}
  };
  _impl_.youtube_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.youtube_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.youtube_account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.youtube_account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgReplayUploadedToYouTube::~CMsgReplayUploadedToYouTube() {
  // @@protoc_insertion_point(destructor:CMsgReplayUploadedToYouTube)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgReplayUploadedToYouTube::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.youtube_url_.Destroy();
  _impl_.youtube_account_name_.Destroy();
}

void CMsgReplayUploadedToYouTube::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgReplayUploadedToYouTube::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgReplayUploadedToYouTube)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.youtube_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.youtube_account_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.session_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgReplayUploadedToYouTube::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string youtube_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_youtube_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgReplayUploadedToYouTube.youtube_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string youtube_account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_youtube_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgReplayUploadedToYouTube.youtube_account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_session_id(&has_bits);
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgReplayUploadedToYouTube::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgReplayUploadedToYouTube)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string youtube_url = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_youtube_url().data(), static_cast<int>(this->_internal_youtube_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgReplayUploadedToYouTube.youtube_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_youtube_url(), target);
  }

  // optional string youtube_account_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_youtube_account_name().data(), static_cast<int>(this->_internal_youtube_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgReplayUploadedToYouTube.youtube_account_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_youtube_account_name(), target);
  }

  // optional uint64 session_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgReplayUploadedToYouTube)
  return target;
}

size_t CMsgReplayUploadedToYouTube::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgReplayUploadedToYouTube)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string youtube_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_youtube_url());
    }

    // optional string youtube_account_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_youtube_account_name());
    }

    // optional uint64 session_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_session_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgReplayUploadedToYouTube::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgReplayUploadedToYouTube::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgReplayUploadedToYouTube::GetClassData() const { return &_class_data_; }


void CMsgReplayUploadedToYouTube::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgReplayUploadedToYouTube*>(&to_msg);
  auto& from = static_cast<const CMsgReplayUploadedToYouTube&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgReplayUploadedToYouTube)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_youtube_url(from._internal_youtube_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_youtube_account_name(from._internal_youtube_account_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.session_id_ = from._impl_.session_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgReplayUploadedToYouTube::CopyFrom(const CMsgReplayUploadedToYouTube& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgReplayUploadedToYouTube)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgReplayUploadedToYouTube::IsInitialized() const {
  return true;
}

void CMsgReplayUploadedToYouTube::InternalSwap(CMsgReplayUploadedToYouTube* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.youtube_url_, lhs_arena,
      &other->_impl_.youtube_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.youtube_account_name_, lhs_arena,
      &other->_impl_.youtube_account_name_, rhs_arena
  );
  swap(_impl_.session_id_, other->_impl_.session_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgReplayUploadedToYouTube::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[38]);
}

// ===================================================================

class CMsgConsumableExhausted::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgConsumableExhausted>()._impl_._has_bits_);
  static void set_has_item_def_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgConsumableExhausted::CMsgConsumableExhausted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgConsumableExhausted)
}
CMsgConsumableExhausted::CMsgConsumableExhausted(const CMsgConsumableExhausted& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgConsumableExhausted* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.item_def_id_ = from._impl_.item_def_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgConsumableExhausted)
}

inline void CMsgConsumableExhausted::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){0}
  };
}

CMsgConsumableExhausted::~CMsgConsumableExhausted() {
  // @@protoc_insertion_point(destructor:CMsgConsumableExhausted)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgConsumableExhausted::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgConsumableExhausted::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgConsumableExhausted::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgConsumableExhausted)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_def_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgConsumableExhausted::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_def_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def_id(&has_bits);
          _impl_.item_def_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgConsumableExhausted::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgConsumableExhausted)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_def_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_def_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgConsumableExhausted)
  return target;
}

size_t CMsgConsumableExhausted::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgConsumableExhausted)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 item_def_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_def_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgConsumableExhausted::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgConsumableExhausted::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgConsumableExhausted::GetClassData() const { return &_class_data_; }


void CMsgConsumableExhausted::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgConsumableExhausted*>(&to_msg);
  auto& from = static_cast<const CMsgConsumableExhausted&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgConsumableExhausted)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_item_def_id()) {
    _this->_internal_set_item_def_id(from._internal_item_def_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgConsumableExhausted::CopyFrom(const CMsgConsumableExhausted& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgConsumableExhausted)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgConsumableExhausted::IsInitialized() const {
  return true;
}

void CMsgConsumableExhausted::InternalSwap(CMsgConsumableExhausted* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.item_def_id_, other->_impl_.item_def_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgConsumableExhausted::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[39]);
}

// ===================================================================

class CMsgItemAcknowledged__DEPRECATED::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgItemAcknowledged__DEPRECATED>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rarity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgItemAcknowledged__DEPRECATED::CMsgItemAcknowledged__DEPRECATED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgItemAcknowledged__DEPRECATED)
}
CMsgItemAcknowledged__DEPRECATED::CMsgItemAcknowledged__DEPRECATED(const CMsgItemAcknowledged__DEPRECATED& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgItemAcknowledged__DEPRECATED* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.inventory_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.rarity_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgItemAcknowledged__DEPRECATED)
}

inline void CMsgItemAcknowledged__DEPRECATED::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.inventory_){0u}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.quality_){0u}
    , decltype(_impl_.rarity_){0u}
    , decltype(_impl_.origin_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
  };
}

CMsgItemAcknowledged__DEPRECATED::~CMsgItemAcknowledged__DEPRECATED() {
  // @@protoc_insertion_point(destructor:CMsgItemAcknowledged__DEPRECATED)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgItemAcknowledged__DEPRECATED::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgItemAcknowledged__DEPRECATED::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgItemAcknowledged__DEPRECATED::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgItemAcknowledged__DEPRECATED)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgItemAcknowledged__DEPRECATED::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 inventory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_inventory(&has_bits);
          _impl_.inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quality = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rarity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rarity(&has_bits);
          _impl_.rarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 origin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_origin(&has_bits);
          _impl_.origin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgItemAcknowledged__DEPRECATED::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgItemAcknowledged__DEPRECATED)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 inventory = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_inventory(), target);
  }

  // optional uint32 def_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_def_index(), target);
  }

  // optional uint32 quality = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_quality(), target);
  }

  // optional uint32 rarity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_rarity(), target);
  }

  // optional uint32 origin = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_origin(), target);
  }

  // optional uint64 item_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgItemAcknowledged__DEPRECATED)
  return target;
}

size_t CMsgItemAcknowledged__DEPRECATED::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgItemAcknowledged__DEPRECATED)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 inventory = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inventory());
    }

    // optional uint32 def_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 quality = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quality());
    }

    // optional uint32 rarity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rarity());
    }

    // optional uint32 origin = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_origin());
    }

    // optional uint64 item_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgItemAcknowledged__DEPRECATED::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgItemAcknowledged__DEPRECATED::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgItemAcknowledged__DEPRECATED::GetClassData() const { return &_class_data_; }


void CMsgItemAcknowledged__DEPRECATED::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgItemAcknowledged__DEPRECATED*>(&to_msg);
  auto& from = static_cast<const CMsgItemAcknowledged__DEPRECATED&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgItemAcknowledged__DEPRECATED)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.inventory_ = from._impl_.inventory_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rarity_ = from._impl_.rarity_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.origin_ = from._impl_.origin_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgItemAcknowledged__DEPRECATED::CopyFrom(const CMsgItemAcknowledged__DEPRECATED& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgItemAcknowledged__DEPRECATED)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgItemAcknowledged__DEPRECATED::IsInitialized() const {
  return true;
}

void CMsgItemAcknowledged__DEPRECATED::InternalSwap(CMsgItemAcknowledged__DEPRECATED* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgItemAcknowledged__DEPRECATED, _impl_.item_id_)
      + sizeof(CMsgItemAcknowledged__DEPRECATED::_impl_.item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgItemAcknowledged__DEPRECATED, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgItemAcknowledged__DEPRECATED::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[40]);
}

// ===================================================================

class CMsgSetItemPositions_ItemPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSetItemPositions_ItemPosition>()._impl_._has_bits_);
  static void set_has_legacy_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSetItemPositions_ItemPosition::CMsgSetItemPositions_ItemPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSetItemPositions.ItemPosition)
}
CMsgSetItemPositions_ItemPosition::CMsgSetItemPositions_ItemPosition(const CMsgSetItemPositions_ItemPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSetItemPositions_ItemPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.legacy_item_id_){}
    , decltype(_impl_.position_){}
    , decltype(_impl_.item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.legacy_item_id_, &from._impl_.legacy_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_id_) -
    reinterpret_cast<char*>(&_impl_.legacy_item_id_)) + sizeof(_impl_.item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSetItemPositions.ItemPosition)
}

inline void CMsgSetItemPositions_ItemPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.legacy_item_id_){0u}
    , decltype(_impl_.position_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
  };
}

CMsgSetItemPositions_ItemPosition::~CMsgSetItemPositions_ItemPosition() {
  // @@protoc_insertion_point(destructor:CMsgSetItemPositions.ItemPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSetItemPositions_ItemPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSetItemPositions_ItemPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSetItemPositions_ItemPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSetItemPositions.ItemPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.legacy_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_id_) -
        reinterpret_cast<char*>(&_impl_.legacy_item_id_)) + sizeof(_impl_.item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSetItemPositions_ItemPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 legacy_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_legacy_item_id(&has_bits);
          _impl_.legacy_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSetItemPositions_ItemPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSetItemPositions.ItemPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 legacy_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_legacy_item_id(), target);
  }

  // optional uint32 position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_position(), target);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSetItemPositions.ItemPosition)
  return target;
}

size_t CMsgSetItemPositions_ItemPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSetItemPositions.ItemPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 legacy_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_item_id());
    }

    // optional uint32 position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_position());
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSetItemPositions_ItemPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSetItemPositions_ItemPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSetItemPositions_ItemPosition::GetClassData() const { return &_class_data_; }


void CMsgSetItemPositions_ItemPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSetItemPositions_ItemPosition*>(&to_msg);
  auto& from = static_cast<const CMsgSetItemPositions_ItemPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSetItemPositions.ItemPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.legacy_item_id_ = from._impl_.legacy_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSetItemPositions_ItemPosition::CopyFrom(const CMsgSetItemPositions_ItemPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSetItemPositions.ItemPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSetItemPositions_ItemPosition::IsInitialized() const {
  return true;
}

void CMsgSetItemPositions_ItemPosition::InternalSwap(CMsgSetItemPositions_ItemPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSetItemPositions_ItemPosition, _impl_.item_id_)
      + sizeof(CMsgSetItemPositions_ItemPosition::_impl_.item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSetItemPositions_ItemPosition, _impl_.legacy_item_id_)>(
          reinterpret_cast<char*>(&_impl_.legacy_item_id_),
          reinterpret_cast<char*>(&other->_impl_.legacy_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSetItemPositions_ItemPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[41]);
}

// ===================================================================

class CMsgSetItemPositions::_Internal {
 public:
};

CMsgSetItemPositions::CMsgSetItemPositions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSetItemPositions)
}
CMsgSetItemPositions::CMsgSetItemPositions(const CMsgSetItemPositions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSetItemPositions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_positions_){from._impl_.item_positions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgSetItemPositions)
}

inline void CMsgSetItemPositions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_positions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgSetItemPositions::~CMsgSetItemPositions() {
  // @@protoc_insertion_point(destructor:CMsgSetItemPositions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSetItemPositions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_positions_.~RepeatedPtrField();
}

void CMsgSetItemPositions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSetItemPositions::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSetItemPositions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_positions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSetItemPositions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSetItemPositions.ItemPosition item_positions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSetItemPositions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSetItemPositions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSetItemPositions.ItemPosition item_positions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_item_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSetItemPositions)
  return target;
}

size_t CMsgSetItemPositions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSetItemPositions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSetItemPositions.ItemPosition item_positions = 1;
  total_size += 1UL * this->_internal_item_positions_size();
  for (const auto& msg : this->_impl_.item_positions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSetItemPositions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSetItemPositions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSetItemPositions::GetClassData() const { return &_class_data_; }


void CMsgSetItemPositions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSetItemPositions*>(&to_msg);
  auto& from = static_cast<const CMsgSetItemPositions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSetItemPositions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_positions_.MergeFrom(from._impl_.item_positions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSetItemPositions::CopyFrom(const CMsgSetItemPositions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSetItemPositions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSetItemPositions::IsInitialized() const {
  return true;
}

void CMsgSetItemPositions::InternalSwap(CMsgSetItemPositions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.item_positions_.InternalSwap(&other->_impl_.item_positions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSetItemPositions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[42]);
}

// ===================================================================

class CMsgGCReportAbuse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCReportAbuse>()._impl_._has_bits_);
  static void set_has_target_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_abuse_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_content_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_game_server_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_target_game_server_port(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgGCReportAbuse::CMsgGCReportAbuse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCReportAbuse)
}
CMsgGCReportAbuse::CMsgGCReportAbuse(const CMsgGCReportAbuse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCReportAbuse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_){}
    , decltype(_impl_.target_steam_id_){}
    , decltype(_impl_.abuse_type_){}
    , decltype(_impl_.content_type_){}
    , decltype(_impl_.gid_){}
    , decltype(_impl_.target_game_server_ip_){}
    , decltype(_impl_.target_game_server_port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.target_steam_id_, &from._impl_.target_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_game_server_port_) -
    reinterpret_cast<char*>(&_impl_.target_steam_id_)) + sizeof(_impl_.target_game_server_port_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCReportAbuse)
}

inline void CMsgGCReportAbuse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_){}
    , decltype(_impl_.target_steam_id_){uint64_t{0u}}
    , decltype(_impl_.abuse_type_){0u}
    , decltype(_impl_.content_type_){0u}
    , decltype(_impl_.gid_){uint64_t{0u}}
    , decltype(_impl_.target_game_server_ip_){0u}
    , decltype(_impl_.target_game_server_port_){0u}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCReportAbuse::~CMsgGCReportAbuse() {
  // @@protoc_insertion_point(destructor:CMsgGCReportAbuse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCReportAbuse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.description_.Destroy();
}

void CMsgGCReportAbuse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCReportAbuse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCReportAbuse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.target_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_game_server_port_) -
        reinterpret_cast<char*>(&_impl_.target_steam_id_)) + sizeof(_impl_.target_game_server_port_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCReportAbuse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 target_steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_target_steam_id(&has_bits);
          _impl_.target_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 abuse_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_abuse_type(&has_bits);
          _impl_.abuse_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 content_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_content_type(&has_bits);
          _impl_.content_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCReportAbuse.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 target_game_server_ip = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_target_game_server_ip(&has_bits);
          _impl_.target_game_server_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_game_server_port = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_target_game_server_port(&has_bits);
          _impl_.target_game_server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCReportAbuse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCReportAbuse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 target_steam_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_target_steam_id(), target);
  }

  // optional uint32 abuse_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_abuse_type(), target);
  }

  // optional uint32 content_type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_content_type(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCReportAbuse.description");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional uint64 gid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_gid(), target);
  }

  // optional fixed32 target_game_server_ip = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_target_game_server_ip(), target);
  }

  // optional uint32 target_game_server_port = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_target_game_server_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCReportAbuse)
  return target;
}

size_t CMsgGCReportAbuse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCReportAbuse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string description = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional fixed64 target_steam_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 abuse_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_abuse_type());
    }

    // optional uint32 content_type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_content_type());
    }

    // optional uint64 gid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gid());
    }

    // optional fixed32 target_game_server_ip = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 target_game_server_port = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_game_server_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCReportAbuse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCReportAbuse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCReportAbuse::GetClassData() const { return &_class_data_; }


void CMsgGCReportAbuse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCReportAbuse*>(&to_msg);
  auto& from = static_cast<const CMsgGCReportAbuse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCReportAbuse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_steam_id_ = from._impl_.target_steam_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.abuse_type_ = from._impl_.abuse_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.content_type_ = from._impl_.content_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.target_game_server_ip_ = from._impl_.target_game_server_ip_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.target_game_server_port_ = from._impl_.target_game_server_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCReportAbuse::CopyFrom(const CMsgGCReportAbuse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCReportAbuse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCReportAbuse::IsInitialized() const {
  return true;
}

void CMsgGCReportAbuse::InternalSwap(CMsgGCReportAbuse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCReportAbuse, _impl_.target_game_server_port_)
      + sizeof(CMsgGCReportAbuse::_impl_.target_game_server_port_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCReportAbuse, _impl_.target_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.target_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.target_steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCReportAbuse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[43]);
}

// ===================================================================

class CMsgGCReportAbuseResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCReportAbuseResponse>()._impl_._has_bits_);
  static void set_has_target_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCReportAbuseResponse::CMsgGCReportAbuseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCReportAbuseResponse)
}
CMsgGCReportAbuseResponse::CMsgGCReportAbuseResponse(const CMsgGCReportAbuseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCReportAbuseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.target_steam_id_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.target_steam_id_, &from._impl_.target_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_) -
    reinterpret_cast<char*>(&_impl_.target_steam_id_)) + sizeof(_impl_.result_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCReportAbuseResponse)
}

inline void CMsgGCReportAbuseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.target_steam_id_){uint64_t{0u}}
    , decltype(_impl_.result_){0u}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCReportAbuseResponse::~CMsgGCReportAbuseResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCReportAbuseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCReportAbuseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
}

void CMsgGCReportAbuseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCReportAbuseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCReportAbuseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.target_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.result_) -
        reinterpret_cast<char*>(&_impl_.target_steam_id_)) + sizeof(_impl_.result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCReportAbuseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 target_steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_target_steam_id(&has_bits);
          _impl_.target_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCReportAbuseResponse.error_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCReportAbuseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCReportAbuseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 target_steam_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_target_steam_id(), target);
  }

  // optional uint32 result = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCReportAbuseResponse.error_message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCReportAbuseResponse)
  return target;
}

size_t CMsgGCReportAbuseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCReportAbuseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional fixed64 target_steam_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 result = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCReportAbuseResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCReportAbuseResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCReportAbuseResponse::GetClassData() const { return &_class_data_; }


void CMsgGCReportAbuseResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCReportAbuseResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCReportAbuseResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCReportAbuseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_steam_id_ = from._impl_.target_steam_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCReportAbuseResponse::CopyFrom(const CMsgGCReportAbuseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCReportAbuseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCReportAbuseResponse::IsInitialized() const {
  return true;
}

void CMsgGCReportAbuseResponse::InternalSwap(CMsgGCReportAbuseResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCReportAbuseResponse, _impl_.result_)
      + sizeof(CMsgGCReportAbuseResponse::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCReportAbuseResponse, _impl_.target_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.target_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.target_steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCReportAbuseResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[44]);
}

// ===================================================================

class CMsgGCNameItemNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCNameItemNotification>()._impl_._has_bits_);
  static void set_has_player_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_item_name_custom(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCNameItemNotification::CMsgGCNameItemNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCNameItemNotification)
}
CMsgGCNameItemNotification::CMsgGCNameItemNotification(const CMsgGCNameItemNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCNameItemNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_name_custom_){}
    , decltype(_impl_.player_steamid_){}
    , decltype(_impl_.item_def_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.item_name_custom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_name_custom_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_item_name_custom()) {
    _this->_impl_.item_name_custom_.Set(from._internal_item_name_custom(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.player_steamid_, &from._impl_.player_steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_def_index_) -
    reinterpret_cast<char*>(&_impl_.player_steamid_)) + sizeof(_impl_.item_def_index_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCNameItemNotification)
}

inline void CMsgGCNameItemNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_name_custom_){}
    , decltype(_impl_.player_steamid_){uint64_t{0u}}
    , decltype(_impl_.item_def_index_){0u}
  };
  _impl_.item_name_custom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_name_custom_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCNameItemNotification::~CMsgGCNameItemNotification() {
  // @@protoc_insertion_point(destructor:CMsgGCNameItemNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCNameItemNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_name_custom_.Destroy();
}

void CMsgGCNameItemNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCNameItemNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCNameItemNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.item_name_custom_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.player_steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_def_index_) -
        reinterpret_cast<char*>(&_impl_.player_steamid_)) + sizeof(_impl_.item_def_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCNameItemNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 player_steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_player_steamid(&has_bits);
          _impl_.player_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_def_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_def_index(&has_bits);
          _impl_.item_def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string item_name_custom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_item_name_custom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCNameItemNotification.item_name_custom");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCNameItemNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCNameItemNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 player_steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_player_steamid(), target);
  }

  // optional uint32 item_def_index = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_item_def_index(), target);
  }

  // optional string item_name_custom = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_item_name_custom().data(), static_cast<int>(this->_internal_item_name_custom().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCNameItemNotification.item_name_custom");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_item_name_custom(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCNameItemNotification)
  return target;
}

size_t CMsgGCNameItemNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCNameItemNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string item_name_custom = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_item_name_custom());
    }

    // optional fixed64 player_steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 item_def_index = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCNameItemNotification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCNameItemNotification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCNameItemNotification::GetClassData() const { return &_class_data_; }


void CMsgGCNameItemNotification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCNameItemNotification*>(&to_msg);
  auto& from = static_cast<const CMsgGCNameItemNotification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCNameItemNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_item_name_custom(from._internal_item_name_custom());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_steamid_ = from._impl_.player_steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_def_index_ = from._impl_.item_def_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCNameItemNotification::CopyFrom(const CMsgGCNameItemNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCNameItemNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCNameItemNotification::IsInitialized() const {
  return true;
}

void CMsgGCNameItemNotification::InternalSwap(CMsgGCNameItemNotification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_name_custom_, lhs_arena,
      &other->_impl_.item_name_custom_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCNameItemNotification, _impl_.item_def_index_)
      + sizeof(CMsgGCNameItemNotification::_impl_.item_def_index_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCNameItemNotification, _impl_.player_steamid_)>(
          reinterpret_cast<char*>(&_impl_.player_steamid_),
          reinterpret_cast<char*>(&other->_impl_.player_steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCNameItemNotification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[45]);
}

// ===================================================================

class CMsgGCClientDisplayNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCClientDisplayNotification>()._impl_._has_bits_);
  static void set_has_notification_title_localization_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_notification_body_localization_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCClientDisplayNotification::CMsgGCClientDisplayNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCClientDisplayNotification)
}
CMsgGCClientDisplayNotification::CMsgGCClientDisplayNotification(const CMsgGCClientDisplayNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCClientDisplayNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_substring_keys_){from._impl_.body_substring_keys_}
    , decltype(_impl_.body_substring_values_){from._impl_.body_substring_values_}
    , decltype(_impl_.notification_title_localization_key_){}
    , decltype(_impl_.notification_body_localization_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.notification_title_localization_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_title_localization_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_notification_title_localization_key()) {
    _this->_impl_.notification_title_localization_key_.Set(from._internal_notification_title_localization_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.notification_body_localization_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_body_localization_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_notification_body_localization_key()) {
    _this->_impl_.notification_body_localization_key_.Set(from._internal_notification_body_localization_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCClientDisplayNotification)
}

inline void CMsgGCClientDisplayNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_substring_keys_){arena}
    , decltype(_impl_.body_substring_values_){arena}
    , decltype(_impl_.notification_title_localization_key_){}
    , decltype(_impl_.notification_body_localization_key_){}
  };
  _impl_.notification_title_localization_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_title_localization_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.notification_body_localization_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_body_localization_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCClientDisplayNotification::~CMsgGCClientDisplayNotification() {
  // @@protoc_insertion_point(destructor:CMsgGCClientDisplayNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCClientDisplayNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_substring_keys_.~RepeatedPtrField();
  _impl_.body_substring_values_.~RepeatedPtrField();
  _impl_.notification_title_localization_key_.Destroy();
  _impl_.notification_body_localization_key_.Destroy();
}

void CMsgGCClientDisplayNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCClientDisplayNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCClientDisplayNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.body_substring_keys_.Clear();
  _impl_.body_substring_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.notification_title_localization_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.notification_body_localization_key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCClientDisplayNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string notification_title_localization_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_notification_title_localization_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCClientDisplayNotification.notification_title_localization_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string notification_body_localization_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_notification_body_localization_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCClientDisplayNotification.notification_body_localization_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string body_substring_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_body_substring_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CMsgGCClientDisplayNotification.body_substring_keys");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string body_substring_values = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_body_substring_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CMsgGCClientDisplayNotification.body_substring_values");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCClientDisplayNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCClientDisplayNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string notification_title_localization_key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_notification_title_localization_key().data(), static_cast<int>(this->_internal_notification_title_localization_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCClientDisplayNotification.notification_title_localization_key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_notification_title_localization_key(), target);
  }

  // optional string notification_body_localization_key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_notification_body_localization_key().data(), static_cast<int>(this->_internal_notification_body_localization_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCClientDisplayNotification.notification_body_localization_key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_notification_body_localization_key(), target);
  }

  // repeated string body_substring_keys = 3;
  for (int i = 0, n = this->_internal_body_substring_keys_size(); i < n; i++) {
    const auto& s = this->_internal_body_substring_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCClientDisplayNotification.body_substring_keys");
    target = stream->WriteString(3, s, target);
  }

  // repeated string body_substring_values = 4;
  for (int i = 0, n = this->_internal_body_substring_values_size(); i < n; i++) {
    const auto& s = this->_internal_body_substring_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCClientDisplayNotification.body_substring_values");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCClientDisplayNotification)
  return target;
}

size_t CMsgGCClientDisplayNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCClientDisplayNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string body_substring_keys = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.body_substring_keys_.size());
  for (int i = 0, n = _impl_.body_substring_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.body_substring_keys_.Get(i));
  }

  // repeated string body_substring_values = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.body_substring_values_.size());
  for (int i = 0, n = _impl_.body_substring_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.body_substring_values_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string notification_title_localization_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_notification_title_localization_key());
    }

    // optional string notification_body_localization_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_notification_body_localization_key());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCClientDisplayNotification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCClientDisplayNotification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCClientDisplayNotification::GetClassData() const { return &_class_data_; }


void CMsgGCClientDisplayNotification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCClientDisplayNotification*>(&to_msg);
  auto& from = static_cast<const CMsgGCClientDisplayNotification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCClientDisplayNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.body_substring_keys_.MergeFrom(from._impl_.body_substring_keys_);
  _this->_impl_.body_substring_values_.MergeFrom(from._impl_.body_substring_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_notification_title_localization_key(from._internal_notification_title_localization_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_notification_body_localization_key(from._internal_notification_body_localization_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCClientDisplayNotification::CopyFrom(const CMsgGCClientDisplayNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCClientDisplayNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCClientDisplayNotification::IsInitialized() const {
  return true;
}

void CMsgGCClientDisplayNotification::InternalSwap(CMsgGCClientDisplayNotification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.body_substring_keys_.InternalSwap(&other->_impl_.body_substring_keys_);
  _impl_.body_substring_values_.InternalSwap(&other->_impl_.body_substring_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.notification_title_localization_key_, lhs_arena,
      &other->_impl_.notification_title_localization_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.notification_body_localization_key_, lhs_arena,
      &other->_impl_.notification_body_localization_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCClientDisplayNotification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[46]);
}

// ===================================================================

class CMsgGCShowItemsPickedUp::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCShowItemsPickedUp>()._impl_._has_bits_);
  static void set_has_player_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCShowItemsPickedUp::CMsgGCShowItemsPickedUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCShowItemsPickedUp)
}
CMsgGCShowItemsPickedUp::CMsgGCShowItemsPickedUp(const CMsgGCShowItemsPickedUp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCShowItemsPickedUp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_steamid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_steamid_ = from._impl_.player_steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCShowItemsPickedUp)
}

inline void CMsgGCShowItemsPickedUp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_steamid_){uint64_t{0u}}
  };
}

CMsgGCShowItemsPickedUp::~CMsgGCShowItemsPickedUp() {
  // @@protoc_insertion_point(destructor:CMsgGCShowItemsPickedUp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCShowItemsPickedUp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCShowItemsPickedUp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCShowItemsPickedUp::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCShowItemsPickedUp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCShowItemsPickedUp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 player_steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_player_steamid(&has_bits);
          _impl_.player_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCShowItemsPickedUp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCShowItemsPickedUp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 player_steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_player_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCShowItemsPickedUp)
  return target;
}

size_t CMsgGCShowItemsPickedUp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCShowItemsPickedUp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 player_steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCShowItemsPickedUp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCShowItemsPickedUp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCShowItemsPickedUp::GetClassData() const { return &_class_data_; }


void CMsgGCShowItemsPickedUp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCShowItemsPickedUp*>(&to_msg);
  auto& from = static_cast<const CMsgGCShowItemsPickedUp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCShowItemsPickedUp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_steamid()) {
    _this->_internal_set_player_steamid(from._internal_player_steamid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCShowItemsPickedUp::CopyFrom(const CMsgGCShowItemsPickedUp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCShowItemsPickedUp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCShowItemsPickedUp::IsInitialized() const {
  return true;
}

void CMsgGCShowItemsPickedUp::InternalSwap(CMsgGCShowItemsPickedUp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_steamid_, other->_impl_.player_steamid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCShowItemsPickedUp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[47]);
}

// ===================================================================

class CMsgGCIncrementKillCountResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCIncrementKillCountResponse>()._impl_._has_bits_);
  static void set_has_killer_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_def(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_level_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCIncrementKillCountResponse::CMsgGCIncrementKillCountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCIncrementKillCountResponse)
}
CMsgGCIncrementKillCountResponse::CMsgGCIncrementKillCountResponse(const CMsgGCIncrementKillCountResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCIncrementKillCountResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.killer_account_id_){}
    , decltype(_impl_.num_kills_){}
    , decltype(_impl_.item_def_){}
    , decltype(_impl_.level_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.killer_account_id_, &from._impl_.killer_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_type_) -
    reinterpret_cast<char*>(&_impl_.killer_account_id_)) + sizeof(_impl_.level_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCIncrementKillCountResponse)
}

inline void CMsgGCIncrementKillCountResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.killer_account_id_){0u}
    , decltype(_impl_.num_kills_){0u}
    , decltype(_impl_.item_def_){0u}
    , decltype(_impl_.level_type_){0u}
  };
}

CMsgGCIncrementKillCountResponse::~CMsgGCIncrementKillCountResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCIncrementKillCountResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCIncrementKillCountResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCIncrementKillCountResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCIncrementKillCountResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCIncrementKillCountResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.killer_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level_type_) -
        reinterpret_cast<char*>(&_impl_.killer_account_id_)) + sizeof(_impl_.level_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCIncrementKillCountResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 killer_account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_killer_account_id(&has_bits);
          _impl_.killer_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_kills = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_kills(&has_bits);
          _impl_.num_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_def = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_def(&has_bits);
          _impl_.item_def_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_level_type(&has_bits);
          _impl_.level_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCIncrementKillCountResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCIncrementKillCountResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 killer_account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_killer_account_id(), target);
  }

  // optional uint32 num_kills = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_kills(), target);
  }

  // optional uint32 item_def = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_item_def(), target);
  }

  // optional uint32 level_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_level_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCIncrementKillCountResponse)
  return target;
}

size_t CMsgGCIncrementKillCountResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCIncrementKillCountResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 killer_account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_killer_account_id());
    }

    // optional uint32 num_kills = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_kills());
    }

    // optional uint32 item_def = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def());
    }

    // optional uint32 level_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCIncrementKillCountResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCIncrementKillCountResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCIncrementKillCountResponse::GetClassData() const { return &_class_data_; }


void CMsgGCIncrementKillCountResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCIncrementKillCountResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCIncrementKillCountResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCIncrementKillCountResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.killer_account_id_ = from._impl_.killer_account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_kills_ = from._impl_.num_kills_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_def_ = from._impl_.item_def_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.level_type_ = from._impl_.level_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCIncrementKillCountResponse::CopyFrom(const CMsgGCIncrementKillCountResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCIncrementKillCountResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCIncrementKillCountResponse::IsInitialized() const {
  return true;
}

void CMsgGCIncrementKillCountResponse::InternalSwap(CMsgGCIncrementKillCountResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCIncrementKillCountResponse, _impl_.level_type_)
      + sizeof(CMsgGCIncrementKillCountResponse::_impl_.level_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCIncrementKillCountResponse, _impl_.killer_account_id_)>(
          reinterpret_cast<char*>(&_impl_.killer_account_id_),
          reinterpret_cast<char*>(&other->_impl_.killer_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCIncrementKillCountResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[48]);
}

// ===================================================================

class CSOEconItemDropRateBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemDropRateBonus>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiration_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bonus_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemDropRateBonus)
}
CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(const CSOEconItemDropRateBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemDropRateBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.expiration_date_){}
    , decltype(_impl_.bonus_){}
    , decltype(_impl_.bonus_count_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.def_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.def_index_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.def_index_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemDropRateBonus)
}

inline void CSOEconItemDropRateBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.expiration_date_){0u}
    , decltype(_impl_.bonus_){0}
    , decltype(_impl_.bonus_count_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.def_index_){0u}
  };
}

CSOEconItemDropRateBonus::~CSOEconItemDropRateBonus() {
  // @@protoc_insertion_point(destructor:CSOEconItemDropRateBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemDropRateBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemDropRateBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemDropRateBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemDropRateBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.def_index_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.def_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemDropRateBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 expiration_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_expiration_date(&has_bits);
          _impl_.expiration_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional float bonus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_bonus(&has_bits);
          _impl_.bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonus_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bonus_count(&has_bits);
          _impl_.bonus_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemDropRateBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemDropRateBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional fixed32 expiration_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_expiration_date(), target);
  }

  // optional float bonus = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_bonus(), target);
  }

  // optional uint32 bonus_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bonus_count(), target);
  }

  // optional uint64 item_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_item_id(), target);
  }

  // optional uint32 def_index = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_def_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemDropRateBonus)
  return target;
}

size_t CSOEconItemDropRateBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemDropRateBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional fixed32 expiration_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float bonus = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 bonus_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_count());
    }

    // optional uint64 item_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 def_index = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemDropRateBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemDropRateBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemDropRateBonus::GetClassData() const { return &_class_data_; }


void CSOEconItemDropRateBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemDropRateBonus*>(&to_msg);
  auto& from = static_cast<const CSOEconItemDropRateBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemDropRateBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.expiration_date_ = from._impl_.expiration_date_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bonus_ = from._impl_.bonus_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bonus_count_ = from._impl_.bonus_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemDropRateBonus::CopyFrom(const CSOEconItemDropRateBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemDropRateBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemDropRateBonus::IsInitialized() const {
  return true;
}

void CSOEconItemDropRateBonus::InternalSwap(CSOEconItemDropRateBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemDropRateBonus, _impl_.def_index_)
      + sizeof(CSOEconItemDropRateBonus::_impl_.def_index_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemDropRateBonus, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemDropRateBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[49]);
}

// ===================================================================

class CSOEconItemLeagueViewPass::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemLeagueViewPass>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_admin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_itemindex(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CSOEconItemLeagueViewPass::CSOEconItemLeagueViewPass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemLeagueViewPass)
}
CSOEconItemLeagueViewPass::CSOEconItemLeagueViewPass(const CSOEconItemLeagueViewPass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemLeagueViewPass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.admin_){}
    , decltype(_impl_.itemindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.itemindex_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.itemindex_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemLeagueViewPass)
}

inline void CSOEconItemLeagueViewPass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.admin_){0u}
    , decltype(_impl_.itemindex_){0u}
  };
}

CSOEconItemLeagueViewPass::~CSOEconItemLeagueViewPass() {
  // @@protoc_insertion_point(destructor:CSOEconItemLeagueViewPass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemLeagueViewPass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemLeagueViewPass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemLeagueViewPass::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemLeagueViewPass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.itemindex_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.itemindex_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemLeagueViewPass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 2 [(.key_field) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 admin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_admin(&has_bits);
          _impl_.admin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 itemindex = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_itemindex(&has_bits);
          _impl_.itemindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemLeagueViewPass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemLeagueViewPass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 league_id = 2 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_league_id(), target);
  }

  // optional uint32 admin = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_admin(), target);
  }

  // optional uint32 itemindex = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_itemindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemLeagueViewPass)
  return target;
}

size_t CSOEconItemLeagueViewPass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemLeagueViewPass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 league_id = 2 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 admin = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_admin());
    }

    // optional uint32 itemindex = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_itemindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemLeagueViewPass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemLeagueViewPass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemLeagueViewPass::GetClassData() const { return &_class_data_; }


void CSOEconItemLeagueViewPass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemLeagueViewPass*>(&to_msg);
  auto& from = static_cast<const CSOEconItemLeagueViewPass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemLeagueViewPass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.admin_ = from._impl_.admin_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.itemindex_ = from._impl_.itemindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemLeagueViewPass::CopyFrom(const CSOEconItemLeagueViewPass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemLeagueViewPass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemLeagueViewPass::IsInitialized() const {
  return true;
}

void CSOEconItemLeagueViewPass::InternalSwap(CSOEconItemLeagueViewPass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemLeagueViewPass, _impl_.itemindex_)
      + sizeof(CSOEconItemLeagueViewPass::_impl_.itemindex_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemLeagueViewPass, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemLeagueViewPass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[50]);
}

// ===================================================================

class CSOEconItemEventTicket::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemEventTicket>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSOEconItemEventTicket::CSOEconItemEventTicket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemEventTicket)
}
CSOEconItemEventTicket::CSOEconItemEventTicket(const CSOEconItemEventTicket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemEventTicket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_id_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemEventTicket)
}

inline void CSOEconItemEventTicket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
  };
}

CSOEconItemEventTicket::~CSOEconItemEventTicket() {
  // @@protoc_insertion_point(destructor:CSOEconItemEventTicket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemEventTicket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemEventTicket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemEventTicket::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemEventTicket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemEventTicket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemEventTicket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemEventTicket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 event_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_event_id(), target);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemEventTicket)
  return target;
}

size_t CSOEconItemEventTicket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemEventTicket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 event_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemEventTicket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemEventTicket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemEventTicket::GetClassData() const { return &_class_data_; }


void CSOEconItemEventTicket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemEventTicket*>(&to_msg);
  auto& from = static_cast<const CSOEconItemEventTicket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemEventTicket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemEventTicket::CopyFrom(const CSOEconItemEventTicket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemEventTicket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemEventTicket::IsInitialized() const {
  return true;
}

void CSOEconItemEventTicket::InternalSwap(CSOEconItemEventTicket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemEventTicket, _impl_.item_id_)
      + sizeof(CSOEconItemEventTicket::_impl_.item_id_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemEventTicket, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemEventTicket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[51]);
}

// ===================================================================

class CMsgGCItemPreviewItemBoughtNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCItemPreviewItemBoughtNotification>()._impl_._has_bits_);
  static void set_has_item_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCItemPreviewItemBoughtNotification::CMsgGCItemPreviewItemBoughtNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCItemPreviewItemBoughtNotification)
}
CMsgGCItemPreviewItemBoughtNotification::CMsgGCItemPreviewItemBoughtNotification(const CMsgGCItemPreviewItemBoughtNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCItemPreviewItemBoughtNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.item_def_index_ = from._impl_.item_def_index_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCItemPreviewItemBoughtNotification)
}

inline void CMsgGCItemPreviewItemBoughtNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_index_){0u}
  };
}

CMsgGCItemPreviewItemBoughtNotification::~CMsgGCItemPreviewItemBoughtNotification() {
  // @@protoc_insertion_point(destructor:CMsgGCItemPreviewItemBoughtNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCItemPreviewItemBoughtNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCItemPreviewItemBoughtNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCItemPreviewItemBoughtNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCItemPreviewItemBoughtNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_def_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCItemPreviewItemBoughtNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_def_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def_index(&has_bits);
          _impl_.item_def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCItemPreviewItemBoughtNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCItemPreviewItemBoughtNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_def_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_def_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCItemPreviewItemBoughtNotification)
  return target;
}

size_t CMsgGCItemPreviewItemBoughtNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCItemPreviewItemBoughtNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 item_def_index = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCItemPreviewItemBoughtNotification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCItemPreviewItemBoughtNotification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCItemPreviewItemBoughtNotification::GetClassData() const { return &_class_data_; }


void CMsgGCItemPreviewItemBoughtNotification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCItemPreviewItemBoughtNotification*>(&to_msg);
  auto& from = static_cast<const CMsgGCItemPreviewItemBoughtNotification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCItemPreviewItemBoughtNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_item_def_index()) {
    _this->_internal_set_item_def_index(from._internal_item_def_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCItemPreviewItemBoughtNotification::CopyFrom(const CMsgGCItemPreviewItemBoughtNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCItemPreviewItemBoughtNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCItemPreviewItemBoughtNotification::IsInitialized() const {
  return true;
}

void CMsgGCItemPreviewItemBoughtNotification::InternalSwap(CMsgGCItemPreviewItemBoughtNotification* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.item_def_index_, other->_impl_.item_def_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCItemPreviewItemBoughtNotification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[52]);
}

// ===================================================================

class CMsgGCStorePurchaseCancel::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseCancel>()._impl_._has_bits_);
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCStorePurchaseCancel::CMsgGCStorePurchaseCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseCancel)
}
CMsgGCStorePurchaseCancel::CMsgGCStorePurchaseCancel(const CMsgGCStorePurchaseCancel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseCancel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.txn_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.txn_id_ = from._impl_.txn_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseCancel)
}

inline void CMsgGCStorePurchaseCancel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.txn_id_){uint64_t{0u}}
  };
}

CMsgGCStorePurchaseCancel::~CMsgGCStorePurchaseCancel() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseCancel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseCancel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCStorePurchaseCancel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseCancel::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseCancel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.txn_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseCancel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 txn_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_txn_id(&has_bits);
          _impl_.txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseCancel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseCancel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 txn_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_txn_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseCancel)
  return target;
}

size_t CMsgGCStorePurchaseCancel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseCancel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 txn_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseCancel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseCancel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseCancel::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseCancel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseCancel*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseCancel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseCancel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_txn_id()) {
    _this->_internal_set_txn_id(from._internal_txn_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseCancel::CopyFrom(const CMsgGCStorePurchaseCancel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseCancel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseCancel::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseCancel::InternalSwap(CMsgGCStorePurchaseCancel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.txn_id_, other->_impl_.txn_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseCancel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[53]);
}

// ===================================================================

class CMsgGCStorePurchaseCancelResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseCancelResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCStorePurchaseCancelResponse::CMsgGCStorePurchaseCancelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseCancelResponse)
}
CMsgGCStorePurchaseCancelResponse::CMsgGCStorePurchaseCancelResponse(const CMsgGCStorePurchaseCancelResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseCancelResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseCancelResponse)
}

inline void CMsgGCStorePurchaseCancelResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0u}
  };
}

CMsgGCStorePurchaseCancelResponse::~CMsgGCStorePurchaseCancelResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseCancelResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseCancelResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCStorePurchaseCancelResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseCancelResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseCancelResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseCancelResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseCancelResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseCancelResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseCancelResponse)
  return target;
}

size_t CMsgGCStorePurchaseCancelResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseCancelResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseCancelResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseCancelResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseCancelResponse::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseCancelResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseCancelResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseCancelResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseCancelResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseCancelResponse::CopyFrom(const CMsgGCStorePurchaseCancelResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseCancelResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseCancelResponse::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseCancelResponse::InternalSwap(CMsgGCStorePurchaseCancelResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseCancelResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[54]);
}

// ===================================================================

class CMsgGCStorePurchaseFinalize::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseFinalize>()._impl_._has_bits_);
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCStorePurchaseFinalize::CMsgGCStorePurchaseFinalize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseFinalize)
}
CMsgGCStorePurchaseFinalize::CMsgGCStorePurchaseFinalize(const CMsgGCStorePurchaseFinalize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseFinalize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.txn_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.txn_id_ = from._impl_.txn_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseFinalize)
}

inline void CMsgGCStorePurchaseFinalize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.txn_id_){uint64_t{0u}}
  };
}

CMsgGCStorePurchaseFinalize::~CMsgGCStorePurchaseFinalize() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseFinalize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseFinalize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCStorePurchaseFinalize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseFinalize::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseFinalize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.txn_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseFinalize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 txn_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_txn_id(&has_bits);
          _impl_.txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseFinalize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseFinalize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 txn_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_txn_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseFinalize)
  return target;
}

size_t CMsgGCStorePurchaseFinalize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseFinalize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 txn_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseFinalize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseFinalize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseFinalize::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseFinalize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseFinalize*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseFinalize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseFinalize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_txn_id()) {
    _this->_internal_set_txn_id(from._internal_txn_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseFinalize::CopyFrom(const CMsgGCStorePurchaseFinalize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseFinalize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseFinalize::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseFinalize::InternalSwap(CMsgGCStorePurchaseFinalize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.txn_id_, other->_impl_.txn_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseFinalize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[55]);
}

// ===================================================================

class CMsgGCStorePurchaseFinalizeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCStorePurchaseFinalizeResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCStorePurchaseFinalizeResponse::CMsgGCStorePurchaseFinalizeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCStorePurchaseFinalizeResponse)
}
CMsgGCStorePurchaseFinalizeResponse::CMsgGCStorePurchaseFinalizeResponse(const CMsgGCStorePurchaseFinalizeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCStorePurchaseFinalizeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_ids_){from._impl_.item_ids_}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCStorePurchaseFinalizeResponse)
}

inline void CMsgGCStorePurchaseFinalizeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_ids_){arena}
    , decltype(_impl_.result_){0u}
  };
}

CMsgGCStorePurchaseFinalizeResponse::~CMsgGCStorePurchaseFinalizeResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCStorePurchaseFinalizeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCStorePurchaseFinalizeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_ids_.~RepeatedField();
}

void CMsgGCStorePurchaseFinalizeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCStorePurchaseFinalizeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCStorePurchaseFinalizeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_ids_.Clear();
  _impl_.result_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCStorePurchaseFinalizeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 item_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCStorePurchaseFinalizeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCStorePurchaseFinalizeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_result(), target);
  }

  // repeated uint64 item_ids = 2;
  for (int i = 0, n = this->_internal_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCStorePurchaseFinalizeResponse)
  return target;
}

size_t CMsgGCStorePurchaseFinalizeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCStorePurchaseFinalizeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 item_ids = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_item_ids_size());
    total_size += data_size;
  }

  // optional uint32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCStorePurchaseFinalizeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCStorePurchaseFinalizeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCStorePurchaseFinalizeResponse::GetClassData() const { return &_class_data_; }


void CMsgGCStorePurchaseFinalizeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCStorePurchaseFinalizeResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCStorePurchaseFinalizeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCStorePurchaseFinalizeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_ids_.MergeFrom(from._impl_.item_ids_);
  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCStorePurchaseFinalizeResponse::CopyFrom(const CMsgGCStorePurchaseFinalizeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCStorePurchaseFinalizeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCStorePurchaseFinalizeResponse::IsInitialized() const {
  return true;
}

void CMsgGCStorePurchaseFinalizeResponse::InternalSwap(CMsgGCStorePurchaseFinalizeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.item_ids_.InternalSwap(&other->_impl_.item_ids_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCStorePurchaseFinalizeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[56]);
}

// ===================================================================

class CMsgGCBannedWordListRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCBannedWordListRequest>()._impl_._has_bits_);
  static void set_has_ban_list_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_word_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCBannedWordListRequest::CMsgGCBannedWordListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCBannedWordListRequest)
}
CMsgGCBannedWordListRequest::CMsgGCBannedWordListRequest(const CMsgGCBannedWordListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCBannedWordListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ban_list_group_id_){}
    , decltype(_impl_.word_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ban_list_group_id_, &from._impl_.ban_list_group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.word_id_) -
    reinterpret_cast<char*>(&_impl_.ban_list_group_id_)) + sizeof(_impl_.word_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCBannedWordListRequest)
}

inline void CMsgGCBannedWordListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ban_list_group_id_){0u}
    , decltype(_impl_.word_id_){0u}
  };
}

CMsgGCBannedWordListRequest::~CMsgGCBannedWordListRequest() {
  // @@protoc_insertion_point(destructor:CMsgGCBannedWordListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCBannedWordListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCBannedWordListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCBannedWordListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCBannedWordListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ban_list_group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.word_id_) -
        reinterpret_cast<char*>(&_impl_.ban_list_group_id_)) + sizeof(_impl_.word_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCBannedWordListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ban_list_group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ban_list_group_id(&has_bits);
          _impl_.ban_list_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 word_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_word_id(&has_bits);
          _impl_.word_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCBannedWordListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCBannedWordListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ban_list_group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ban_list_group_id(), target);
  }

  // optional uint32 word_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_word_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCBannedWordListRequest)
  return target;
}

size_t CMsgGCBannedWordListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCBannedWordListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ban_list_group_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ban_list_group_id());
    }

    // optional uint32 word_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_word_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCBannedWordListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCBannedWordListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCBannedWordListRequest::GetClassData() const { return &_class_data_; }


void CMsgGCBannedWordListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCBannedWordListRequest*>(&to_msg);
  auto& from = static_cast<const CMsgGCBannedWordListRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCBannedWordListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ban_list_group_id_ = from._impl_.ban_list_group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.word_id_ = from._impl_.word_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCBannedWordListRequest::CopyFrom(const CMsgGCBannedWordListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCBannedWordListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCBannedWordListRequest::IsInitialized() const {
  return true;
}

void CMsgGCBannedWordListRequest::InternalSwap(CMsgGCBannedWordListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCBannedWordListRequest, _impl_.word_id_)
      + sizeof(CMsgGCBannedWordListRequest::_impl_.word_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCBannedWordListRequest, _impl_.ban_list_group_id_)>(
          reinterpret_cast<char*>(&_impl_.ban_list_group_id_),
          reinterpret_cast<char*>(&other->_impl_.ban_list_group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCBannedWordListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[57]);
}

// ===================================================================

class CMsgGCRequestAnnouncements::_Internal {
 public:
};

CMsgGCRequestAnnouncements::CMsgGCRequestAnnouncements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestAnnouncements)
}
CMsgGCRequestAnnouncements::CMsgGCRequestAnnouncements(const CMsgGCRequestAnnouncements& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCRequestAnnouncements* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestAnnouncements)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRequestAnnouncements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRequestAnnouncements::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRequestAnnouncements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[58]);
}

// ===================================================================

class CMsgGCRequestAnnouncementsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRequestAnnouncementsResponse>()._impl_._has_bits_);
  static void set_has_announcement_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_announcement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nextmatch_title(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nextmatch(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCRequestAnnouncementsResponse::CMsgGCRequestAnnouncementsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestAnnouncementsResponse)
}
CMsgGCRequestAnnouncementsResponse::CMsgGCRequestAnnouncementsResponse(const CMsgGCRequestAnnouncementsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCRequestAnnouncementsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announcement_title_){}
    , decltype(_impl_.announcement_){}
    , decltype(_impl_.nextmatch_title_){}
    , decltype(_impl_.nextmatch_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.announcement_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.announcement_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_announcement_title()) {
    _this->_impl_.announcement_title_.Set(from._internal_announcement_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.announcement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.announcement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_announcement()) {
    _this->_impl_.announcement_.Set(from._internal_announcement(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nextmatch_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextmatch_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextmatch_title()) {
    _this->_impl_.nextmatch_title_.Set(from._internal_nextmatch_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nextmatch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextmatch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextmatch()) {
    _this->_impl_.nextmatch_.Set(from._internal_nextmatch(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestAnnouncementsResponse)
}

inline void CMsgGCRequestAnnouncementsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announcement_title_){}
    , decltype(_impl_.announcement_){}
    , decltype(_impl_.nextmatch_title_){}
    , decltype(_impl_.nextmatch_){}
  };
  _impl_.announcement_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.announcement_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.announcement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.announcement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nextmatch_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextmatch_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nextmatch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextmatch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCRequestAnnouncementsResponse::~CMsgGCRequestAnnouncementsResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCRequestAnnouncementsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRequestAnnouncementsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.announcement_title_.Destroy();
  _impl_.announcement_.Destroy();
  _impl_.nextmatch_title_.Destroy();
  _impl_.nextmatch_.Destroy();
}

void CMsgGCRequestAnnouncementsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRequestAnnouncementsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRequestAnnouncementsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.announcement_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.announcement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.nextmatch_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.nextmatch_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCRequestAnnouncementsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string announcement_title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_announcement_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCRequestAnnouncementsResponse.announcement_title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string announcement = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_announcement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCRequestAnnouncementsResponse.announcement");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string nextmatch_title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nextmatch_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCRequestAnnouncementsResponse.nextmatch_title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string nextmatch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nextmatch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCRequestAnnouncementsResponse.nextmatch");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRequestAnnouncementsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRequestAnnouncementsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string announcement_title = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_announcement_title().data(), static_cast<int>(this->_internal_announcement_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCRequestAnnouncementsResponse.announcement_title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_announcement_title(), target);
  }

  // optional string announcement = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_announcement().data(), static_cast<int>(this->_internal_announcement().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCRequestAnnouncementsResponse.announcement");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_announcement(), target);
  }

  // optional string nextmatch_title = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nextmatch_title().data(), static_cast<int>(this->_internal_nextmatch_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCRequestAnnouncementsResponse.nextmatch_title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nextmatch_title(), target);
  }

  // optional string nextmatch = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nextmatch().data(), static_cast<int>(this->_internal_nextmatch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCRequestAnnouncementsResponse.nextmatch");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nextmatch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRequestAnnouncementsResponse)
  return target;
}

size_t CMsgGCRequestAnnouncementsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRequestAnnouncementsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string announcement_title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_announcement_title());
    }

    // optional string announcement = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_announcement());
    }

    // optional string nextmatch_title = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nextmatch_title());
    }

    // optional string nextmatch = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nextmatch());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRequestAnnouncementsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCRequestAnnouncementsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRequestAnnouncementsResponse::GetClassData() const { return &_class_data_; }


void CMsgGCRequestAnnouncementsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCRequestAnnouncementsResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCRequestAnnouncementsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRequestAnnouncementsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_announcement_title(from._internal_announcement_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_announcement(from._internal_announcement());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_nextmatch_title(from._internal_nextmatch_title());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_nextmatch(from._internal_nextmatch());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCRequestAnnouncementsResponse::CopyFrom(const CMsgGCRequestAnnouncementsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRequestAnnouncementsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRequestAnnouncementsResponse::IsInitialized() const {
  return true;
}

void CMsgGCRequestAnnouncementsResponse::InternalSwap(CMsgGCRequestAnnouncementsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.announcement_title_, lhs_arena,
      &other->_impl_.announcement_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.announcement_, lhs_arena,
      &other->_impl_.announcement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nextmatch_title_, lhs_arena,
      &other->_impl_.nextmatch_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nextmatch_, lhs_arena,
      &other->_impl_.nextmatch_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRequestAnnouncementsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[59]);
}

// ===================================================================

class CMsgGCBannedWord::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCBannedWord>()._impl_._has_bits_);
  static void set_has_word_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_word_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_word(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCBannedWord::CMsgGCBannedWord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCBannedWord)
}
CMsgGCBannedWord::CMsgGCBannedWord(const CMsgGCBannedWord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCBannedWord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_){}
    , decltype(_impl_.word_id_){}
    , decltype(_impl_.word_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_word()) {
    _this->_impl_.word_.Set(from._internal_word(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.word_id_, &from._impl_.word_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.word_type_) -
    reinterpret_cast<char*>(&_impl_.word_id_)) + sizeof(_impl_.word_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCBannedWord)
}

inline void CMsgGCBannedWord::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_){}
    , decltype(_impl_.word_id_){0u}
    , decltype(_impl_.word_type_){0}
  };
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCBannedWord::~CMsgGCBannedWord() {
  // @@protoc_insertion_point(destructor:CMsgGCBannedWord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCBannedWord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.word_.Destroy();
}

void CMsgGCBannedWord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCBannedWord::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCBannedWord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.word_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.word_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.word_type_) -
        reinterpret_cast<char*>(&_impl_.word_id_)) + sizeof(_impl_.word_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCBannedWord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 word_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_word_id(&has_bits);
          _impl_.word_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GC_BannedWordType word_type = 2 [default = GC_BANNED_WORD_DISABLE_WORD];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GC_BannedWordType_IsValid(val))) {
            _internal_set_word_type(static_cast<::GC_BannedWordType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string word = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_word();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCBannedWord.word");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCBannedWord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCBannedWord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 word_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_word_id(), target);
  }

  // optional .GC_BannedWordType word_type = 2 [default = GC_BANNED_WORD_DISABLE_WORD];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_word_type(), target);
  }

  // optional string word = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_word().data(), static_cast<int>(this->_internal_word().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCBannedWord.word");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_word(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCBannedWord)
  return target;
}

size_t CMsgGCBannedWord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCBannedWord)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string word = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_word());
    }

    // optional uint32 word_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_word_id());
    }

    // optional .GC_BannedWordType word_type = 2 [default = GC_BANNED_WORD_DISABLE_WORD];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_word_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCBannedWord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCBannedWord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCBannedWord::GetClassData() const { return &_class_data_; }


void CMsgGCBannedWord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCBannedWord*>(&to_msg);
  auto& from = static_cast<const CMsgGCBannedWord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCBannedWord)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_word(from._internal_word());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.word_id_ = from._impl_.word_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.word_type_ = from._impl_.word_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCBannedWord::CopyFrom(const CMsgGCBannedWord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCBannedWord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCBannedWord::IsInitialized() const {
  return true;
}

void CMsgGCBannedWord::InternalSwap(CMsgGCBannedWord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.word_, lhs_arena,
      &other->_impl_.word_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCBannedWord, _impl_.word_type_)
      + sizeof(CMsgGCBannedWord::_impl_.word_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCBannedWord, _impl_.word_id_)>(
          reinterpret_cast<char*>(&_impl_.word_id_),
          reinterpret_cast<char*>(&other->_impl_.word_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCBannedWord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[60]);
}

// ===================================================================

class CMsgGCBannedWordListResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCBannedWordListResponse>()._impl_._has_bits_);
  static void set_has_ban_list_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCBannedWordListResponse::CMsgGCBannedWordListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCBannedWordListResponse)
}
CMsgGCBannedWordListResponse::CMsgGCBannedWordListResponse(const CMsgGCBannedWordListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCBannedWordListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_list_){from._impl_.word_list_}
    , decltype(_impl_.ban_list_group_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ban_list_group_id_ = from._impl_.ban_list_group_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCBannedWordListResponse)
}

inline void CMsgGCBannedWordListResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_list_){arena}
    , decltype(_impl_.ban_list_group_id_){0u}
  };
}

CMsgGCBannedWordListResponse::~CMsgGCBannedWordListResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCBannedWordListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCBannedWordListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.word_list_.~RepeatedPtrField();
}

void CMsgGCBannedWordListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCBannedWordListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCBannedWordListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.word_list_.Clear();
  _impl_.ban_list_group_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCBannedWordListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ban_list_group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ban_list_group_id(&has_bits);
          _impl_.ban_list_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCBannedWord word_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_word_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCBannedWordListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCBannedWordListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ban_list_group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ban_list_group_id(), target);
  }

  // repeated .CMsgGCBannedWord word_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_word_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_word_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCBannedWordListResponse)
  return target;
}

size_t CMsgGCBannedWordListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCBannedWordListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCBannedWord word_list = 2;
  total_size += 1UL * this->_internal_word_list_size();
  for (const auto& msg : this->_impl_.word_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 ban_list_group_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ban_list_group_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCBannedWordListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCBannedWordListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCBannedWordListResponse::GetClassData() const { return &_class_data_; }


void CMsgGCBannedWordListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCBannedWordListResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCBannedWordListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCBannedWordListResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.word_list_.MergeFrom(from._impl_.word_list_);
  if (from._internal_has_ban_list_group_id()) {
    _this->_internal_set_ban_list_group_id(from._internal_ban_list_group_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCBannedWordListResponse::CopyFrom(const CMsgGCBannedWordListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCBannedWordListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCBannedWordListResponse::IsInitialized() const {
  return true;
}

void CMsgGCBannedWordListResponse::InternalSwap(CMsgGCBannedWordListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.word_list_.InternalSwap(&other->_impl_.word_list_);
  swap(_impl_.ban_list_group_id_, other->_impl_.ban_list_group_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCBannedWordListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[61]);
}

// ===================================================================

class CMsgGCToGCBannedWordListBroadcast::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCBannedWordListBroadcast>()._impl_._has_bits_);
  static const ::CMsgGCBannedWordListResponse& broadcast(const CMsgGCToGCBannedWordListBroadcast* msg);
  static void set_has_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgGCBannedWordListResponse&
CMsgGCToGCBannedWordListBroadcast::_Internal::broadcast(const CMsgGCToGCBannedWordListBroadcast* msg) {
  return *msg->_impl_.broadcast_;
}
CMsgGCToGCBannedWordListBroadcast::CMsgGCToGCBannedWordListBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCBannedWordListBroadcast)
}
CMsgGCToGCBannedWordListBroadcast::CMsgGCToGCBannedWordListBroadcast(const CMsgGCToGCBannedWordListBroadcast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCBannedWordListBroadcast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.broadcast_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_broadcast()) {
    _this->_impl_.broadcast_ = new ::CMsgGCBannedWordListResponse(*from._impl_.broadcast_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCBannedWordListBroadcast)
}

inline void CMsgGCToGCBannedWordListBroadcast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.broadcast_){nullptr}
  };
}

CMsgGCToGCBannedWordListBroadcast::~CMsgGCToGCBannedWordListBroadcast() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCBannedWordListBroadcast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCBannedWordListBroadcast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.broadcast_;
}

void CMsgGCToGCBannedWordListBroadcast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCBannedWordListBroadcast::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCBannedWordListBroadcast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.broadcast_ != nullptr);
    _impl_.broadcast_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCBannedWordListBroadcast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgGCBannedWordListResponse broadcast = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_broadcast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCBannedWordListBroadcast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCBannedWordListBroadcast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgGCBannedWordListResponse broadcast = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::broadcast(this),
        _Internal::broadcast(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCBannedWordListBroadcast)
  return target;
}

size_t CMsgGCToGCBannedWordListBroadcast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCBannedWordListBroadcast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgGCBannedWordListResponse broadcast = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.broadcast_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCBannedWordListBroadcast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCBannedWordListBroadcast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCBannedWordListBroadcast::GetClassData() const { return &_class_data_; }


void CMsgGCToGCBannedWordListBroadcast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCBannedWordListBroadcast*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCBannedWordListBroadcast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCBannedWordListBroadcast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_broadcast()) {
    _this->_internal_mutable_broadcast()->::CMsgGCBannedWordListResponse::MergeFrom(
        from._internal_broadcast());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCBannedWordListBroadcast::CopyFrom(const CMsgGCToGCBannedWordListBroadcast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCBannedWordListBroadcast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCBannedWordListBroadcast::IsInitialized() const {
  return true;
}

void CMsgGCToGCBannedWordListBroadcast::InternalSwap(CMsgGCToGCBannedWordListBroadcast* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.broadcast_, other->_impl_.broadcast_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCBannedWordListBroadcast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[62]);
}

// ===================================================================

class CMsgGCToGCBannedWordListUpdated::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCBannedWordListUpdated>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCBannedWordListUpdated::CMsgGCToGCBannedWordListUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCBannedWordListUpdated)
}
CMsgGCToGCBannedWordListUpdated::CMsgGCToGCBannedWordListUpdated(const CMsgGCToGCBannedWordListUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCBannedWordListUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.group_id_ = from._impl_.group_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCBannedWordListUpdated)
}

inline void CMsgGCToGCBannedWordListUpdated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){0u}
  };
}

CMsgGCToGCBannedWordListUpdated::~CMsgGCToGCBannedWordListUpdated() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCBannedWordListUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCBannedWordListUpdated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCBannedWordListUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCBannedWordListUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCBannedWordListUpdated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCBannedWordListUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCBannedWordListUpdated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCBannedWordListUpdated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCBannedWordListUpdated)
  return target;
}

size_t CMsgGCToGCBannedWordListUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCBannedWordListUpdated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 group_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCBannedWordListUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCBannedWordListUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCBannedWordListUpdated::GetClassData() const { return &_class_data_; }


void CMsgGCToGCBannedWordListUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCBannedWordListUpdated*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCBannedWordListUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCBannedWordListUpdated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_group_id()) {
    _this->_internal_set_group_id(from._internal_group_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCBannedWordListUpdated::CopyFrom(const CMsgGCToGCBannedWordListUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCBannedWordListUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCBannedWordListUpdated::IsInitialized() const {
  return true;
}

void CMsgGCToGCBannedWordListUpdated::InternalSwap(CMsgGCToGCBannedWordListUpdated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.group_id_, other->_impl_.group_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCBannedWordListUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[63]);
}

// ===================================================================

class CMsgGCToGCDirtySDOCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCDirtySDOCache>()._impl_._has_bits_);
  static void set_has_sdo_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_uint64(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCDirtySDOCache::CMsgGCToGCDirtySDOCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCDirtySDOCache)
}
CMsgGCToGCDirtySDOCache::CMsgGCToGCDirtySDOCache(const CMsgGCToGCDirtySDOCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCDirtySDOCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_uint64_){}
    , decltype(_impl_.sdo_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.key_uint64_, &from._impl_.key_uint64_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sdo_type_) -
    reinterpret_cast<char*>(&_impl_.key_uint64_)) + sizeof(_impl_.sdo_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCDirtySDOCache)
}

inline void CMsgGCToGCDirtySDOCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_uint64_){uint64_t{0u}}
    , decltype(_impl_.sdo_type_){0u}
  };
}

CMsgGCToGCDirtySDOCache::~CMsgGCToGCDirtySDOCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCDirtySDOCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCDirtySDOCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCDirtySDOCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCDirtySDOCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCDirtySDOCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.key_uint64_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sdo_type_) -
        reinterpret_cast<char*>(&_impl_.key_uint64_)) + sizeof(_impl_.sdo_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCDirtySDOCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sdo_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sdo_type(&has_bits);
          _impl_.sdo_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 key_uint64 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_key_uint64(&has_bits);
          _impl_.key_uint64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCDirtySDOCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCDirtySDOCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 sdo_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sdo_type(), target);
  }

  // optional uint64 key_uint64 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_key_uint64(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCDirtySDOCache)
  return target;
}

size_t CMsgGCToGCDirtySDOCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCDirtySDOCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 key_uint64 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_key_uint64());
    }

    // optional uint32 sdo_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sdo_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCDirtySDOCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCDirtySDOCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCDirtySDOCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCDirtySDOCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCDirtySDOCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCDirtySDOCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCDirtySDOCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.key_uint64_ = from._impl_.key_uint64_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sdo_type_ = from._impl_.sdo_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCDirtySDOCache::CopyFrom(const CMsgGCToGCDirtySDOCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCDirtySDOCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCDirtySDOCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCDirtySDOCache::InternalSwap(CMsgGCToGCDirtySDOCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCDirtySDOCache, _impl_.sdo_type_)
      + sizeof(CMsgGCToGCDirtySDOCache::_impl_.sdo_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCDirtySDOCache, _impl_.key_uint64_)>(
          reinterpret_cast<char*>(&_impl_.key_uint64_),
          reinterpret_cast<char*>(&other->_impl_.key_uint64_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCDirtySDOCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[64]);
}

// ===================================================================

class CMsgGCToGCDirtyMultipleSDOCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCDirtyMultipleSDOCache>()._impl_._has_bits_);
  static void set_has_sdo_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCDirtyMultipleSDOCache::CMsgGCToGCDirtyMultipleSDOCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCDirtyMultipleSDOCache)
}
CMsgGCToGCDirtyMultipleSDOCache::CMsgGCToGCDirtyMultipleSDOCache(const CMsgGCToGCDirtyMultipleSDOCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCDirtyMultipleSDOCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_uint64_){from._impl_.key_uint64_}
    , decltype(_impl_.sdo_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sdo_type_ = from._impl_.sdo_type_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCDirtyMultipleSDOCache)
}

inline void CMsgGCToGCDirtyMultipleSDOCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_uint64_){arena}
    , decltype(_impl_.sdo_type_){0u}
  };
}

CMsgGCToGCDirtyMultipleSDOCache::~CMsgGCToGCDirtyMultipleSDOCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCDirtyMultipleSDOCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCDirtyMultipleSDOCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_uint64_.~RepeatedField();
}

void CMsgGCToGCDirtyMultipleSDOCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCDirtyMultipleSDOCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCDirtyMultipleSDOCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_uint64_.Clear();
  _impl_.sdo_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCDirtyMultipleSDOCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sdo_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sdo_type(&has_bits);
          _impl_.sdo_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 key_uint64 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_key_uint64(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_key_uint64(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCDirtyMultipleSDOCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCDirtyMultipleSDOCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 sdo_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sdo_type(), target);
  }

  // repeated uint64 key_uint64 = 2;
  for (int i = 0, n = this->_internal_key_uint64_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_key_uint64(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCDirtyMultipleSDOCache)
  return target;
}

size_t CMsgGCToGCDirtyMultipleSDOCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCDirtyMultipleSDOCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 key_uint64 = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.key_uint64_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_key_uint64_size());
    total_size += data_size;
  }

  // optional uint32 sdo_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sdo_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCDirtyMultipleSDOCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCDirtyMultipleSDOCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCDirtyMultipleSDOCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCDirtyMultipleSDOCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCDirtyMultipleSDOCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCDirtyMultipleSDOCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCDirtyMultipleSDOCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.key_uint64_.MergeFrom(from._impl_.key_uint64_);
  if (from._internal_has_sdo_type()) {
    _this->_internal_set_sdo_type(from._internal_sdo_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCDirtyMultipleSDOCache::CopyFrom(const CMsgGCToGCDirtyMultipleSDOCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCDirtyMultipleSDOCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCDirtyMultipleSDOCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCDirtyMultipleSDOCache::InternalSwap(CMsgGCToGCDirtyMultipleSDOCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.key_uint64_.InternalSwap(&other->_impl_.key_uint64_);
  swap(_impl_.sdo_type_, other->_impl_.sdo_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCDirtyMultipleSDOCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[65]);
}

// ===================================================================

class CMsgGCCollectItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCCollectItem>()._impl_._has_bits_);
  static void set_has_collection_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subject_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCCollectItem::CMsgGCCollectItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCCollectItem)
}
CMsgGCCollectItem::CMsgGCCollectItem(const CMsgGCCollectItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCCollectItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.collection_item_id_){}
    , decltype(_impl_.subject_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.collection_item_id_, &from._impl_.collection_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subject_item_id_) -
    reinterpret_cast<char*>(&_impl_.collection_item_id_)) + sizeof(_impl_.subject_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCCollectItem)
}

inline void CMsgGCCollectItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.collection_item_id_){uint64_t{0u}}
    , decltype(_impl_.subject_item_id_){uint64_t{0u}}
  };
}

CMsgGCCollectItem::~CMsgGCCollectItem() {
  // @@protoc_insertion_point(destructor:CMsgGCCollectItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCCollectItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCCollectItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCCollectItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCCollectItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.collection_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.subject_item_id_) -
        reinterpret_cast<char*>(&_impl_.collection_item_id_)) + sizeof(_impl_.subject_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCCollectItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 collection_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_collection_item_id(&has_bits);
          _impl_.collection_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 subject_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_subject_item_id(&has_bits);
          _impl_.subject_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCCollectItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCCollectItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 collection_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_collection_item_id(), target);
  }

  // optional uint64 subject_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_subject_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCCollectItem)
  return target;
}

size_t CMsgGCCollectItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCCollectItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 collection_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_collection_item_id());
    }

    // optional uint64 subject_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_subject_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCCollectItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCCollectItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCCollectItem::GetClassData() const { return &_class_data_; }


void CMsgGCCollectItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCCollectItem*>(&to_msg);
  auto& from = static_cast<const CMsgGCCollectItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCCollectItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.collection_item_id_ = from._impl_.collection_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.subject_item_id_ = from._impl_.subject_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCCollectItem::CopyFrom(const CMsgGCCollectItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCCollectItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCCollectItem::IsInitialized() const {
  return true;
}

void CMsgGCCollectItem::InternalSwap(CMsgGCCollectItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCCollectItem, _impl_.subject_item_id_)
      + sizeof(CMsgGCCollectItem::_impl_.subject_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCCollectItem, _impl_.collection_item_id_)>(
          reinterpret_cast<char*>(&_impl_.collection_item_id_),
          reinterpret_cast<char*>(&other->_impl_.collection_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCCollectItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[66]);
}

// ===================================================================

class CMsgSDONoMemcached::_Internal {
 public:
};

CMsgSDONoMemcached::CMsgSDONoMemcached(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgSDONoMemcached)
}
CMsgSDONoMemcached::CMsgSDONoMemcached(const CMsgSDONoMemcached& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgSDONoMemcached* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgSDONoMemcached)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSDONoMemcached::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSDONoMemcached::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgSDONoMemcached::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[67]);
}

// ===================================================================

class CMsgGCToGCUpdateSQLKeyValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCUpdateSQLKeyValue>()._impl_._has_bits_);
  static void set_has_key_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCUpdateSQLKeyValue::CMsgGCToGCUpdateSQLKeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCUpdateSQLKeyValue)
}
CMsgGCToGCUpdateSQLKeyValue::CMsgGCToGCUpdateSQLKeyValue(const CMsgGCToGCUpdateSQLKeyValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCUpdateSQLKeyValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_name()) {
    _this->_impl_.key_name_.Set(from._internal_key_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCUpdateSQLKeyValue)
}

inline void CMsgGCToGCUpdateSQLKeyValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_name_){}
  };
  _impl_.key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCToGCUpdateSQLKeyValue::~CMsgGCToGCUpdateSQLKeyValue() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCUpdateSQLKeyValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCUpdateSQLKeyValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_name_.Destroy();
}

void CMsgGCToGCUpdateSQLKeyValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCUpdateSQLKeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCUpdateSQLKeyValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.key_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCUpdateSQLKeyValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCToGCUpdateSQLKeyValue.key_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCUpdateSQLKeyValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCUpdateSQLKeyValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string key_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_name().data(), static_cast<int>(this->_internal_key_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCToGCUpdateSQLKeyValue.key_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCUpdateSQLKeyValue)
  return target;
}

size_t CMsgGCToGCUpdateSQLKeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCUpdateSQLKeyValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string key_name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCUpdateSQLKeyValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCUpdateSQLKeyValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCUpdateSQLKeyValue::GetClassData() const { return &_class_data_; }


void CMsgGCToGCUpdateSQLKeyValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCUpdateSQLKeyValue*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCUpdateSQLKeyValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCUpdateSQLKeyValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key_name()) {
    _this->_internal_set_key_name(from._internal_key_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCUpdateSQLKeyValue::CopyFrom(const CMsgGCToGCUpdateSQLKeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCUpdateSQLKeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCUpdateSQLKeyValue::IsInitialized() const {
  return true;
}

void CMsgGCToGCUpdateSQLKeyValue::InternalSwap(CMsgGCToGCUpdateSQLKeyValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_name_, lhs_arena,
      &other->_impl_.key_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCUpdateSQLKeyValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[68]);
}

// ===================================================================

class CMsgGCToGCIsTrustedServer::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCIsTrustedServer>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCIsTrustedServer::CMsgGCToGCIsTrustedServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCIsTrustedServer)
}
CMsgGCToGCIsTrustedServer::CMsgGCToGCIsTrustedServer(const CMsgGCToGCIsTrustedServer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCIsTrustedServer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.steam_id_ = from._impl_.steam_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCIsTrustedServer)
}

inline void CMsgGCToGCIsTrustedServer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
  };
}

CMsgGCToGCIsTrustedServer::~CMsgGCToGCIsTrustedServer() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCIsTrustedServer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCIsTrustedServer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCIsTrustedServer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCIsTrustedServer::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCIsTrustedServer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCIsTrustedServer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCIsTrustedServer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCIsTrustedServer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCIsTrustedServer)
  return target;
}

size_t CMsgGCToGCIsTrustedServer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCIsTrustedServer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steam_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCIsTrustedServer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCIsTrustedServer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCIsTrustedServer::GetClassData() const { return &_class_data_; }


void CMsgGCToGCIsTrustedServer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCIsTrustedServer*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCIsTrustedServer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCIsTrustedServer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steam_id()) {
    _this->_internal_set_steam_id(from._internal_steam_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCIsTrustedServer::CopyFrom(const CMsgGCToGCIsTrustedServer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCIsTrustedServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCIsTrustedServer::IsInitialized() const {
  return true;
}

void CMsgGCToGCIsTrustedServer::InternalSwap(CMsgGCToGCIsTrustedServer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steam_id_, other->_impl_.steam_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCIsTrustedServer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[69]);
}

// ===================================================================

class CMsgGCToGCIsTrustedServerResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCIsTrustedServerResponse>()._impl_._has_bits_);
  static void set_has_is_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCIsTrustedServerResponse::CMsgGCToGCIsTrustedServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCIsTrustedServerResponse)
}
CMsgGCToGCIsTrustedServerResponse::CMsgGCToGCIsTrustedServerResponse(const CMsgGCToGCIsTrustedServerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCIsTrustedServerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_trusted_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.is_trusted_ = from._impl_.is_trusted_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCIsTrustedServerResponse)
}

inline void CMsgGCToGCIsTrustedServerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_trusted_){false}
  };
}

CMsgGCToGCIsTrustedServerResponse::~CMsgGCToGCIsTrustedServerResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCIsTrustedServerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCIsTrustedServerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCIsTrustedServerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCIsTrustedServerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCIsTrustedServerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.is_trusted_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCIsTrustedServerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_trusted = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_trusted(&has_bits);
          _impl_.is_trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCIsTrustedServerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCIsTrustedServerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_trusted = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_trusted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCIsTrustedServerResponse)
  return target;
}

size_t CMsgGCToGCIsTrustedServerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCIsTrustedServerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_trusted = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCIsTrustedServerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCIsTrustedServerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCIsTrustedServerResponse::GetClassData() const { return &_class_data_; }


void CMsgGCToGCIsTrustedServerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCIsTrustedServerResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCIsTrustedServerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCIsTrustedServerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_trusted()) {
    _this->_internal_set_is_trusted(from._internal_is_trusted());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCIsTrustedServerResponse::CopyFrom(const CMsgGCToGCIsTrustedServerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCIsTrustedServerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCIsTrustedServerResponse::IsInitialized() const {
  return true;
}

void CMsgGCToGCIsTrustedServerResponse::InternalSwap(CMsgGCToGCIsTrustedServerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.is_trusted_, other->_impl_.is_trusted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCIsTrustedServerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[70]);
}

// ===================================================================

class CMsgGCToGCBroadcastConsoleCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCBroadcastConsoleCommand>()._impl_._has_bits_);
  static void set_has_con_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCBroadcastConsoleCommand::CMsgGCToGCBroadcastConsoleCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCBroadcastConsoleCommand)
}
CMsgGCToGCBroadcastConsoleCommand::CMsgGCToGCBroadcastConsoleCommand(const CMsgGCToGCBroadcastConsoleCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCBroadcastConsoleCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.con_command_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.con_command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.con_command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_con_command()) {
    _this->_impl_.con_command_.Set(from._internal_con_command(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCBroadcastConsoleCommand)
}

inline void CMsgGCToGCBroadcastConsoleCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.con_command_){}
  };
  _impl_.con_command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.con_command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCToGCBroadcastConsoleCommand::~CMsgGCToGCBroadcastConsoleCommand() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCBroadcastConsoleCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCBroadcastConsoleCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.con_command_.Destroy();
}

void CMsgGCToGCBroadcastConsoleCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCBroadcastConsoleCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCBroadcastConsoleCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.con_command_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCBroadcastConsoleCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string con_command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_con_command();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCToGCBroadcastConsoleCommand.con_command");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCBroadcastConsoleCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCBroadcastConsoleCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string con_command = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_con_command().data(), static_cast<int>(this->_internal_con_command().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCToGCBroadcastConsoleCommand.con_command");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_con_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCBroadcastConsoleCommand)
  return target;
}

size_t CMsgGCToGCBroadcastConsoleCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCBroadcastConsoleCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string con_command = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_con_command());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCBroadcastConsoleCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCBroadcastConsoleCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCBroadcastConsoleCommand::GetClassData() const { return &_class_data_; }


void CMsgGCToGCBroadcastConsoleCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCBroadcastConsoleCommand*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCBroadcastConsoleCommand&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCBroadcastConsoleCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_con_command()) {
    _this->_internal_set_con_command(from._internal_con_command());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCBroadcastConsoleCommand::CopyFrom(const CMsgGCToGCBroadcastConsoleCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCBroadcastConsoleCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCBroadcastConsoleCommand::IsInitialized() const {
  return true;
}

void CMsgGCToGCBroadcastConsoleCommand::InternalSwap(CMsgGCToGCBroadcastConsoleCommand* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.con_command_, lhs_arena,
      &other->_impl_.con_command_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCBroadcastConsoleCommand::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[71]);
}

// ===================================================================

class CMsgGCServerVersionUpdated::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCServerVersionUpdated>()._impl_._has_bits_);
  static void set_has_server_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCServerVersionUpdated::CMsgGCServerVersionUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCServerVersionUpdated)
}
CMsgGCServerVersionUpdated::CMsgGCServerVersionUpdated(const CMsgGCServerVersionUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCServerVersionUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.server_version_ = from._impl_.server_version_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCServerVersionUpdated)
}

inline void CMsgGCServerVersionUpdated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_version_){0u}
  };
}

CMsgGCServerVersionUpdated::~CMsgGCServerVersionUpdated() {
  // @@protoc_insertion_point(destructor:CMsgGCServerVersionUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCServerVersionUpdated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCServerVersionUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCServerVersionUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCServerVersionUpdated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.server_version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCServerVersionUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 server_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_server_version(&has_bits);
          _impl_.server_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCServerVersionUpdated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCServerVersionUpdated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 server_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_server_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCServerVersionUpdated)
  return target;
}

size_t CMsgGCServerVersionUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCServerVersionUpdated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 server_version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCServerVersionUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCServerVersionUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCServerVersionUpdated::GetClassData() const { return &_class_data_; }


void CMsgGCServerVersionUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCServerVersionUpdated*>(&to_msg);
  auto& from = static_cast<const CMsgGCServerVersionUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCServerVersionUpdated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server_version()) {
    _this->_internal_set_server_version(from._internal_server_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCServerVersionUpdated::CopyFrom(const CMsgGCServerVersionUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCServerVersionUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCServerVersionUpdated::IsInitialized() const {
  return true;
}

void CMsgGCServerVersionUpdated::InternalSwap(CMsgGCServerVersionUpdated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.server_version_, other->_impl_.server_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCServerVersionUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[72]);
}

// ===================================================================

class CMsgGCClientVersionUpdated::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCClientVersionUpdated>()._impl_._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCClientVersionUpdated::CMsgGCClientVersionUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCClientVersionUpdated)
}
CMsgGCClientVersionUpdated::CMsgGCClientVersionUpdated(const CMsgGCClientVersionUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCClientVersionUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.client_version_ = from._impl_.client_version_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCClientVersionUpdated)
}

inline void CMsgGCClientVersionUpdated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){0u}
  };
}

CMsgGCClientVersionUpdated::~CMsgGCClientVersionUpdated() {
  // @@protoc_insertion_point(destructor:CMsgGCClientVersionUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCClientVersionUpdated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCClientVersionUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCClientVersionUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCClientVersionUpdated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.client_version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCClientVersionUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_version(&has_bits);
          _impl_.client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCClientVersionUpdated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCClientVersionUpdated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCClientVersionUpdated)
  return target;
}

size_t CMsgGCClientVersionUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCClientVersionUpdated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 client_version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCClientVersionUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCClientVersionUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCClientVersionUpdated::GetClassData() const { return &_class_data_; }


void CMsgGCClientVersionUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCClientVersionUpdated*>(&to_msg);
  auto& from = static_cast<const CMsgGCClientVersionUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCClientVersionUpdated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_version()) {
    _this->_internal_set_client_version(from._internal_client_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCClientVersionUpdated::CopyFrom(const CMsgGCClientVersionUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCClientVersionUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCClientVersionUpdated::IsInitialized() const {
  return true;
}

void CMsgGCClientVersionUpdated::InternalSwap(CMsgGCClientVersionUpdated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.client_version_, other->_impl_.client_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCClientVersionUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[73]);
}

// ===================================================================

class CMsgGCToGCWebAPIAccountChanged::_Internal {
 public:
};

CMsgGCToGCWebAPIAccountChanged::CMsgGCToGCWebAPIAccountChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCWebAPIAccountChanged)
}
CMsgGCToGCWebAPIAccountChanged::CMsgGCToGCWebAPIAccountChanged(const CMsgGCToGCWebAPIAccountChanged& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCToGCWebAPIAccountChanged* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCWebAPIAccountChanged)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCWebAPIAccountChanged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCWebAPIAccountChanged::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCWebAPIAccountChanged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[74]);
}

// ===================================================================

class CMsgGCToGCRequestPassportItemGrant::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCRequestPassportItemGrant>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reward_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCToGCRequestPassportItemGrant::CMsgGCToGCRequestPassportItemGrant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCRequestPassportItemGrant)
}
CMsgGCToGCRequestPassportItemGrant::CMsgGCToGCRequestPassportItemGrant(const CMsgGCToGCRequestPassportItemGrant& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCRequestPassportItemGrant* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.reward_flag_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reward_flag_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.reward_flag_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCRequestPassportItemGrant)
}

inline void CMsgGCToGCRequestPassportItemGrant::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.reward_flag_){0}
  };
}

CMsgGCToGCRequestPassportItemGrant::~CMsgGCToGCRequestPassportItemGrant() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCRequestPassportItemGrant)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCRequestPassportItemGrant::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCRequestPassportItemGrant::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCRequestPassportItemGrant::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCRequestPassportItemGrant)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reward_flag_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.reward_flag_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCRequestPassportItemGrant::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reward_flag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reward_flag(&has_bits);
          _impl_.reward_flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCRequestPassportItemGrant::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCRequestPassportItemGrant)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional uint32 league_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_league_id(), target);
  }

  // optional int32 reward_flag = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_reward_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCRequestPassportItemGrant)
  return target;
}

size_t CMsgGCToGCRequestPassportItemGrant::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCRequestPassportItemGrant)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 league_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional int32 reward_flag = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reward_flag());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCRequestPassportItemGrant::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCRequestPassportItemGrant::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCRequestPassportItemGrant::GetClassData() const { return &_class_data_; }


void CMsgGCToGCRequestPassportItemGrant::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCRequestPassportItemGrant*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCRequestPassportItemGrant&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCRequestPassportItemGrant)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reward_flag_ = from._impl_.reward_flag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCRequestPassportItemGrant::CopyFrom(const CMsgGCToGCRequestPassportItemGrant& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCRequestPassportItemGrant)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCRequestPassportItemGrant::IsInitialized() const {
  return true;
}

void CMsgGCToGCRequestPassportItemGrant::InternalSwap(CMsgGCToGCRequestPassportItemGrant* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCRequestPassportItemGrant, _impl_.reward_flag_)
      + sizeof(CMsgGCToGCRequestPassportItemGrant::_impl_.reward_flag_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCRequestPassportItemGrant, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCRequestPassportItemGrant::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[75]);
}

// ===================================================================

class CMsgGameServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameServerInfo>()._impl_._has_bits_);
  static void set_has_server_public_ip_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_private_ip_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_tv_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_server_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_hibernation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_server_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_server_region(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_server_loadavg(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_server_tv_broadcast_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_server_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_server_relay_connected_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_relay_slots_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_relays_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_relay_clients_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_relayed_game_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_parent_relay_count(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_tv_secret_code(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

CMsgGameServerInfo::CMsgGameServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameServerInfo)
}
CMsgGameServerInfo::CMsgGameServerInfo(const CMsgGameServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_key_){}
    , decltype(_impl_.server_public_ip_addr_){}
    , decltype(_impl_.server_private_ip_addr_){}
    , decltype(_impl_.server_port_){}
    , decltype(_impl_.server_tv_port_){}
    , decltype(_impl_.server_hibernation_){}
    , decltype(_impl_.server_type_){}
    , decltype(_impl_.server_region_){}
    , decltype(_impl_.server_loadavg_){}
    , decltype(_impl_.server_tv_broadcast_time_){}
    , decltype(_impl_.server_game_time_){}
    , decltype(_impl_.server_relay_connected_steam_id_){}
    , decltype(_impl_.relay_slots_max_){}
    , decltype(_impl_.relays_connected_){}
    , decltype(_impl_.relayed_game_server_steam_id_){}
    , decltype(_impl_.relay_clients_connected_){}
    , decltype(_impl_.parent_relay_count_){}
    , decltype(_impl_.tv_secret_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.server_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_key()) {
    _this->_impl_.server_key_.Set(from._internal_server_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.server_public_ip_addr_, &from._impl_.server_public_ip_addr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tv_secret_code_) -
    reinterpret_cast<char*>(&_impl_.server_public_ip_addr_)) + sizeof(_impl_.tv_secret_code_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameServerInfo)
}

inline void CMsgGameServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_key_){}
    , decltype(_impl_.server_public_ip_addr_){0u}
    , decltype(_impl_.server_private_ip_addr_){0u}
    , decltype(_impl_.server_port_){0u}
    , decltype(_impl_.server_tv_port_){0u}
    , decltype(_impl_.server_hibernation_){false}
    , decltype(_impl_.server_type_){0}
    , decltype(_impl_.server_region_){0u}
    , decltype(_impl_.server_loadavg_){0}
    , decltype(_impl_.server_tv_broadcast_time_){0}
    , decltype(_impl_.server_game_time_){0}
    , decltype(_impl_.server_relay_connected_steam_id_){uint64_t{0u}}
    , decltype(_impl_.relay_slots_max_){0u}
    , decltype(_impl_.relays_connected_){0}
    , decltype(_impl_.relayed_game_server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.relay_clients_connected_){0}
    , decltype(_impl_.parent_relay_count_){0u}
    , decltype(_impl_.tv_secret_code_){uint64_t{0u}}
  };
  _impl_.server_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameServerInfo::~CMsgGameServerInfo() {
  // @@protoc_insertion_point(destructor:CMsgGameServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.server_key_.Destroy();
}

void CMsgGameServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.server_key_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.server_public_ip_addr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_region_) -
        reinterpret_cast<char*>(&_impl_.server_public_ip_addr_)) + sizeof(_impl_.server_region_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.server_loadavg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.relay_clients_connected_) -
        reinterpret_cast<char*>(&_impl_.server_loadavg_)) + sizeof(_impl_.relay_clients_connected_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&_impl_.parent_relay_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tv_secret_code_) -
        reinterpret_cast<char*>(&_impl_.parent_relay_count_)) + sizeof(_impl_.tv_secret_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 server_public_ip_addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_server_public_ip_addr(&has_bits);
          _impl_.server_public_ip_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_private_ip_addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_server_private_ip_addr(&has_bits);
          _impl_.server_private_ip_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_server_port(&has_bits);
          _impl_.server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_tv_port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_server_tv_port(&has_bits);
          _impl_.server_tv_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string server_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_server_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameServerInfo.server_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool server_hibernation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_server_hibernation(&has_bits);
          _impl_.server_hibernation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGameServerInfo.ServerType server_type = 7 [default = UNSPECIFIED];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgGameServerInfo_ServerType_IsValid(val))) {
            _internal_set_server_type(static_cast<::CMsgGameServerInfo_ServerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_region = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_server_region(&has_bits);
          _impl_.server_region_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float server_loadavg = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_server_loadavg(&has_bits);
          _impl_.server_loadavg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float server_tv_broadcast_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_server_tv_broadcast_time(&has_bits);
          _impl_.server_tv_broadcast_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float server_game_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_server_game_time(&has_bits);
          _impl_.server_game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 server_relay_connected_steam_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_server_relay_connected_steam_id(&has_bits);
          _impl_.server_relay_connected_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 relay_slots_max = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_relay_slots_max(&has_bits);
          _impl_.relay_slots_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 relays_connected = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_relays_connected(&has_bits);
          _impl_.relays_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 relay_clients_connected = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_relay_clients_connected(&has_bits);
          _impl_.relay_clients_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 relayed_game_server_steam_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_relayed_game_server_steam_id(&has_bits);
          _impl_.relayed_game_server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 parent_relay_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_parent_relay_count(&has_bits);
          _impl_.parent_relay_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 tv_secret_code = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _Internal::set_has_tv_secret_code(&has_bits);
          _impl_.tv_secret_code_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 server_public_ip_addr = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_server_public_ip_addr(), target);
  }

  // optional fixed32 server_private_ip_addr = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_server_private_ip_addr(), target);
  }

  // optional uint32 server_port = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_server_port(), target);
  }

  // optional uint32 server_tv_port = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_server_tv_port(), target);
  }

  // optional string server_key = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_key().data(), static_cast<int>(this->_internal_server_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameServerInfo.server_key");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_server_key(), target);
  }

  // optional bool server_hibernation = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_server_hibernation(), target);
  }

  // optional .CMsgGameServerInfo.ServerType server_type = 7 [default = UNSPECIFIED];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_server_type(), target);
  }

  // optional uint32 server_region = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_server_region(), target);
  }

  // optional float server_loadavg = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_server_loadavg(), target);
  }

  // optional float server_tv_broadcast_time = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_server_tv_broadcast_time(), target);
  }

  // optional float server_game_time = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_server_game_time(), target);
  }

  // optional fixed64 server_relay_connected_steam_id = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(12, this->_internal_server_relay_connected_steam_id(), target);
  }

  // optional uint32 relay_slots_max = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_relay_slots_max(), target);
  }

  // optional int32 relays_connected = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_relays_connected(), target);
  }

  // optional int32 relay_clients_connected = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_relay_clients_connected(), target);
  }

  // optional fixed64 relayed_game_server_steam_id = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(16, this->_internal_relayed_game_server_steam_id(), target);
  }

  // optional uint32 parent_relay_count = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_parent_relay_count(), target);
  }

  // optional fixed64 tv_secret_code = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(18, this->_internal_tv_secret_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameServerInfo)
  return target;
}

size_t CMsgGameServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string server_key = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_key());
    }

    // optional fixed32 server_public_ip_addr = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 server_private_ip_addr = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 server_port = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_port());
    }

    // optional uint32 server_tv_port = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_tv_port());
    }

    // optional bool server_hibernation = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional .CMsgGameServerInfo.ServerType server_type = 7 [default = UNSPECIFIED];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_server_type());
    }

    // optional uint32 server_region = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_region());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float server_loadavg = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float server_tv_broadcast_time = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float server_game_time = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional fixed64 server_relay_connected_steam_id = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional uint32 relay_slots_max = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_relay_slots_max());
    }

    // optional int32 relays_connected = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_relays_connected());
    }

    // optional fixed64 relayed_game_server_steam_id = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 8;
    }

    // optional int32 relay_clients_connected = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_relay_clients_connected());
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional uint32 parent_relay_count = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_parent_relay_count());
    }

    // optional fixed64 tv_secret_code = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameServerInfo::GetClassData() const { return &_class_data_; }


void CMsgGameServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameServerInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGameServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_server_key(from._internal_server_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.server_public_ip_addr_ = from._impl_.server_public_ip_addr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.server_private_ip_addr_ = from._impl_.server_private_ip_addr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.server_port_ = from._impl_.server_port_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.server_tv_port_ = from._impl_.server_tv_port_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.server_hibernation_ = from._impl_.server_hibernation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.server_type_ = from._impl_.server_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.server_region_ = from._impl_.server_region_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.server_loadavg_ = from._impl_.server_loadavg_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.server_tv_broadcast_time_ = from._impl_.server_tv_broadcast_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.server_game_time_ = from._impl_.server_game_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.server_relay_connected_steam_id_ = from._impl_.server_relay_connected_steam_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.relay_slots_max_ = from._impl_.relay_slots_max_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.relays_connected_ = from._impl_.relays_connected_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.relayed_game_server_steam_id_ = from._impl_.relayed_game_server_steam_id_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.relay_clients_connected_ = from._impl_.relay_clients_connected_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.parent_relay_count_ = from._impl_.parent_relay_count_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.tv_secret_code_ = from._impl_.tv_secret_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameServerInfo::CopyFrom(const CMsgGameServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameServerInfo::IsInitialized() const {
  return true;
}

void CMsgGameServerInfo::InternalSwap(CMsgGameServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_key_, lhs_arena,
      &other->_impl_.server_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGameServerInfo, _impl_.tv_secret_code_)
      + sizeof(CMsgGameServerInfo::_impl_.tv_secret_code_)
      - PROTOBUF_FIELD_OFFSET(CMsgGameServerInfo, _impl_.server_public_ip_addr_)>(
          reinterpret_cast<char*>(&_impl_.server_public_ip_addr_),
          reinterpret_cast<char*>(&other->_impl_.server_public_ip_addr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[76]);
}

// ===================================================================

class CSOEconEquipSlot::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconEquipSlot>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_class_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_item_definition(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CSOEconEquipSlot::CSOEconEquipSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconEquipSlot)
}
CSOEconEquipSlot::CSOEconEquipSlot(const CSOEconEquipSlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconEquipSlot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.class_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.item_definition_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_definition_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_definition_));
  // @@protoc_insertion_point(copy_constructor:CSOEconEquipSlot)
}

inline void CSOEconEquipSlot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.class_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.item_definition_){0u}
  };
}

CSOEconEquipSlot::~CSOEconEquipSlot() {
  // @@protoc_insertion_point(destructor:CSOEconEquipSlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconEquipSlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconEquipSlot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconEquipSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconEquipSlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_definition_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_definition_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconEquipSlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 class_id = 2 [(.key_field) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_class_id(&has_bits);
          _impl_.class_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot_id = 3 [(.key_field) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_definition = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_item_definition(&has_bits);
          _impl_.item_definition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconEquipSlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconEquipSlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 class_id = 2 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_class_id(), target);
  }

  // optional uint32 slot_id = 3 [(.key_field) = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_slot_id(), target);
  }

  // optional uint64 item_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_item_id(), target);
  }

  // optional uint32 item_definition = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_item_definition(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconEquipSlot)
  return target;
}

size_t CSOEconEquipSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconEquipSlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 class_id = 2 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_class_id());
    }

    // optional uint64 item_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 slot_id = 3 [(.key_field) = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 item_definition = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_definition());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconEquipSlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconEquipSlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconEquipSlot::GetClassData() const { return &_class_data_; }


void CSOEconEquipSlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconEquipSlot*>(&to_msg);
  auto& from = static_cast<const CSOEconEquipSlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconEquipSlot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.class_id_ = from._impl_.class_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_definition_ = from._impl_.item_definition_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconEquipSlot::CopyFrom(const CSOEconEquipSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconEquipSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconEquipSlot::IsInitialized() const {
  return true;
}

void CSOEconEquipSlot::InternalSwap(CSOEconEquipSlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconEquipSlot, _impl_.item_definition_)
      + sizeof(CSOEconEquipSlot::_impl_.item_definition_)
      - PROTOBUF_FIELD_OFFSET(CSOEconEquipSlot, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconEquipSlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[77]);
}

// ===================================================================

class CMsgAdjustEquipSlot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAdjustEquipSlot>()._impl_._has_bits_);
  static void set_has_class_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgAdjustEquipSlot::CMsgAdjustEquipSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAdjustEquipSlot)
}
CMsgAdjustEquipSlot::CMsgAdjustEquipSlot(const CMsgAdjustEquipSlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAdjustEquipSlot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_id_){}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.class_id_, &from._impl_.class_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_id_) -
    reinterpret_cast<char*>(&_impl_.class_id_)) + sizeof(_impl_.item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgAdjustEquipSlot)
}

inline void CMsgAdjustEquipSlot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_id_){0u}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
  };
}

CMsgAdjustEquipSlot::~CMsgAdjustEquipSlot() {
  // @@protoc_insertion_point(destructor:CMsgAdjustEquipSlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAdjustEquipSlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAdjustEquipSlot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAdjustEquipSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAdjustEquipSlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.class_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_id_) -
        reinterpret_cast<char*>(&_impl_.class_id_)) + sizeof(_impl_.item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAdjustEquipSlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 class_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_class_id(&has_bits);
          _impl_.class_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAdjustEquipSlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAdjustEquipSlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 class_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_class_id(), target);
  }

  // optional uint32 slot_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_slot_id(), target);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAdjustEquipSlot)
  return target;
}

size_t CMsgAdjustEquipSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAdjustEquipSlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 class_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_class_id());
    }

    // optional uint32 slot_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAdjustEquipSlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAdjustEquipSlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAdjustEquipSlot::GetClassData() const { return &_class_data_; }


void CMsgAdjustEquipSlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAdjustEquipSlot*>(&to_msg);
  auto& from = static_cast<const CMsgAdjustEquipSlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAdjustEquipSlot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.class_id_ = from._impl_.class_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAdjustEquipSlot::CopyFrom(const CMsgAdjustEquipSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAdjustEquipSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAdjustEquipSlot::IsInitialized() const {
  return true;
}

void CMsgAdjustEquipSlot::InternalSwap(CMsgAdjustEquipSlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAdjustEquipSlot, _impl_.item_id_)
      + sizeof(CMsgAdjustEquipSlot::_impl_.item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgAdjustEquipSlot, _impl_.class_id_)>(
          reinterpret_cast<char*>(&_impl_.class_id_),
          reinterpret_cast<char*>(&other->_impl_.class_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAdjustEquipSlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[78]);
}

// ===================================================================

class CMsgAdjustEquipSlots::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAdjustEquipSlots>()._impl_._has_bits_);
  static void set_has_change_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAdjustEquipSlots::CMsgAdjustEquipSlots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAdjustEquipSlots)
}
CMsgAdjustEquipSlots::CMsgAdjustEquipSlots(const CMsgAdjustEquipSlots& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAdjustEquipSlots* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){from._impl_.slots_}
    , decltype(_impl_.change_num_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.change_num_ = from._impl_.change_num_;
  // @@protoc_insertion_point(copy_constructor:CMsgAdjustEquipSlots)
}

inline void CMsgAdjustEquipSlots::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){arena}
    , decltype(_impl_.change_num_){0u}
  };
}

CMsgAdjustEquipSlots::~CMsgAdjustEquipSlots() {
  // @@protoc_insertion_point(destructor:CMsgAdjustEquipSlots)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAdjustEquipSlots::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.slots_.~RepeatedPtrField();
}

void CMsgAdjustEquipSlots::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAdjustEquipSlots::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAdjustEquipSlots)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slots_.Clear();
  _impl_.change_num_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAdjustEquipSlots::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgAdjustEquipSlot slots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 change_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_change_num(&has_bits);
          _impl_.change_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAdjustEquipSlots::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAdjustEquipSlots)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgAdjustEquipSlot slots = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 change_num = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_change_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAdjustEquipSlots)
  return target;
}

size_t CMsgAdjustEquipSlots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAdjustEquipSlots)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgAdjustEquipSlot slots = 1;
  total_size += 1UL * this->_internal_slots_size();
  for (const auto& msg : this->_impl_.slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 change_num = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_change_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAdjustEquipSlots::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAdjustEquipSlots::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAdjustEquipSlots::GetClassData() const { return &_class_data_; }


void CMsgAdjustEquipSlots::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAdjustEquipSlots*>(&to_msg);
  auto& from = static_cast<const CMsgAdjustEquipSlots&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAdjustEquipSlots)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.slots_.MergeFrom(from._impl_.slots_);
  if (from._internal_has_change_num()) {
    _this->_internal_set_change_num(from._internal_change_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAdjustEquipSlots::CopyFrom(const CMsgAdjustEquipSlots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAdjustEquipSlots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAdjustEquipSlots::IsInitialized() const {
  return true;
}

void CMsgAdjustEquipSlots::InternalSwap(CMsgAdjustEquipSlots* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.slots_.InternalSwap(&other->_impl_.slots_);
  swap(_impl_.change_num_, other->_impl_.change_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAdjustEquipSlots::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[79]);
}

// ===================================================================

class CMsgOpenCrate::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOpenCrate>()._impl_._has_bits_);
  static void set_has_tool_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subject_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_for_rental(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_points_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgOpenCrate::CMsgOpenCrate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOpenCrate)
}
CMsgOpenCrate::CMsgOpenCrate(const CMsgOpenCrate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOpenCrate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tool_item_id_){}
    , decltype(_impl_.subject_item_id_){}
    , decltype(_impl_.for_rental_){}
    , decltype(_impl_.points_remaining_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tool_item_id_, &from._impl_.tool_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.points_remaining_) -
    reinterpret_cast<char*>(&_impl_.tool_item_id_)) + sizeof(_impl_.points_remaining_));
  // @@protoc_insertion_point(copy_constructor:CMsgOpenCrate)
}

inline void CMsgOpenCrate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tool_item_id_){uint64_t{0u}}
    , decltype(_impl_.subject_item_id_){uint64_t{0u}}
    , decltype(_impl_.for_rental_){false}
    , decltype(_impl_.points_remaining_){0u}
  };
}

CMsgOpenCrate::~CMsgOpenCrate() {
  // @@protoc_insertion_point(destructor:CMsgOpenCrate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOpenCrate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgOpenCrate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOpenCrate::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOpenCrate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.tool_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.points_remaining_) -
        reinterpret_cast<char*>(&_impl_.tool_item_id_)) + sizeof(_impl_.points_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOpenCrate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 tool_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tool_item_id(&has_bits);
          _impl_.tool_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 subject_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_subject_item_id(&has_bits);
          _impl_.subject_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool for_rental = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_for_rental(&has_bits);
          _impl_.for_rental_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 points_remaining = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_points_remaining(&has_bits);
          _impl_.points_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOpenCrate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOpenCrate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 tool_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tool_item_id(), target);
  }

  // optional uint64 subject_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_subject_item_id(), target);
  }

  // optional bool for_rental = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_for_rental(), target);
  }

  // optional uint32 points_remaining = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_points_remaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOpenCrate)
  return target;
}

size_t CMsgOpenCrate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOpenCrate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 tool_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tool_item_id());
    }

    // optional uint64 subject_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_subject_item_id());
    }

    // optional bool for_rental = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 points_remaining = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_points_remaining());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOpenCrate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOpenCrate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOpenCrate::GetClassData() const { return &_class_data_; }


void CMsgOpenCrate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOpenCrate*>(&to_msg);
  auto& from = static_cast<const CMsgOpenCrate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOpenCrate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tool_item_id_ = from._impl_.tool_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.subject_item_id_ = from._impl_.subject_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.for_rental_ = from._impl_.for_rental_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.points_remaining_ = from._impl_.points_remaining_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOpenCrate::CopyFrom(const CMsgOpenCrate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOpenCrate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOpenCrate::IsInitialized() const {
  return true;
}

void CMsgOpenCrate::InternalSwap(CMsgOpenCrate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOpenCrate, _impl_.points_remaining_)
      + sizeof(CMsgOpenCrate::_impl_.points_remaining_)
      - PROTOBUF_FIELD_OFFSET(CMsgOpenCrate, _impl_.tool_item_id_)>(
          reinterpret_cast<char*>(&_impl_.tool_item_id_),
          reinterpret_cast<char*>(&other->_impl_.tool_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOpenCrate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[80]);
}

// ===================================================================

class CSOEconRentalHistory::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconRentalHistory>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crate_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_crate_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_issue_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_expiration_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CSOEconRentalHistory::CSOEconRentalHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconRentalHistory)
}
CSOEconRentalHistory::CSOEconRentalHistory(const CSOEconRentalHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconRentalHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crate_item_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.crate_def_index_){}
    , decltype(_impl_.issue_date_){}
    , decltype(_impl_.expiration_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.crate_item_id_, &from._impl_.crate_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.expiration_date_) -
    reinterpret_cast<char*>(&_impl_.crate_item_id_)) + sizeof(_impl_.expiration_date_));
  // @@protoc_insertion_point(copy_constructor:CSOEconRentalHistory)
}

inline void CSOEconRentalHistory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crate_item_id_){uint64_t{0u}}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.crate_def_index_){0u}
    , decltype(_impl_.issue_date_){0u}
    , decltype(_impl_.expiration_date_){0u}
  };
}

CSOEconRentalHistory::~CSOEconRentalHistory() {
  // @@protoc_insertion_point(destructor:CSOEconRentalHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconRentalHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconRentalHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconRentalHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconRentalHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.crate_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.expiration_date_) -
        reinterpret_cast<char*>(&_impl_.crate_item_id_)) + sizeof(_impl_.expiration_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconRentalHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 crate_item_id = 2 [(.key_field) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_crate_item_id(&has_bits);
          _impl_.crate_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 crate_def_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_crate_def_index(&has_bits);
          _impl_.crate_def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 issue_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_issue_date(&has_bits);
          _impl_.issue_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expiration_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_expiration_date(&has_bits);
          _impl_.expiration_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconRentalHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconRentalHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint64 crate_item_id = 2 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_crate_item_id(), target);
  }

  // optional uint32 crate_def_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_crate_def_index(), target);
  }

  // optional uint32 issue_date = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_issue_date(), target);
  }

  // optional uint32 expiration_date = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_expiration_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconRentalHistory)
  return target;
}

size_t CSOEconRentalHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconRentalHistory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 crate_item_id = 2 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_crate_item_id());
    }

    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 crate_def_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crate_def_index());
    }

    // optional uint32 issue_date = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_issue_date());
    }

    // optional uint32 expiration_date = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expiration_date());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconRentalHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconRentalHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconRentalHistory::GetClassData() const { return &_class_data_; }


void CSOEconRentalHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconRentalHistory*>(&to_msg);
  auto& from = static_cast<const CSOEconRentalHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconRentalHistory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.crate_item_id_ = from._impl_.crate_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.crate_def_index_ = from._impl_.crate_def_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.issue_date_ = from._impl_.issue_date_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.expiration_date_ = from._impl_.expiration_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconRentalHistory::CopyFrom(const CSOEconRentalHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconRentalHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconRentalHistory::IsInitialized() const {
  return true;
}

void CSOEconRentalHistory::InternalSwap(CSOEconRentalHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconRentalHistory, _impl_.expiration_date_)
      + sizeof(CSOEconRentalHistory::_impl_.expiration_date_)
      - PROTOBUF_FIELD_OFFSET(CSOEconRentalHistory, _impl_.crate_item_id_)>(
          reinterpret_cast<char*>(&_impl_.crate_item_id_),
          reinterpret_cast<char*>(&other->_impl_.crate_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconRentalHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[81]);
}

// ===================================================================

class CMsgAcknowledgeRentalExpiration::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAcknowledgeRentalExpiration>()._impl_._has_bits_);
  static void set_has_crate_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAcknowledgeRentalExpiration::CMsgAcknowledgeRentalExpiration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAcknowledgeRentalExpiration)
}
CMsgAcknowledgeRentalExpiration::CMsgAcknowledgeRentalExpiration(const CMsgAcknowledgeRentalExpiration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAcknowledgeRentalExpiration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crate_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.crate_item_id_ = from._impl_.crate_item_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgAcknowledgeRentalExpiration)
}

inline void CMsgAcknowledgeRentalExpiration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crate_item_id_){uint64_t{0u}}
  };
}

CMsgAcknowledgeRentalExpiration::~CMsgAcknowledgeRentalExpiration() {
  // @@protoc_insertion_point(destructor:CMsgAcknowledgeRentalExpiration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAcknowledgeRentalExpiration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAcknowledgeRentalExpiration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAcknowledgeRentalExpiration::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAcknowledgeRentalExpiration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crate_item_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAcknowledgeRentalExpiration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 crate_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_crate_item_id(&has_bits);
          _impl_.crate_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAcknowledgeRentalExpiration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAcknowledgeRentalExpiration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 crate_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_crate_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAcknowledgeRentalExpiration)
  return target;
}

size_t CMsgAcknowledgeRentalExpiration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAcknowledgeRentalExpiration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 crate_item_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_crate_item_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAcknowledgeRentalExpiration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAcknowledgeRentalExpiration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAcknowledgeRentalExpiration::GetClassData() const { return &_class_data_; }


void CMsgAcknowledgeRentalExpiration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAcknowledgeRentalExpiration*>(&to_msg);
  auto& from = static_cast<const CMsgAcknowledgeRentalExpiration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAcknowledgeRentalExpiration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_crate_item_id()) {
    _this->_internal_set_crate_item_id(from._internal_crate_item_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAcknowledgeRentalExpiration::CopyFrom(const CMsgAcknowledgeRentalExpiration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAcknowledgeRentalExpiration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAcknowledgeRentalExpiration::IsInitialized() const {
  return true;
}

void CMsgAcknowledgeRentalExpiration::InternalSwap(CMsgAcknowledgeRentalExpiration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.crate_item_id_, other->_impl_.crate_item_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAcknowledgeRentalExpiration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_base_5fgcmessages_2eproto_getter, &descriptor_table_base_5fgcmessages_2eproto_once,
      file_level_metadata_base_5fgcmessages_2eproto[82]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CGCStorePurchaseInit_LineItem*
Arena::CreateMaybeMessage< ::CGCStorePurchaseInit_LineItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCStorePurchaseInit_LineItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseInit*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseInit >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseInitResponse*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseInitResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseInitResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOPartyInvite*
Arena::CreateMaybeMessage< ::CSOPartyInvite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOPartyInvite >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOLobbyInvite*
Arena::CreateMaybeMessage< ::CSOLobbyInvite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOLobbyInvite >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemBroadcast*
Arena::CreateMaybeMessage< ::CMsgSystemBroadcast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemBroadcast >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgInviteToParty*
Arena::CreateMaybeMessage< ::CMsgInviteToParty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgInviteToParty >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgInvitationCreated*
Arena::CreateMaybeMessage< ::CMsgInvitationCreated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgInvitationCreated >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPartyInviteResponse*
Arena::CreateMaybeMessage< ::CMsgPartyInviteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPartyInviteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgKickFromParty*
Arena::CreateMaybeMessage< ::CMsgKickFromParty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgKickFromParty >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLeaveParty*
Arena::CreateMaybeMessage< ::CMsgLeaveParty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLeaveParty >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerAvailable*
Arena::CreateMaybeMessage< ::CMsgServerAvailable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerAvailable >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLANServerAvailable*
Arena::CreateMaybeMessage< ::CMsgLANServerAvailable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLANServerAvailable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconGameAccountClient*
Arena::CreateMaybeMessage< ::CSOEconGameAccountClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconGameAccountClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOItemCriteriaCondition*
Arena::CreateMaybeMessage< ::CSOItemCriteriaCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOItemCriteriaCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOItemCriteria*
Arena::CreateMaybeMessage< ::CSOItemCriteria >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOItemCriteria >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOItemRecipe*
Arena::CreateMaybeMessage< ::CSOItemRecipe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOItemRecipe >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDevNewItemRequest*
Arena::CreateMaybeMessage< ::CMsgDevNewItemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDevNewItemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgIncrementKillCountAttribute*
Arena::CreateMaybeMessage< ::CMsgIncrementKillCountAttribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgIncrementKillCountAttribute >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgApplySticker*
Arena::CreateMaybeMessage< ::CMsgApplySticker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgApplySticker >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgModifyItemAttribute*
Arena::CreateMaybeMessage< ::CMsgModifyItemAttribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgModifyItemAttribute >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgApplyStatTrakSwap*
Arena::CreateMaybeMessage< ::CMsgApplyStatTrakSwap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgApplyStatTrakSwap >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgApplyStrangePart*
Arena::CreateMaybeMessage< ::CMsgApplyStrangePart >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgApplyStrangePart >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgApplyPennantUpgrade*
Arena::CreateMaybeMessage< ::CMsgApplyPennantUpgrade >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgApplyPennantUpgrade >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgApplyEggEssence*
Arena::CreateMaybeMessage< ::CMsgApplyEggEssence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgApplyEggEssence >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemAttribute*
Arena::CreateMaybeMessage< ::CSOEconItemAttribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemAttribute >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemEquipped*
Arena::CreateMaybeMessage< ::CSOEconItemEquipped >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemEquipped >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItem*
Arena::CreateMaybeMessage< ::CSOEconItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSortItems*
Arena::CreateMaybeMessage< ::CMsgSortItems >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSortItems >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconClaimCode*
Arena::CreateMaybeMessage< ::CSOEconClaimCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconClaimCode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStoreGetUserData*
Arena::CreateMaybeMessage< ::CMsgStoreGetUserData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStoreGetUserData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStoreGetUserDataResponse*
Arena::CreateMaybeMessage< ::CMsgStoreGetUserDataResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStoreGetUserDataResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgUpdateItemSchema*
Arena::CreateMaybeMessage< ::CMsgUpdateItemSchema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgUpdateItemSchema >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCError*
Arena::CreateMaybeMessage< ::CMsgGCError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCError >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRequestInventoryRefresh*
Arena::CreateMaybeMessage< ::CMsgRequestInventoryRefresh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRequestInventoryRefresh >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgConVarValue*
Arena::CreateMaybeMessage< ::CMsgConVarValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgConVarValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgReplicateConVars*
Arena::CreateMaybeMessage< ::CMsgReplicateConVars >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgReplicateConVars >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgUseItem*
Arena::CreateMaybeMessage< ::CMsgUseItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgUseItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgReplayUploadedToYouTube*
Arena::CreateMaybeMessage< ::CMsgReplayUploadedToYouTube >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgReplayUploadedToYouTube >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgConsumableExhausted*
Arena::CreateMaybeMessage< ::CMsgConsumableExhausted >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgConsumableExhausted >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgItemAcknowledged__DEPRECATED*
Arena::CreateMaybeMessage< ::CMsgItemAcknowledged__DEPRECATED >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgItemAcknowledged__DEPRECATED >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSetItemPositions_ItemPosition*
Arena::CreateMaybeMessage< ::CMsgSetItemPositions_ItemPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSetItemPositions_ItemPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSetItemPositions*
Arena::CreateMaybeMessage< ::CMsgSetItemPositions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSetItemPositions >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCReportAbuse*
Arena::CreateMaybeMessage< ::CMsgGCReportAbuse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCReportAbuse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCReportAbuseResponse*
Arena::CreateMaybeMessage< ::CMsgGCReportAbuseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCReportAbuseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCNameItemNotification*
Arena::CreateMaybeMessage< ::CMsgGCNameItemNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCNameItemNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCClientDisplayNotification*
Arena::CreateMaybeMessage< ::CMsgGCClientDisplayNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCClientDisplayNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCShowItemsPickedUp*
Arena::CreateMaybeMessage< ::CMsgGCShowItemsPickedUp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCShowItemsPickedUp >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCIncrementKillCountResponse*
Arena::CreateMaybeMessage< ::CMsgGCIncrementKillCountResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCIncrementKillCountResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemDropRateBonus*
Arena::CreateMaybeMessage< ::CSOEconItemDropRateBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemDropRateBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemLeagueViewPass*
Arena::CreateMaybeMessage< ::CSOEconItemLeagueViewPass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemLeagueViewPass >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemEventTicket*
Arena::CreateMaybeMessage< ::CSOEconItemEventTicket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemEventTicket >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCItemPreviewItemBoughtNotification*
Arena::CreateMaybeMessage< ::CMsgGCItemPreviewItemBoughtNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCItemPreviewItemBoughtNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseCancel*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseCancel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseCancel >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseCancelResponse*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseCancelResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseCancelResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseFinalize*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseFinalize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseFinalize >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCStorePurchaseFinalizeResponse*
Arena::CreateMaybeMessage< ::CMsgGCStorePurchaseFinalizeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCStorePurchaseFinalizeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCBannedWordListRequest*
Arena::CreateMaybeMessage< ::CMsgGCBannedWordListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCBannedWordListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestAnnouncements*
Arena::CreateMaybeMessage< ::CMsgGCRequestAnnouncements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestAnnouncements >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestAnnouncementsResponse*
Arena::CreateMaybeMessage< ::CMsgGCRequestAnnouncementsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestAnnouncementsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCBannedWord*
Arena::CreateMaybeMessage< ::CMsgGCBannedWord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCBannedWord >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCBannedWordListResponse*
Arena::CreateMaybeMessage< ::CMsgGCBannedWordListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCBannedWordListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCBannedWordListBroadcast*
Arena::CreateMaybeMessage< ::CMsgGCToGCBannedWordListBroadcast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCBannedWordListBroadcast >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCBannedWordListUpdated*
Arena::CreateMaybeMessage< ::CMsgGCToGCBannedWordListUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCBannedWordListUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCDirtySDOCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCDirtySDOCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCDirtySDOCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCDirtyMultipleSDOCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCDirtyMultipleSDOCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCDirtyMultipleSDOCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCCollectItem*
Arena::CreateMaybeMessage< ::CMsgGCCollectItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCCollectItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSDONoMemcached*
Arena::CreateMaybeMessage< ::CMsgSDONoMemcached >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSDONoMemcached >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCUpdateSQLKeyValue*
Arena::CreateMaybeMessage< ::CMsgGCToGCUpdateSQLKeyValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCUpdateSQLKeyValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCIsTrustedServer*
Arena::CreateMaybeMessage< ::CMsgGCToGCIsTrustedServer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCIsTrustedServer >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCIsTrustedServerResponse*
Arena::CreateMaybeMessage< ::CMsgGCToGCIsTrustedServerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCIsTrustedServerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCBroadcastConsoleCommand*
Arena::CreateMaybeMessage< ::CMsgGCToGCBroadcastConsoleCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCBroadcastConsoleCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCServerVersionUpdated*
Arena::CreateMaybeMessage< ::CMsgGCServerVersionUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCServerVersionUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCClientVersionUpdated*
Arena::CreateMaybeMessage< ::CMsgGCClientVersionUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCClientVersionUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCWebAPIAccountChanged*
Arena::CreateMaybeMessage< ::CMsgGCToGCWebAPIAccountChanged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCWebAPIAccountChanged >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCRequestPassportItemGrant*
Arena::CreateMaybeMessage< ::CMsgGCToGCRequestPassportItemGrant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCRequestPassportItemGrant >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameServerInfo*
Arena::CreateMaybeMessage< ::CMsgGameServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconEquipSlot*
Arena::CreateMaybeMessage< ::CSOEconEquipSlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconEquipSlot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAdjustEquipSlot*
Arena::CreateMaybeMessage< ::CMsgAdjustEquipSlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAdjustEquipSlot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAdjustEquipSlots*
Arena::CreateMaybeMessage< ::CMsgAdjustEquipSlots >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAdjustEquipSlots >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOpenCrate*
Arena::CreateMaybeMessage< ::CMsgOpenCrate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOpenCrate >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconRentalHistory*
Arena::CreateMaybeMessage< ::CSOEconRentalHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconRentalHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAcknowledgeRentalExpiration*
Arena::CreateMaybeMessage< ::CMsgAcknowledgeRentalExpiration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAcknowledgeRentalExpiration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
