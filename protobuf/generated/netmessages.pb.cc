// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netmessages.proto

#include "netmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.friends_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.send_table_crc_)*/0u
  , /*decltype(_impl_.server_count_)*/0u
  , /*decltype(_impl_.is_hltv_)*/false
  , /*decltype(_impl_.friends_id_)*/0u} {}
struct CCLCMsg_ClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ClientInfoDefaultTypeInternal() {}
  union {
    CCLCMsg_ClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ClientInfoDefaultTypeInternal _CCLCMsg_ClientInfo_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_Move::CCLCMsg_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_command_number_)*/0u} {}
struct CCLCMsg_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_MoveDefaultTypeInternal() {}
  union {
    CCLCMsg_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_MoveDefaultTypeInternal _CCLCMsg_Move_default_instance_;
PROTOBUF_CONSTEXPR CMsgVoiceAudio::CMsgVoiceAudio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.packet_offsets_)*/{}
  , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
  , /*decltype(_impl_.voice_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.sequence_bytes_)*/0
  , /*decltype(_impl_.section_number_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.uncompressed_sample_offset_)*/0u
  , /*decltype(_impl_.num_packets_)*/0u
  , /*decltype(_impl_.voice_level_)*/0} {}
struct CMsgVoiceAudioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgVoiceAudioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgVoiceAudioDefaultTypeInternal() {}
  union {
    CMsgVoiceAudio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgVoiceAudioDefaultTypeInternal _CMsgVoiceAudio_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_VoiceData::CCLCMsg_VoiceData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.xuid_)*/uint64_t{0u}
  , /*decltype(_impl_.tick_)*/0u} {}
struct CCLCMsg_VoiceDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_VoiceDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_VoiceDataDefaultTypeInternal() {}
  union {
    CCLCMsg_VoiceData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_VoiceDataDefaultTypeInternal _CCLCMsg_VoiceData_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.baseline_tick_)*/0
  , /*decltype(_impl_.baseline_nr_)*/0} {}
struct CCLCMsg_BaselineAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_BaselineAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_BaselineAckDefaultTypeInternal() {}
  union {
    CCLCMsg_BaselineAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_BaselineAckDefaultTypeInternal _CCLCMsg_BaselineAck_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.event_mask_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CCLCMsg_ListenEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ListenEventsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ListenEventsDefaultTypeInternal() {}
  union {
    CCLCMsg_ListenEvents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ListenEventsDefaultTypeInternal _CCLCMsg_ListenEvents_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cookie_)*/0
  , /*decltype(_impl_.status_code_)*/0} {}
struct CCLCMsg_RespondCvarValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RespondCvarValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RespondCvarValueDefaultTypeInternal() {}
  union {
    CCLCMsg_RespondCvarValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RespondCvarValueDefaultTypeInternal _CCLCMsg_RespondCvarValue_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_path_)*/0
  , /*decltype(_impl_.code_filename_)*/0
  , /*decltype(_impl_.crc_)*/0u} {}
struct CCLCMsg_FileCRCCheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_FileCRCCheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_FileCRCCheckDefaultTypeInternal() {}
  union {
    CCLCMsg_FileCRCCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_FileCRCCheckDefaultTypeInternal _CCLCMsg_FileCRCCheck_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.progress_)*/0} {}
struct CCLCMsg_LoadingProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_LoadingProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_LoadingProgressDefaultTypeInternal() {}
  union {
    CCLCMsg_LoadingProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_LoadingProgressDefaultTypeInternal _CCLCMsg_LoadingProgress_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_SplitPlayerConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_SplitPlayerConnectDefaultTypeInternal() {}
  union {
    CCLCMsg_SplitPlayerConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_SplitPlayerConnectDefaultTypeInternal _CCLCMsg_SplitPlayerConnect_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_)*/0} {}
struct CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal() {}
  union {
    CCLCMsg_SplitPlayerDisconnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal _CCLCMsg_SplitPlayerDisconnect_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.simplified_)*/false} {}
struct CCLCMsg_ServerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ServerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ServerStatusDefaultTypeInternal() {}
  union {
    CCLCMsg_ServerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ServerStatusDefaultTypeInternal _CCLCMsg_ServerStatus_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RequestPause::CCLCMsg_RequestPause(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pause_type_)*/0
  , /*decltype(_impl_.pause_group_)*/0} {}
struct CCLCMsg_RequestPauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RequestPauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RequestPauseDefaultTypeInternal() {}
  union {
    CCLCMsg_RequestPause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RequestPauseDefaultTypeInternal _CCLCMsg_RequestPause_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_CmdKeyValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_CmdKeyValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_CmdKeyValuesDefaultTypeInternal() {}
  union {
    CCLCMsg_CmdKeyValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_CmdKeyValuesDefaultTypeInternal _CCLCMsg_CmdKeyValues_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_RconServerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RconServerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RconServerDetailsDefaultTypeInternal() {}
  union {
    CCLCMsg_RconServerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RconServerDetailsDefaultTypeInternal _CCLCMsg_RconServerDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgSource2SystemSpecs::CMsgSource2SystemSpecs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cpu_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpu_brand_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gpu_rendersystem_dll_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gpu_driver_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpu_model_)*/0u
  , /*decltype(_impl_.cpu_num_physical_)*/0u
  , /*decltype(_impl_.ram_physical_total_mb_)*/0u
  , /*decltype(_impl_.gpu_vendor_id_)*/0u
  , /*decltype(_impl_.gpu_driver_version_high_)*/0u
  , /*decltype(_impl_.gpu_driver_version_low_)*/0u
  , /*decltype(_impl_.gpu_dx_support_level_)*/0u
  , /*decltype(_impl_.gpu_texture_memory_size_mb_)*/0u} {}
struct CMsgSource2SystemSpecsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSource2SystemSpecsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSource2SystemSpecsDefaultTypeInternal() {}
  union {
    CMsgSource2SystemSpecs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSource2SystemSpecsDefaultTypeInternal _CMsgSource2SystemSpecs_default_instance_;
PROTOBUF_CONSTEXPR CMsgSource2VProfLiteReportItem::CMsgSource2VProfLiteReportItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.active_samples_)*/0u
  , /*decltype(_impl_.usec_max_)*/0u
  , /*decltype(_impl_.usec_avg_active_)*/0u
  , /*decltype(_impl_.usec_p50_active_)*/0u
  , /*decltype(_impl_.usec_p99_active_)*/0u
  , /*decltype(_impl_.usec_avg_all_)*/0u
  , /*decltype(_impl_.usec_p50_all_)*/0u
  , /*decltype(_impl_.usec_p99_all_)*/0u} {}
struct CMsgSource2VProfLiteReportItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSource2VProfLiteReportItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSource2VProfLiteReportItemDefaultTypeInternal() {}
  union {
    CMsgSource2VProfLiteReportItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSource2VProfLiteReportItemDefaultTypeInternal _CMsgSource2VProfLiteReportItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgSource2VProfLiteReport::CMsgSource2VProfLiteReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.total_)*/nullptr
  , /*decltype(_impl_.discarded_frames_)*/0u} {}
struct CMsgSource2VProfLiteReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSource2VProfLiteReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSource2VProfLiteReportDefaultTypeInternal() {}
  union {
    CMsgSource2VProfLiteReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSource2VProfLiteReportDefaultTypeInternal _CMsgSource2VProfLiteReport_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_Diagnostic::CCLCMsg_Diagnostic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.system_specs_)*/nullptr
  , /*decltype(_impl_.vprof_report_)*/nullptr} {}
struct CCLCMsg_DiagnosticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_DiagnosticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_DiagnosticDefaultTypeInternal() {}
  union {
    CCLCMsg_Diagnostic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_DiagnosticDefaultTypeInternal _CCLCMsg_Diagnostic_default_instance_;
PROTOBUF_CONSTEXPR CSource2Metrics_MatchPerfSummary_Notification_Client::CSource2Metrics_MatchPerfSummary_Notification_Client(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.system_specs_)*/nullptr
  , /*decltype(_impl_.profile_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.build_id_)*/0u} {}
struct CSource2Metrics_MatchPerfSummary_Notification_ClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSource2Metrics_MatchPerfSummary_Notification_ClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSource2Metrics_MatchPerfSummary_Notification_ClientDefaultTypeInternal() {}
  union {
    CSource2Metrics_MatchPerfSummary_Notification_Client _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSource2Metrics_MatchPerfSummary_Notification_ClientDefaultTypeInternal _CSource2Metrics_MatchPerfSummary_Notification_Client_default_instance_;
PROTOBUF_CONSTEXPR CSource2Metrics_MatchPerfSummary_Notification::CSource2Metrics_MatchPerfSummary_Notification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.clients_)*/{}
  , /*decltype(_impl_.game_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_profile_)*/nullptr
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.server_build_id_)*/0u} {}
struct CSource2Metrics_MatchPerfSummary_NotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSource2Metrics_MatchPerfSummary_NotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSource2Metrics_MatchPerfSummary_NotificationDefaultTypeInternal() {}
  union {
    CSource2Metrics_MatchPerfSummary_Notification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSource2Metrics_MatchPerfSummary_NotificationDefaultTypeInternal _CSource2Metrics_MatchPerfSummary_Notification_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_dir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sky_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.addon_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_session_manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_session_config_)*/nullptr
  , /*decltype(_impl_.protocol_)*/0
  , /*decltype(_impl_.server_count_)*/0
  , /*decltype(_impl_.is_dedicated_)*/false
  , /*decltype(_impl_.is_hltv_)*/false
  , /*decltype(_impl_.c_os_)*/0
  , /*decltype(_impl_.max_clients_)*/0
  , /*decltype(_impl_.max_classes_)*/0
  , /*decltype(_impl_.tick_interval_)*/0
  , /*decltype(_impl_.player_slot_)*/-1} {}
struct CSVCMsg_ServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ServerInfoDefaultTypeInternal() {}
  union {
    CSVCMsg_ServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ServerInfoDefaultTypeInternal _CSVCMsg_ServerInfo_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.class_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.class_id_)*/0} {}
struct CSVCMsg_ClassInfo_class_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo_class_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClassInfo_class_tDefaultTypeInternal() {}
  union {
    CSVCMsg_ClassInfo_class_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClassInfo_class_tDefaultTypeInternal _CSVCMsg_ClassInfo_class_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.classes_)*/{}
  , /*decltype(_impl_.create_on_client_)*/false} {}
struct CSVCMsg_ClassInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClassInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClassInfoDefaultTypeInternal() {}
  union {
    CSVCMsg_ClassInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClassInfoDefaultTypeInternal _CSVCMsg_ClassInfo_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SetPause::CSVCMsg_SetPause(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.paused_)*/false} {}
struct CSVCMsg_SetPauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SetPauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SetPauseDefaultTypeInternal() {}
  union {
    CSVCMsg_SetPause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SetPauseDefaultTypeInternal _CSVCMsg_SetPause_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.codec_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_)*/0
  , /*decltype(_impl_.version_)*/0} {}
struct CSVCMsg_VoiceInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_VoiceInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_VoiceInitDefaultTypeInternal() {}
  union {
    CSVCMsg_VoiceInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_VoiceInitDefaultTypeInternal _CSVCMsg_VoiceInit_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Print::CSVCMsg_Print(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_PrintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PrintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PrintDefaultTypeInternal() {}
  union {
    CSVCMsg_Print _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PrintDefaultTypeInternal _CSVCMsg_Print_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_x_)*/0
  , /*decltype(_impl_.origin_y_)*/0
  , /*decltype(_impl_.origin_z_)*/0
  , /*decltype(_impl_.volume_)*/0u
  , /*decltype(_impl_.delay_value_)*/0
  , /*decltype(_impl_.sequence_number_)*/0
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.sound_num_)*/0u
  , /*decltype(_impl_.sound_num_handle_)*/0u
  , /*decltype(_impl_.speaker_entity_)*/0
  , /*decltype(_impl_.random_seed_)*/0
  , /*decltype(_impl_.sound_level_)*/0
  , /*decltype(_impl_.is_sentence_)*/false
  , /*decltype(_impl_.is_ambient_)*/false
  , /*decltype(_impl_.guid_)*/0u
  , /*decltype(_impl_.sound_resource_id_)*/uint64_t{0u}
  , /*decltype(_impl_.entity_index_)*/-1} {}
struct CSVCMsg_Sounds_sounddata_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_Sounds_sounddata_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_Sounds_sounddata_tDefaultTypeInternal() {}
  union {
    CSVCMsg_Sounds_sounddata_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_Sounds_sounddata_tDefaultTypeInternal _CSVCMsg_Sounds_sounddata_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Sounds::CSVCMsg_Sounds(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sounds_)*/{}
  , /*decltype(_impl_.reliable_sound_)*/false} {}
struct CSVCMsg_SoundsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SoundsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SoundsDefaultTypeInternal() {}
  union {
    CSVCMsg_Sounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SoundsDefaultTypeInternal _CSVCMsg_Sounds_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Prefetch::CSVCMsg_Prefetch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sound_index_)*/0
  , /*decltype(_impl_.resource_type_)*/0} {}
struct CSVCMsg_PrefetchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PrefetchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PrefetchDefaultTypeInternal() {}
  union {
    CSVCMsg_Prefetch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PrefetchDefaultTypeInternal _CSVCMsg_Prefetch_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SetView::CSVCMsg_SetView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_index_)*/-1
  , /*decltype(_impl_.slot_)*/-1} {}
struct CSVCMsg_SetViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SetViewDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SetViewDefaultTypeInternal() {}
  union {
    CSVCMsg_SetView _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SetViewDefaultTypeInternal _CSVCMsg_SetView_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FixAngle::CSVCMsg_FixAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/nullptr
  , /*decltype(_impl_.relative_)*/false} {}
struct CSVCMsg_FixAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FixAngleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FixAngleDefaultTypeInternal() {}
  union {
    CSVCMsg_FixAngle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FixAngleDefaultTypeInternal _CSVCMsg_FixAngle_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/nullptr} {}
struct CSVCMsg_CrosshairAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CrosshairAngleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CrosshairAngleDefaultTypeInternal() {}
  union {
    CSVCMsg_CrosshairAngle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CrosshairAngleDefaultTypeInternal _CSVCMsg_CrosshairAngle_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.decal_texture_index_)*/0
  , /*decltype(_impl_.model_index_)*/0
  , /*decltype(_impl_.low_priority_)*/false
  , /*decltype(_impl_.entity_index_)*/-1} {}
struct CSVCMsg_BSPDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_BSPDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_BSPDecalDefaultTypeInternal() {}
  union {
    CSVCMsg_BSPDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_BSPDecalDefaultTypeInternal _CSVCMsg_BSPDecal_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.player_index_)*/-1} {}
struct CSVCMsg_SplitScreenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SplitScreenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SplitScreenDefaultTypeInternal() {}
  union {
    CSVCMsg_SplitScreen _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SplitScreenDefaultTypeInternal _CSVCMsg_SplitScreen_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cvar_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cookie_)*/0} {}
struct CSVCMsg_GetCvarValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GetCvarValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GetCvarValueDefaultTypeInternal() {}
  union {
    CSVCMsg_GetCvarValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GetCvarValueDefaultTypeInternal _CSVCMsg_GetCvarValue_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Menu::CSVCMsg_Menu(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.menu_key_values_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dialog_type_)*/0} {}
struct CSVCMsg_MenuDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_MenuDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_MenuDefaultTypeInternal() {}
  union {
    CSVCMsg_Menu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_MenuDefaultTypeInternal _CSVCMsg_Menu_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_UserMessage::CSVCMsg_UserMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0
  , /*decltype(_impl_.passthrough_)*/0} {}
struct CSVCMsg_UserMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_UserMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_UserMessageDefaultTypeInternal() {}
  union {
    CSVCMsg_UserMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_UserMessageDefaultTypeInternal _CSVCMsg_UserMessage_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.var_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dt_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.num_elements_)*/0
  , /*decltype(_impl_.low_value_)*/0
  , /*decltype(_impl_.high_value_)*/0
  , /*decltype(_impl_.num_bits_)*/0} {}
struct CSVCMsg_SendTable_sendprop_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SendTable_sendprop_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SendTable_sendprop_tDefaultTypeInternal() {}
  union {
    CSVCMsg_SendTable_sendprop_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SendTable_sendprop_tDefaultTypeInternal _CSVCMsg_SendTable_sendprop_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SendTable::CSVCMsg_SendTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.props_)*/{}
  , /*decltype(_impl_.net_table_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_end_)*/false
  , /*decltype(_impl_.needs_decoder_)*/false} {}
struct CSVCMsg_SendTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SendTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SendTableDefaultTypeInternal() {}
  union {
    CSVCMsg_SendTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SendTableDefaultTypeInternal _CSVCMsg_SendTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct CSVCMsg_GameEventList_key_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_key_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventList_key_tDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList_key_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventList_key_tDefaultTypeInternal _CSVCMsg_GameEventList_key_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.eventid_)*/0} {}
struct CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList_descriptor_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal _CSVCMsg_GameEventList_descriptor_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList::CSVCMsg_GameEventList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.descriptors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_GameEventListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventListDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventListDefaultTypeInternal _CSVCMsg_GameEventList_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_index_)*/0
  , /*decltype(_impl_.baseline_index_)*/0} {}
struct CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities_alternate_baseline_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal _CSVCMsg_PacketEntities_alternate_baseline_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_count_)*/0} {}
struct CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities_non_transmitted_entities_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal _CSVCMsg_PacketEntities_non_transmitted_entities_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alternate_baselines_)*/{}
  , /*decltype(_impl_.cmd_recv_status_)*/{}
  , /*decltype(_impl_._cmd_recv_status_cached_byte_size_)*/{0}
  , /*decltype(_impl_.entity_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serialized_entities_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_padding_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.non_transmitted_entities_)*/nullptr
  , /*decltype(_impl_.max_entries_)*/0
  , /*decltype(_impl_.updated_entries_)*/0
  , /*decltype(_impl_.baseline_)*/0
  , /*decltype(_impl_.legacy_is_delta_)*/false
  , /*decltype(_impl_.update_baseline_)*/false
  , /*decltype(_impl_.pending_full_frame_)*/false
  , /*decltype(_impl_.delta_from_)*/0
  , /*decltype(_impl_.active_spawngroup_handle_)*/0u
  , /*decltype(_impl_.max_spawngroup_creationsequence_)*/0u
  , /*decltype(_impl_.last_cmd_number_executed_)*/0u
  , /*decltype(_impl_.server_tick_)*/0u
  , /*decltype(_impl_.has_pvs_vis_bits_)*/0u
  , /*decltype(_impl_.last_cmd_number_recv_delta_)*/0
  , /*decltype(_impl_.cq_starved_command_ticks_)*/0u
  , /*decltype(_impl_.cq_discarded_command_ticks_)*/0u} {}
struct CSVCMsg_PacketEntitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntitiesDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntitiesDefaultTypeInternal _CSVCMsg_PacketEntities_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_TempEntities::CSVCMsg_TempEntities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reliable_)*/false
  , /*decltype(_impl_.num_entries_)*/0} {}
struct CSVCMsg_TempEntitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_TempEntitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_TempEntitiesDefaultTypeInternal() {}
  union {
    CSVCMsg_TempEntities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_TempEntitiesDefaultTypeInternal _CSVCMsg_TempEntities_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.string_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.num_entries_)*/0
  , /*decltype(_impl_.user_data_size_)*/0
  , /*decltype(_impl_.user_data_size_bits_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.user_data_fixed_size_)*/false
  , /*decltype(_impl_.data_compressed_)*/false
  , /*decltype(_impl_.using_varint_bitcounts_)*/false
  , /*decltype(_impl_.uncompressed_size_)*/0} {}
struct CSVCMsg_CreateStringTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CreateStringTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CreateStringTableDefaultTypeInternal() {}
  union {
    CSVCMsg_CreateStringTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CreateStringTableDefaultTypeInternal _CSVCMsg_CreateStringTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.string_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_id_)*/0
  , /*decltype(_impl_.num_changed_entries_)*/0} {}
struct CSVCMsg_UpdateStringTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_UpdateStringTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_UpdateStringTableDefaultTypeInternal() {}
  union {
    CSVCMsg_UpdateStringTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_UpdateStringTableDefaultTypeInternal _CSVCMsg_UpdateStringTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_VoiceData::CSVCMsg_VoiceData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.xuid_)*/uint64_t{0u}
  , /*decltype(_impl_.proximity_)*/false
  , /*decltype(_impl_.audible_mask_)*/0
  , /*decltype(_impl_.tick_)*/0u
  , /*decltype(_impl_.passthrough_)*/0
  , /*decltype(_impl_.client_)*/-1} {}
struct CSVCMsg_VoiceDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_VoiceDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_VoiceDataDefaultTypeInternal() {}
  union {
    CSVCMsg_VoiceData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_VoiceDataDefaultTypeInternal _CSVCMsg_VoiceData_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.messagessize_)*/0
  , /*decltype(_impl_.state_)*/false} {}
struct CSVCMsg_PacketReliableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketReliableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketReliableDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketReliable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketReliableDefaultTypeInternal _CSVCMsg_PacketReliable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.section_)*/0
  , /*decltype(_impl_.total_)*/0} {}
struct CSVCMsg_FullFrameSplitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FullFrameSplitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FullFrameSplitDefaultTypeInternal() {}
  union {
    CSVCMsg_FullFrameSplit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FullFrameSplitDefaultTypeInternal _CSVCMsg_FullFrameSplit_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clients_)*/0
  , /*decltype(_impl_.slots_)*/0
  , /*decltype(_impl_.proxies_)*/0} {}
struct CSVCMsg_HLTVStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HLTVStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HLTVStatusDefaultTypeInternal() {}
  union {
    CSVCMsg_HLTVStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HLTVStatusDefaultTypeInternal _CSVCMsg_HLTVStatus_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}} {}
struct CSVCMsg_ServerSteamIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ServerSteamIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ServerSteamIDDefaultTypeInternal() {}
  union {
    CSVCMsg_ServerSteamID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ServerSteamIDDefaultTypeInternal _CSVCMsg_ServerSteamID_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_CmdKeyValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CmdKeyValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CmdKeyValuesDefaultTypeInternal() {}
  union {
    CSVCMsg_CmdKeyValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CmdKeyValuesDefaultTypeInternal _CSVCMsg_CmdKeyValues_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.details_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_RconServerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_RconServerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_RconServerDetailsDefaultTypeInternal() {}
  union {
    CSVCMsg_RconServerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_RconServerDetailsDefaultTypeInternal _CSVCMsg_RconServerDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgIPCAddress::CMsgIPCAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.computer_guid_)*/uint64_t{0u}
  , /*decltype(_impl_.process_id_)*/0u} {}
struct CMsgIPCAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgIPCAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgIPCAddressDefaultTypeInternal() {}
  union {
    CMsgIPCAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgIPCAddressDefaultTypeInternal _CMsgIPCAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerPeer::CMsgServerPeer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipc_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.they_hear_you_)*/false
  , /*decltype(_impl_.you_hear_them_)*/false
  , /*decltype(_impl_.is_listenserver_host_)*/false
  , /*decltype(_impl_.player_slot_)*/-1} {}
struct CMsgServerPeerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerPeerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerPeerDefaultTypeInternal() {}
  union {
    CMsgServerPeer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerPeerDefaultTypeInternal _CMsgServerPeer_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PeerList::CSVCMsg_PeerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peer_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_PeerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PeerListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PeerListDefaultTypeInternal() {}
  union {
    CSVCMsg_PeerList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PeerListDefaultTypeInternal _CSVCMsg_PeerList_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mapname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.create_tables_skipped_)*/false} {}
struct CSVCMsg_ClearAllStringTablesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClearAllStringTablesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClearAllStringTablesDefaultTypeInternal() {}
  union {
    CSVCMsg_ClearAllStringTables _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClearAllStringTablesDefaultTypeInternal _CSVCMsg_ClearAllStringTables_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.polymorphic_field_serializer_name_sym_)*/0
  , /*decltype(_impl_.polymorphic_field_serializer_version_)*/0} {}
struct ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializerField_t_polymorphic_field_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal _ProtoFlattenedSerializerField_t_polymorphic_field_t_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.polymorphic_types_)*/{}
  , /*decltype(_impl_.var_type_sym_)*/0
  , /*decltype(_impl_.var_name_sym_)*/0
  , /*decltype(_impl_.bit_count_)*/0
  , /*decltype(_impl_.low_value_)*/0
  , /*decltype(_impl_.high_value_)*/0
  , /*decltype(_impl_.encode_flags_)*/0
  , /*decltype(_impl_.field_serializer_name_sym_)*/0
  , /*decltype(_impl_.field_serializer_version_)*/0
  , /*decltype(_impl_.send_node_sym_)*/0
  , /*decltype(_impl_.var_encoder_sym_)*/0
  , /*decltype(_impl_.var_serializer_sym_)*/0} {}
struct ProtoFlattenedSerializerField_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializerField_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializerField_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializerField_tDefaultTypeInternal _ProtoFlattenedSerializerField_t_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fields_index_)*/{}
  , /*decltype(_impl_.serializer_name_sym_)*/0
  , /*decltype(_impl_.serializer_version_)*/0} {}
struct ProtoFlattenedSerializer_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializer_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializer_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializer_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializer_tDefaultTypeInternal _ProtoFlattenedSerializer_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serializers_)*/{}
  , /*decltype(_impl_.symbols_)*/{}
  , /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_FlattenedSerializerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FlattenedSerializerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FlattenedSerializerDefaultTypeInternal() {}
  union {
    CSVCMsg_FlattenedSerializer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FlattenedSerializerDefaultTypeInternal _CSVCMsg_FlattenedSerializer_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_StopSound::CSVCMsg_StopSound(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guid_)*/0u} {}
struct CSVCMsg_StopSoundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_StopSoundDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_StopSoundDefaultTypeInternal() {}
  union {
    CSVCMsg_StopSound _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_StopSoundDefaultTypeInternal _CSVCMsg_StopSound_default_instance_;
PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.posttoserver_)*/false
  , /*decltype(_impl_.buftype_)*/0
  , /*decltype(_impl_.receivingclients_)*/uint64_t{0u}
  , /*decltype(_impl_.clientbitcount_)*/0u} {}
struct CBidirMsg_RebroadcastGameEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastGameEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBidirMsg_RebroadcastGameEventDefaultTypeInternal() {}
  union {
    CBidirMsg_RebroadcastGameEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBidirMsg_RebroadcastGameEventDefaultTypeInternal _CBidirMsg_RebroadcastGameEvent_default_instance_;
PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eventsource_)*/0} {}
struct CBidirMsg_RebroadcastSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBidirMsg_RebroadcastSourceDefaultTypeInternal() {}
  union {
    CBidirMsg_RebroadcastSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBidirMsg_RebroadcastSourceDefaultTypeInternal _CBidirMsg_RebroadcastSource_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0} {}
struct CMsgServerNetworkStats_PortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStats_PortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStats_PortDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats_Port _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStats_PortDefaultTypeInternal _CMsgServerNetworkStats_Port_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remote_addr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.ping_avg_ms_)*/0
  , /*decltype(_impl_.packet_loss_pct_)*/0
  , /*decltype(_impl_.is_bot_)*/false
  , /*decltype(_impl_.loss_in_)*/0
  , /*decltype(_impl_.loss_out_)*/0
  , /*decltype(_impl_.engine_latency_ms_)*/0} {}
struct CMsgServerNetworkStats_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStats_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStats_PlayerDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStats_PlayerDefaultTypeInternal _CMsgServerNetworkStats_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats::CMsgServerNetworkStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.dedicated_)*/false
  , /*decltype(_impl_.cpu_usage_)*/0
  , /*decltype(_impl_.memory_used_mb_)*/0
  , /*decltype(_impl_.memory_free_mb_)*/0
  , /*decltype(_impl_.uptime_)*/0
  , /*decltype(_impl_.spawn_count_)*/0
  , /*decltype(_impl_.num_clients_)*/0
  , /*decltype(_impl_.num_bots_)*/0
  , /*decltype(_impl_.num_spectators_)*/0
  , /*decltype(_impl_.num_tv_relays_)*/0
  , /*decltype(_impl_.fps_)*/0
  , /*decltype(_impl_.avg_ping_ms_)*/0
  , /*decltype(_impl_.avg_engine_latency_out_)*/0
  , /*decltype(_impl_.avg_packets_out_)*/0
  , /*decltype(_impl_.avg_packets_in_)*/0
  , /*decltype(_impl_.avg_loss_out_)*/0
  , /*decltype(_impl_.avg_loss_in_)*/0
  , /*decltype(_impl_.avg_data_out_)*/0
  , /*decltype(_impl_.total_data_in_)*/uint64_t{0u}
  , /*decltype(_impl_.total_packets_in_)*/uint64_t{0u}
  , /*decltype(_impl_.total_data_out_)*/uint64_t{0u}
  , /*decltype(_impl_.total_packets_out_)*/uint64_t{0u}
  , /*decltype(_impl_.avg_data_in_)*/0} {}
struct CMsgServerNetworkStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStatsDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStatsDefaultTypeInternal _CMsgServerNetworkStats_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.delay_)*/0
  , /*decltype(_impl_.replay_stop_at_)*/0
  , /*decltype(_impl_.replay_start_at_)*/0
  , /*decltype(_impl_.replay_slowdown_begin_)*/0
  , /*decltype(_impl_.replay_slowdown_end_)*/0
  , /*decltype(_impl_.replay_slowdown_rate_)*/0
  , /*decltype(_impl_.reason_)*/0
  , /*decltype(_impl_.primary_target_)*/-1} {}
struct CSVCMsg_HltvReplayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HltvReplayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HltvReplayDefaultTypeInternal() {}
  union {
    CSVCMsg_HltvReplay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HltvReplayDefaultTypeInternal _CSVCMsg_HltvReplay_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.request_)*/0
  , /*decltype(_impl_.slowdown_length_)*/0
  , /*decltype(_impl_.slowdown_rate_)*/0
  , /*decltype(_impl_.event_time_)*/0
  , /*decltype(_impl_.primary_target_)*/-1} {}
struct CCLCMsg_HltvReplayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_HltvReplayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_HltvReplayDefaultTypeInternal() {}
  union {
    CCLCMsg_HltvReplay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_HltvReplayDefaultTypeInternal _CCLCMsg_HltvReplay_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cmd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_Broadcast_CommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_Broadcast_CommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_Broadcast_CommandDefaultTypeInternal() {}
  union {
    CSVCMsg_Broadcast_Command _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_Broadcast_CommandDefaultTypeInternal _CSVCMsg_Broadcast_Command_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.props_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.eye_angles_)*/nullptr
  , /*decltype(_impl_.view_offset_)*/nullptr
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.observer_mode_)*/0
  , /*decltype(_impl_.cameraman_scoreboard_)*/false
  , /*decltype(_impl_.observer_target_)*/0} {}
struct CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal() {}
  union {
    CCLCMsg_HltvFixupOperatorTick _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal _CCLCMsg_HltvFixupOperatorTick_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.override_operator_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mode_)*/0u} {}
struct CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal() {}
  union {
    CSVCMsg_HltvFixupOperatorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal _CSVCMsg_HltvFixupOperatorStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerUserCmd::CMsgServerUserCmd(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cmd_number_)*/0
  , /*decltype(_impl_.server_tick_executed_)*/0
  , /*decltype(_impl_.client_tick_)*/0
  , /*decltype(_impl_.player_slot_)*/-1} {}
struct CMsgServerUserCmdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerUserCmdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerUserCmdDefaultTypeInternal() {}
  union {
    CMsgServerUserCmd _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerUserCmdDefaultTypeInternal _CMsgServerUserCmd_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_UserCommands::CSVCMsg_UserCommands(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_UserCommandsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_UserCommandsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_UserCommandsDefaultTypeInternal() {}
  union {
    CSVCMsg_UserCommands _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_UserCommandsDefaultTypeInternal _CSVCMsg_UserCommands_default_instance_;
static ::_pb::Metadata file_level_metadata_netmessages_2eproto[77];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_netmessages_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_netmessages_2eproto = nullptr;

const uint32_t TableStruct_netmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.send_table_crc_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.server_count_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.is_hltv_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.friends_id_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.friends_name_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_.last_command_number_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.voice_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.sequence_bytes_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.section_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.uncompressed_sample_offset_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.num_packets_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.packet_offsets_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.voice_level_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  7,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.xuid_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.tick_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_.baseline_tick_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_.baseline_nr_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ListenEvents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ListenEvents, _impl_.event_mask_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.cookie_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.status_code_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.value_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.code_path_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.code_filename_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.crc_),
  2,
  0,
  3,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _impl_.progress_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _impl_.playername_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _impl_.slot_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _impl_.simplified_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_.pause_type_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_.pause_group_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _impl_.token_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.cpu_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.cpu_brand_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.cpu_model_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.cpu_num_physical_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.ram_physical_total_mb_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_rendersystem_dll_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_vendor_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_driver_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_driver_version_high_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_driver_version_low_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_dx_support_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2SystemSpecs, _impl_.gpu_texture_memory_size_mb_),
  0,
  1,
  4,
  5,
  6,
  2,
  7,
  3,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.active_samples_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_avg_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_p50_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_p99_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_avg_all_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_p50_all_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReportItem, _impl_.usec_p99_all_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReport, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReport, _impl_.total_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReport, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::CMsgSource2VProfLiteReport, _impl_.discarded_frames_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Diagnostic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Diagnostic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Diagnostic, _impl_.system_specs_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Diagnostic, _impl_.vprof_report_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.system_specs_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.profile_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.build_id_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.steamid_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.server_build_id_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.server_profile_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.clients_),
  PROTOBUF_FIELD_OFFSET(::CSource2Metrics_MatchPerfSummary_Notification, _impl_.map_),
  3,
  0,
  4,
  2,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.server_count_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.is_dedicated_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.is_hltv_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.c_os_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.max_clients_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.max_classes_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.tick_interval_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_dir_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.map_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.sky_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.host_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.addon_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_session_config_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_session_manifest_),
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  15,
  14,
  0,
  1,
  2,
  3,
  4,
  6,
  5,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_.class_id_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_.class_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_.create_on_client_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_.classes_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _impl_.paused_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.codec_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.version_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _impl_.text_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_x_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_y_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_z_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.delay_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sequence_number_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_num_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_num_handle_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.speaker_entity_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_level_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.is_sentence_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.is_ambient_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_resource_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  18,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_.reliable_sound_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_.sounds_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_.sound_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_.resource_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_.slot_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_.relative_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_.angle_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _impl_.angle_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.decal_texture_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.model_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.low_priority_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.player_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_.cookie_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_.cvar_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_.dialog_type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_.menu_key_values_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.msg_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.passthrough_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.var_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.dt_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.num_elements_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.low_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.high_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.num_bits_),
  2,
  0,
  3,
  4,
  1,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.is_end_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.net_table_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.needs_decoder_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.props_),
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.eventid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.keys_),
  1,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList, _impl_.descriptors_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.baseline_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_.header_count_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_.data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.max_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.updated_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.legacy_is_delta_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.update_baseline_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.baseline_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.delta_from_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.entity_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.pending_full_frame_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.active_spawngroup_handle_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.max_spawngroup_creationsequence_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.last_cmd_number_executed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.last_cmd_number_recv_delta_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.server_tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.serialized_entities_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.alternate_baselines_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.has_pvs_vis_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.cmd_recv_status_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.non_transmitted_entities_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.cq_starved_command_ticks_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.cq_discarded_command_ticks_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.dev_padding_),
  4,
  5,
  7,
  8,
  6,
  10,
  0,
  9,
  11,
  12,
  13,
  16,
  14,
  1,
  ~0u,
  15,
  ~0u,
  3,
  17,
  18,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.reliable_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.num_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.entity_data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.num_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_fixed_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_size_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.string_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.uncompressed_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.data_compressed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.using_varint_bitcounts_),
  0,
  2,
  6,
  3,
  4,
  5,
  1,
  9,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.table_id_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.num_changed_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.string_data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.client_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.proximity_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.xuid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.audible_mask_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.passthrough_),
  0,
  6,
  2,
  1,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.messagessize_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.state_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.section_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.total_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.data_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.master_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.clients_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.slots_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.proxies_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _impl_.steam_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_.token_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_.details_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_.computer_guid_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_.process_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.ipc_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.they_hear_you_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.you_hear_them_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.is_listenserver_host_),
  5,
  1,
  0,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PeerList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PeerList, _impl_.peer_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_.mapname_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_.create_tables_skipped_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_version_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_type_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.bit_count_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.low_value_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.high_value_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.encode_flags_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.field_serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.field_serializer_version_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.send_node_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_encoder_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.polymorphic_types_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_serializer_sym_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  10,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.serializer_version_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.fields_index_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.serializers_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.symbols_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.fields_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _impl_.guid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.posttoserver_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.buftype_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.clientbitcount_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.receivingclients_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _impl_.eventsource_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.remote_addr_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.ping_avg_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.packet_loss_pct_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.is_bot_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.loss_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.loss_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.engine_latency_ms_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.dedicated_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.cpu_usage_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.memory_used_mb_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.memory_free_mb_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.uptime_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.spawn_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_clients_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_bots_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_spectators_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_tv_relays_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.fps_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_engine_latency_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_packets_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_packets_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_loss_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_loss_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_data_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_data_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_data_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_packets_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_data_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_packets_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.players_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  ~0u,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  22,
  18,
  19,
  20,
  21,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.primary_target_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_stop_at_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_start_at_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_begin_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_end_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_rate_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.reason_),
  0,
  7,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.request_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.slowdown_length_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.slowdown_rate_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.primary_target_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.event_time_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _impl_.cmd_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.props_data_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.eye_angles_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.observer_mode_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.cameraman_scoreboard_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.observer_target_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.view_offset_),
  4,
  0,
  1,
  2,
  5,
  6,
  7,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_.override_operator_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_.cmd_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_.server_tick_executed_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerUserCmd, _impl_.client_tick_),
  0,
  1,
  4,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserCommands, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserCommands, _impl_.commands_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::CCLCMsg_ClientInfo)},
  { 16, 24, -1, sizeof(::CCLCMsg_Move)},
  { 26, 41, -1, sizeof(::CMsgVoiceAudio)},
  { 50, 59, -1, sizeof(::CCLCMsg_VoiceData)},
  { 62, 70, -1, sizeof(::CCLCMsg_BaselineAck)},
  { 72, -1, -1, sizeof(::CCLCMsg_ListenEvents)},
  { 79, 89, -1, sizeof(::CCLCMsg_RespondCvarValue)},
  { 93, 104, -1, sizeof(::CCLCMsg_FileCRCCheck)},
  { 109, 116, -1, sizeof(::CCLCMsg_LoadingProgress)},
  { 117, 124, -1, sizeof(::CCLCMsg_SplitPlayerConnect)},
  { 125, 132, -1, sizeof(::CCLCMsg_SplitPlayerDisconnect)},
  { 133, 140, -1, sizeof(::CCLCMsg_ServerStatus)},
  { 141, 149, -1, sizeof(::CCLCMsg_RequestPause)},
  { 151, 158, -1, sizeof(::CCLCMsg_CmdKeyValues)},
  { 159, 166, -1, sizeof(::CCLCMsg_RconServerDetails)},
  { 167, 185, -1, sizeof(::CMsgSource2SystemSpecs)},
  { 197, 212, -1, sizeof(::CMsgSource2VProfLiteReportItem)},
  { 221, 230, -1, sizeof(::CMsgSource2VProfLiteReport)},
  { 233, 241, -1, sizeof(::CCLCMsg_Diagnostic)},
  { 243, 253, -1, sizeof(::CSource2Metrics_MatchPerfSummary_Notification_Client)},
  { 257, 269, -1, sizeof(::CSource2Metrics_MatchPerfSummary_Notification)},
  { 275, 297, -1, sizeof(::CSVCMsg_ServerInfo)},
  { 313, 321, -1, sizeof(::CSVCMsg_ClassInfo_class_t)},
  { 323, 331, -1, sizeof(::CSVCMsg_ClassInfo)},
  { 333, 340, -1, sizeof(::CSVCMsg_SetPause)},
  { 341, 350, -1, sizeof(::CSVCMsg_VoiceInit)},
  { 353, 360, -1, sizeof(::CSVCMsg_Print)},
  { 361, 386, -1, sizeof(::CSVCMsg_Sounds_sounddata_t)},
  { 405, 413, -1, sizeof(::CSVCMsg_Sounds)},
  { 415, 423, -1, sizeof(::CSVCMsg_Prefetch)},
  { 425, 433, -1, sizeof(::CSVCMsg_SetView)},
  { 435, 443, -1, sizeof(::CSVCMsg_FixAngle)},
  { 445, 452, -1, sizeof(::CSVCMsg_CrosshairAngle)},
  { 453, 464, -1, sizeof(::CSVCMsg_BSPDecal)},
  { 469, 478, -1, sizeof(::CSVCMsg_SplitScreen)},
  { 481, 489, -1, sizeof(::CSVCMsg_GetCvarValue)},
  { 491, 499, -1, sizeof(::CSVCMsg_Menu)},
  { 501, 510, -1, sizeof(::CSVCMsg_UserMessage)},
  { 513, 528, -1, sizeof(::CSVCMsg_SendTable_sendprop_t)},
  { 537, 547, -1, sizeof(::CSVCMsg_SendTable)},
  { 551, 559, -1, sizeof(::CSVCMsg_GameEventList_key_t)},
  { 561, 570, -1, sizeof(::CSVCMsg_GameEventList_descriptor_t)},
  { 573, -1, -1, sizeof(::CSVCMsg_GameEventList)},
  { 580, 588, -1, sizeof(::CSVCMsg_PacketEntities_alternate_baseline_t)},
  { 590, 598, -1, sizeof(::CSVCMsg_PacketEntities_non_transmitted_entities_t)},
  { 600, 627, -1, sizeof(::CSVCMsg_PacketEntities)},
  { 648, 657, -1, sizeof(::CSVCMsg_TempEntities)},
  { 660, 676, -1, sizeof(::CSVCMsg_CreateStringTable)},
  { 686, 695, -1, sizeof(::CSVCMsg_UpdateStringTable)},
  { 698, 711, -1, sizeof(::CSVCMsg_VoiceData)},
  { 718, 727, -1, sizeof(::CSVCMsg_PacketReliable)},
  { 730, 740, -1, sizeof(::CSVCMsg_FullFrameSplit)},
  { 744, 754, -1, sizeof(::CSVCMsg_HLTVStatus)},
  { 758, 765, -1, sizeof(::CSVCMsg_ServerSteamID)},
  { 766, 773, -1, sizeof(::CSVCMsg_CmdKeyValues)},
  { 774, 782, -1, sizeof(::CSVCMsg_RconServerDetails)},
  { 784, 792, -1, sizeof(::CMsgIPCAddress)},
  { 794, 806, -1, sizeof(::CMsgServerPeer)},
  { 812, -1, -1, sizeof(::CSVCMsg_PeerList)},
  { 819, 827, -1, sizeof(::CSVCMsg_ClearAllStringTables)},
  { 829, 837, -1, sizeof(::ProtoFlattenedSerializerField_t_polymorphic_field_t)},
  { 839, 857, -1, sizeof(::ProtoFlattenedSerializerField_t)},
  { 869, 878, -1, sizeof(::ProtoFlattenedSerializer_t)},
  { 881, -1, -1, sizeof(::CSVCMsg_FlattenedSerializer)},
  { 890, 897, -1, sizeof(::CSVCMsg_StopSound)},
  { 898, 908, -1, sizeof(::CBidirMsg_RebroadcastGameEvent)},
  { 912, 919, -1, sizeof(::CBidirMsg_RebroadcastSource)},
  { 920, 928, -1, sizeof(::CMsgServerNetworkStats_Port)},
  { 930, 944, -1, sizeof(::CMsgServerNetworkStats_Player)},
  { 952, 983, -1, sizeof(::CMsgServerNetworkStats)},
  { 1008, 1022, -1, sizeof(::CSVCMsg_HltvReplay)},
  { 1030, 1041, -1, sizeof(::CCLCMsg_HltvReplay)},
  { 1046, 1053, -1, sizeof(::CSVCMsg_Broadcast_Command)},
  { 1054, 1068, -1, sizeof(::CCLCMsg_HltvFixupOperatorTick)},
  { 1076, 1084, -1, sizeof(::CSVCMsg_HltvFixupOperatorStatus)},
  { 1086, 1097, -1, sizeof(::CMsgServerUserCmd)},
  { 1102, -1, -1, sizeof(::CSVCMsg_UserCommands)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CCLCMsg_ClientInfo_default_instance_._instance,
  &::_CCLCMsg_Move_default_instance_._instance,
  &::_CMsgVoiceAudio_default_instance_._instance,
  &::_CCLCMsg_VoiceData_default_instance_._instance,
  &::_CCLCMsg_BaselineAck_default_instance_._instance,
  &::_CCLCMsg_ListenEvents_default_instance_._instance,
  &::_CCLCMsg_RespondCvarValue_default_instance_._instance,
  &::_CCLCMsg_FileCRCCheck_default_instance_._instance,
  &::_CCLCMsg_LoadingProgress_default_instance_._instance,
  &::_CCLCMsg_SplitPlayerConnect_default_instance_._instance,
  &::_CCLCMsg_SplitPlayerDisconnect_default_instance_._instance,
  &::_CCLCMsg_ServerStatus_default_instance_._instance,
  &::_CCLCMsg_RequestPause_default_instance_._instance,
  &::_CCLCMsg_CmdKeyValues_default_instance_._instance,
  &::_CCLCMsg_RconServerDetails_default_instance_._instance,
  &::_CMsgSource2SystemSpecs_default_instance_._instance,
  &::_CMsgSource2VProfLiteReportItem_default_instance_._instance,
  &::_CMsgSource2VProfLiteReport_default_instance_._instance,
  &::_CCLCMsg_Diagnostic_default_instance_._instance,
  &::_CSource2Metrics_MatchPerfSummary_Notification_Client_default_instance_._instance,
  &::_CSource2Metrics_MatchPerfSummary_Notification_default_instance_._instance,
  &::_CSVCMsg_ServerInfo_default_instance_._instance,
  &::_CSVCMsg_ClassInfo_class_t_default_instance_._instance,
  &::_CSVCMsg_ClassInfo_default_instance_._instance,
  &::_CSVCMsg_SetPause_default_instance_._instance,
  &::_CSVCMsg_VoiceInit_default_instance_._instance,
  &::_CSVCMsg_Print_default_instance_._instance,
  &::_CSVCMsg_Sounds_sounddata_t_default_instance_._instance,
  &::_CSVCMsg_Sounds_default_instance_._instance,
  &::_CSVCMsg_Prefetch_default_instance_._instance,
  &::_CSVCMsg_SetView_default_instance_._instance,
  &::_CSVCMsg_FixAngle_default_instance_._instance,
  &::_CSVCMsg_CrosshairAngle_default_instance_._instance,
  &::_CSVCMsg_BSPDecal_default_instance_._instance,
  &::_CSVCMsg_SplitScreen_default_instance_._instance,
  &::_CSVCMsg_GetCvarValue_default_instance_._instance,
  &::_CSVCMsg_Menu_default_instance_._instance,
  &::_CSVCMsg_UserMessage_default_instance_._instance,
  &::_CSVCMsg_SendTable_sendprop_t_default_instance_._instance,
  &::_CSVCMsg_SendTable_default_instance_._instance,
  &::_CSVCMsg_GameEventList_key_t_default_instance_._instance,
  &::_CSVCMsg_GameEventList_descriptor_t_default_instance_._instance,
  &::_CSVCMsg_GameEventList_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_alternate_baseline_t_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_non_transmitted_entities_t_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_default_instance_._instance,
  &::_CSVCMsg_TempEntities_default_instance_._instance,
  &::_CSVCMsg_CreateStringTable_default_instance_._instance,
  &::_CSVCMsg_UpdateStringTable_default_instance_._instance,
  &::_CSVCMsg_VoiceData_default_instance_._instance,
  &::_CSVCMsg_PacketReliable_default_instance_._instance,
  &::_CSVCMsg_FullFrameSplit_default_instance_._instance,
  &::_CSVCMsg_HLTVStatus_default_instance_._instance,
  &::_CSVCMsg_ServerSteamID_default_instance_._instance,
  &::_CSVCMsg_CmdKeyValues_default_instance_._instance,
  &::_CSVCMsg_RconServerDetails_default_instance_._instance,
  &::_CMsgIPCAddress_default_instance_._instance,
  &::_CMsgServerPeer_default_instance_._instance,
  &::_CSVCMsg_PeerList_default_instance_._instance,
  &::_CSVCMsg_ClearAllStringTables_default_instance_._instance,
  &::_ProtoFlattenedSerializerField_t_polymorphic_field_t_default_instance_._instance,
  &::_ProtoFlattenedSerializerField_t_default_instance_._instance,
  &::_ProtoFlattenedSerializer_t_default_instance_._instance,
  &::_CSVCMsg_FlattenedSerializer_default_instance_._instance,
  &::_CSVCMsg_StopSound_default_instance_._instance,
  &::_CBidirMsg_RebroadcastGameEvent_default_instance_._instance,
  &::_CBidirMsg_RebroadcastSource_default_instance_._instance,
  &::_CMsgServerNetworkStats_Port_default_instance_._instance,
  &::_CMsgServerNetworkStats_Player_default_instance_._instance,
  &::_CMsgServerNetworkStats_default_instance_._instance,
  &::_CSVCMsg_HltvReplay_default_instance_._instance,
  &::_CCLCMsg_HltvReplay_default_instance_._instance,
  &::_CSVCMsg_Broadcast_Command_default_instance_._instance,
  &::_CCLCMsg_HltvFixupOperatorTick_default_instance_._instance,
  &::_CSVCMsg_HltvFixupOperatorStatus_default_instance_._instance,
  &::_CMsgServerUserCmd_default_instance_._instance,
  &::_CSVCMsg_UserCommands_default_instance_._instance,
};

const char descriptor_table_protodef_netmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021netmessages.proto\032\026networkbasetypes.pr"
  "oto\"}\n\022CCLCMsg_ClientInfo\022\026\n\016send_table_"
  "crc\030\001 \001(\007\022\024\n\014server_count\030\002 \001(\r\022\017\n\007is_hl"
  "tv\030\003 \001(\010\022\022\n\nfriends_id\030\005 \001(\r\022\024\n\014friends_"
  "name\030\006 \001(\t\"9\n\014CCLCMsg_Move\022\014\n\004data\030\003 \001(\014"
  "\022\033\n\023last_command_number\030\004 \001(\r\"\217\002\n\016CMsgVo"
  "iceAudio\022:\n\006format\030\001 \001(\0162\022.VoiceDataForm"
  "at_t:\026VOICEDATA_FORMAT_STEAM\022\022\n\nvoice_da"
  "ta\030\002 \001(\014\022\026\n\016sequence_bytes\030\003 \001(\005\022\026\n\016sect"
  "ion_number\030\004 \001(\r\022\023\n\013sample_rate\030\005 \001(\r\022\"\n"
  "\032uncompressed_sample_offset\030\006 \001(\r\022\023\n\013num"
  "_packets\030\007 \001(\r\022\032\n\016packet_offsets\030\010 \003(\rB\002"
  "\020\001\022\023\n\013voice_level\030\t \001(\002\"O\n\021CCLCMsg_Voice"
  "Data\022\036\n\005audio\030\001 \001(\0132\017.CMsgVoiceAudio\022\014\n\004"
  "xuid\030\002 \001(\006\022\014\n\004tick\030\003 \001(\r\"A\n\023CCLCMsg_Base"
  "lineAck\022\025\n\rbaseline_tick\030\001 \001(\005\022\023\n\013baseli"
  "ne_nr\030\002 \001(\005\"*\n\024CCLCMsg_ListenEvents\022\022\n\ne"
  "vent_mask\030\001 \003(\007\"\\\n\030CCLCMsg_RespondCvarVa"
  "lue\022\016\n\006cookie\030\001 \001(\005\022\023\n\013status_code\030\002 \001(\005"
  "\022\014\n\004name\030\003 \001(\t\022\r\n\005value\030\004 \001(\t\"m\n\024CCLCMsg"
  "_FileCRCCheck\022\021\n\tcode_path\030\001 \001(\005\022\014\n\004path"
  "\030\002 \001(\t\022\025\n\rcode_filename\030\003 \001(\005\022\020\n\010filenam"
  "e\030\004 \001(\t\022\013\n\003crc\030\005 \001(\007\"+\n\027CCLCMsg_LoadingP"
  "rogress\022\020\n\010progress\030\001 \001(\005\"0\n\032CCLCMsg_Spl"
  "itPlayerConnect\022\022\n\nplayername\030\001 \001(\t\"-\n\035C"
  "CLCMsg_SplitPlayerDisconnect\022\014\n\004slot\030\001 \001"
  "(\005\"*\n\024CCLCMsg_ServerStatus\022\022\n\nsimplified"
  "\030\001 \001(\010\"Z\n\024CCLCMsg_RequestPause\022-\n\npause_"
  "type\030\001 \001(\0162\017.RequestPause_t:\010RP_PAUSE\022\023\n"
  "\013pause_group\030\002 \001(\005\"$\n\024CCLCMsg_CmdKeyValu"
  "es\022\014\n\004data\030\001 \001(\014\"*\n\031CCLCMsg_RconServerDe"
  "tails\022\r\n\005token\030\001 \001(\014\"\335\002\n\026CMsgSource2Syst"
  "emSpecs\022\016\n\006cpu_id\030\001 \001(\t\022\021\n\tcpu_brand\030\002 \001"
  "(\t\022\021\n\tcpu_model\030\003 \001(\r\022\030\n\020cpu_num_physica"
  "l\030\004 \001(\r\022\035\n\025ram_physical_total_mb\030\025 \001(\r\022!"
  "\n\031gpu_rendersystem_dll_name\030) \001(\t\022\025\n\rgpu"
  "_vendor_id\030* \001(\r\022\027\n\017gpu_driver_name\030+ \001("
  "\t\022\037\n\027gpu_driver_version_high\030, \001(\r\022\036\n\026gp"
  "u_driver_version_low\030- \001(\r\022\034\n\024gpu_dx_sup"
  "port_level\030. \001(\r\022\"\n\032gpu_texture_memory_s"
  "ize_mb\030/ \001(\r\"\345\001\n\036CMsgSource2VProfLiteRep"
  "ortItem\022\014\n\004name\030\001 \001(\t\022\026\n\016active_samples\030"
  "\002 \001(\r\022\020\n\010usec_max\030\003 \001(\r\022\027\n\017usec_avg_acti"
  "ve\030\013 \001(\r\022\027\n\017usec_p50_active\030\014 \001(\r\022\027\n\017use"
  "c_p99_active\030\r \001(\r\022\024\n\014usec_avg_all\030\025 \001(\r"
  "\022\024\n\014usec_p50_all\030\026 \001(\r\022\024\n\014usec_p99_all\030\027"
  " \001(\r\"\226\001\n\032CMsgSource2VProfLiteReport\022.\n\005t"
  "otal\030\001 \001(\0132\037.CMsgSource2VProfLiteReportI"
  "tem\022.\n\005items\030\002 \003(\0132\037.CMsgSource2VProfLit"
  "eReportItem\022\030\n\020discarded_frames\030\003 \001(\r\"v\n"
  "\022CCLCMsg_Diagnostic\022-\n\014system_specs\030\001 \001("
  "\0132\027.CMsgSource2SystemSpecs\0221\n\014vprof_repo"
  "rt\030\002 \001(\0132\033.CMsgSource2VProfLiteReport\"\377\002"
  "\n-CSource2Metrics_MatchPerfSummary_Notif"
  "ication\022\r\n\005appid\030\001 \001(\r\022\021\n\tgame_mode\030\002 \001("
  "\t\022\027\n\017server_build_id\030\003 \001(\r\0223\n\016server_pro"
  "file\030\n \001(\0132\033.CMsgSource2VProfLiteReport\022"
  "F\n\007clients\030\013 \003(\01325.CSource2Metrics_Match"
  "PerfSummary_Notification.Client\022\013\n\003map\030\024"
  " \001(\t\032\210\001\n\006Client\022-\n\014system_specs\030\001 \001(\0132\027."
  "CMsgSource2SystemSpecs\022,\n\007profile\030\002 \001(\0132"
  "\033.CMsgSource2VProfLiteReport\022\020\n\010build_id"
  "\030\003 \001(\r\022\017\n\007steamid\030\n \001(\006\"\207\003\n\022CSVCMsg_Serv"
  "erInfo\022\020\n\010protocol\030\001 \001(\005\022\024\n\014server_count"
  "\030\002 \001(\005\022\024\n\014is_dedicated\030\003 \001(\010\022\017\n\007is_hltv\030"
  "\004 \001(\010\022\014\n\004c_os\030\006 \001(\005\022\023\n\013max_clients\030\n \001(\005"
  "\022\023\n\013max_classes\030\013 \001(\005\022\027\n\013player_slot\030\014 \001"
  "(\005:\002-1\022\025\n\rtick_interval\030\r \001(\002\022\020\n\010game_di"
  "r\030\016 \001(\t\022\020\n\010map_name\030\017 \001(\t\022\020\n\010sky_name\030\020 "
  "\001(\t\022\021\n\thost_name\030\021 \001(\t\022\022\n\naddon_name\030\022 \001"
  "(\t\022>\n\023game_session_config\030\023 \001(\0132!.CSVCMs"
  "g_GameSessionConfiguration\022\035\n\025game_sessi"
  "on_manifest\030\024 \001(\014\"\213\001\n\021CSVCMsg_ClassInfo\022"
  "\030\n\020create_on_client\030\001 \001(\010\022+\n\007classes\030\002 \003"
  "(\0132\032.CSVCMsg_ClassInfo.class_t\032/\n\007class_"
  "t\022\020\n\010class_id\030\001 \001(\005\022\022\n\nclass_name\030\003 \001(\t\""
  "\"\n\020CSVCMsg_SetPause\022\016\n\006paused\030\001 \001(\010\"G\n\021C"
  "SVCMsg_VoiceInit\022\017\n\007quality\030\001 \001(\005\022\r\n\005cod"
  "ec\030\002 \001(\t\022\022\n\007version\030\003 \001(\005:\0010\"\035\n\rCSVCMsg_"
  "Print\022\014\n\004text\030\001 \001(\t\"\343\003\n\016CSVCMsg_Sounds\022\026"
  "\n\016reliable_sound\030\001 \001(\010\022+\n\006sounds\030\002 \003(\0132\033"
  ".CSVCMsg_Sounds.sounddata_t\032\213\003\n\013sounddat"
  "a_t\022\020\n\010origin_x\030\001 \001(\021\022\020\n\010origin_y\030\002 \001(\021\022"
  "\020\n\010origin_z\030\003 \001(\021\022\016\n\006volume\030\004 \001(\r\022\023\n\013del"
  "ay_value\030\005 \001(\002\022\027\n\017sequence_number\030\006 \001(\005\022"
  "\030\n\014entity_index\030\007 \001(\005:\002-1\022\017\n\007channel\030\010 \001"
  "(\005\022\r\n\005pitch\030\t \001(\005\022\r\n\005flags\030\n \001(\005\022\021\n\tsoun"
  "d_num\030\013 \001(\r\022\030\n\020sound_num_handle\030\014 \001(\007\022\026\n"
  "\016speaker_entity\030\r \001(\005\022\023\n\013random_seed\030\016 \001"
  "(\005\022\023\n\013sound_level\030\017 \001(\005\022\023\n\013is_sentence\030\020"
  " \001(\010\022\022\n\nis_ambient\030\021 \001(\010\022\014\n\004guid\030\022 \001(\r\022\031"
  "\n\021sound_resource_id\030\023 \001(\006\"X\n\020CSVCMsg_Pre"
  "fetch\022\023\n\013sound_index\030\001 \001(\005\022/\n\rresource_t"
  "ype\030\002 \001(\0162\r.PrefetchType:\tPFT_SOUND\"=\n\017C"
  "SVCMsg_SetView\022\030\n\014entity_index\030\001 \001(\005:\002-1"
  "\022\020\n\004slot\030\002 \001(\005:\002-1\"@\n\020CSVCMsg_FixAngle\022\020"
  "\n\010relative\030\001 \001(\010\022\032\n\005angle\030\002 \001(\0132\013.CMsgQA"
  "ngle\"4\n\026CSVCMsg_CrosshairAngle\022\032\n\005angle\030"
  "\001 \001(\0132\013.CMsgQAngle\"\216\001\n\020CSVCMsg_BSPDecal\022"
  "\030\n\003pos\030\001 \001(\0132\013.CMsgVector\022\033\n\023decal_textu"
  "re_index\030\002 \001(\005\022\030\n\014entity_index\030\003 \001(\005:\002-1"
  "\022\023\n\013model_index\030\004 \001(\005\022\024\n\014low_priority\030\005 "
  "\001(\010\"~\n\023CSVCMsg_SplitScreen\022\?\n\004type\030\001 \001(\016"
  "2\030.ESplitScreenMessageType:\027MSG_SPLITSCR"
  "EEN_ADDUSER\022\014\n\004slot\030\002 \001(\005\022\030\n\014player_inde"
  "x\030\003 \001(\005:\002-1\"9\n\024CSVCMsg_GetCvarValue\022\016\n\006c"
  "ookie\030\001 \001(\005\022\021\n\tcvar_name\030\002 \001(\t\"<\n\014CSVCMs"
  "g_Menu\022\023\n\013dialog_type\030\001 \001(\005\022\027\n\017menu_key_"
  "values\030\002 \001(\014\"N\n\023CSVCMsg_UserMessage\022\020\n\010m"
  "sg_type\030\001 \001(\005\022\020\n\010msg_data\030\002 \001(\014\022\023\n\013passt"
  "hrough\030\003 \001(\005\"\260\002\n\021CSVCMsg_SendTable\022\016\n\006is"
  "_end\030\001 \001(\010\022\026\n\016net_table_name\030\002 \001(\t\022\025\n\rne"
  "eds_decoder\030\003 \001(\010\022,\n\005props\030\004 \003(\0132\035.CSVCM"
  "sg_SendTable.sendprop_t\032\255\001\n\nsendprop_t\022\014"
  "\n\004type\030\001 \001(\005\022\020\n\010var_name\030\002 \001(\t\022\r\n\005flags\030"
  "\003 \001(\005\022\020\n\010priority\030\004 \001(\005\022\017\n\007dt_name\030\005 \001(\t"
  "\022\024\n\014num_elements\030\006 \001(\005\022\021\n\tlow_value\030\007 \001("
  "\002\022\022\n\nhigh_value\030\010 \001(\002\022\020\n\010num_bits\030\t \001(\005\""
  "\321\001\n\025CSVCMsg_GameEventList\0228\n\013descriptors"
  "\030\001 \003(\0132#.CSVCMsg_GameEventList.descripto"
  "r_t\032#\n\005key_t\022\014\n\004type\030\001 \001(\005\022\014\n\004name\030\002 \001(\t"
  "\032Y\n\014descriptor_t\022\017\n\007eventid\030\001 \001(\005\022\014\n\004nam"
  "e\030\002 \001(\t\022*\n\004keys\030\003 \003(\0132\034.CSVCMsg_GameEven"
  "tList.key_t\"\316\006\n\026CSVCMsg_PacketEntities\022\023"
  "\n\013max_entries\030\001 \001(\005\022\027\n\017updated_entries\030\002"
  " \001(\005\022\027\n\017legacy_is_delta\030\003 \001(\010\022\027\n\017update_"
  "baseline\030\004 \001(\010\022\020\n\010baseline\030\005 \001(\005\022\022\n\ndelt"
  "a_from\030\006 \001(\005\022\023\n\013entity_data\030\007 \001(\014\022\032\n\022pen"
  "ding_full_frame\030\010 \001(\010\022 \n\030active_spawngro"
  "up_handle\030\t \001(\r\022\'\n\037max_spawngroup_creati"
  "onsequence\030\n \001(\r\022 \n\030last_cmd_number_exec"
  "uted\030\013 \001(\r\022\"\n\032last_cmd_number_recv_delta"
  "\030\021 \001(\021\022\023\n\013server_tick\030\014 \001(\r\022\033\n\023serialize"
  "d_entities\030\r \001(\014\022I\n\023alternate_baselines\030"
  "\017 \003(\0132,.CSVCMsg_PacketEntities.alternate"
  "_baseline_t\022\030\n\020has_pvs_vis_bits\030\020 \001(\r\022\033\n"
  "\017cmd_recv_status\030\026 \003(\021B\002\020\001\022T\n\030non_transm"
  "itted_entities\030\023 \001(\01322.CSVCMsg_PacketEnt"
  "ities.non_transmitted_entities_t\022 \n\030cq_s"
  "tarved_command_ticks\030\024 \001(\r\022\"\n\032cq_discard"
  "ed_command_ticks\030\025 \001(\r\022\024\n\013dev_padding\030\347\007"
  " \001(\014\032D\n\024alternate_baseline_t\022\024\n\014entity_i"
  "ndex\030\001 \001(\005\022\026\n\016baseline_index\030\002 \001(\005\032@\n\032no"
  "n_transmitted_entities_t\022\024\n\014header_count"
  "\030\001 \001(\005\022\014\n\004data\030\002 \001(\014\"R\n\024CSVCMsg_TempEnti"
  "ties\022\020\n\010reliable\030\001 \001(\010\022\023\n\013num_entries\030\002 "
  "\001(\005\022\023\n\013entity_data\030\003 \001(\014\"\211\002\n\031CSVCMsg_Cre"
  "ateStringTable\022\014\n\004name\030\001 \001(\t\022\023\n\013num_entr"
  "ies\030\002 \001(\005\022\034\n\024user_data_fixed_size\030\003 \001(\010\022"
  "\026\n\016user_data_size\030\004 \001(\005\022\033\n\023user_data_siz"
  "e_bits\030\005 \001(\005\022\r\n\005flags\030\006 \001(\005\022\023\n\013string_da"
  "ta\030\007 \001(\014\022\031\n\021uncompressed_size\030\010 \001(\005\022\027\n\017d"
  "ata_compressed\030\t \001(\010\022\036\n\026using_varint_bit"
  "counts\030\n \001(\010\"_\n\031CSVCMsg_UpdateStringTabl"
  "e\022\020\n\010table_id\030\001 \001(\005\022\033\n\023num_changed_entri"
  "es\030\002 \001(\005\022\023\n\013string_data\030\003 \001(\014\"\241\001\n\021CSVCMs"
  "g_VoiceData\022\036\n\005audio\030\001 \001(\0132\017.CMsgVoiceAu"
  "dio\022\022\n\006client\030\002 \001(\005:\002-1\022\021\n\tproximity\030\003 \001"
  "(\010\022\014\n\004xuid\030\004 \001(\006\022\024\n\014audible_mask\030\005 \001(\005\022\014"
  "\n\004tick\030\006 \001(\r\022\023\n\013passthrough\030\007 \001(\005\"K\n\026CSV"
  "CMsg_PacketReliable\022\014\n\004tick\030\001 \001(\005\022\024\n\014mes"
  "sagessize\030\002 \001(\005\022\r\n\005state\030\003 \001(\010\"T\n\026CSVCMs"
  "g_FullFrameSplit\022\014\n\004tick\030\001 \001(\005\022\017\n\007sectio"
  "n\030\002 \001(\005\022\r\n\005total\030\003 \001(\005\022\014\n\004data\030\004 \001(\014\"U\n\022"
  "CSVCMsg_HLTVStatus\022\016\n\006master\030\001 \001(\t\022\017\n\007cl"
  "ients\030\002 \001(\005\022\r\n\005slots\030\003 \001(\005\022\017\n\007proxies\030\004 "
  "\001(\005\")\n\025CSVCMsg_ServerSteamID\022\020\n\010steam_id"
  "\030\001 \001(\004\"$\n\024CSVCMsg_CmdKeyValues\022\014\n\004data\030\001"
  " \001(\014\";\n\031CSVCMsg_RconServerDetails\022\r\n\005tok"
  "en\030\001 \001(\014\022\017\n\007details\030\002 \001(\t\";\n\016CMsgIPCAddr"
  "ess\022\025\n\rcomputer_guid\030\001 \001(\006\022\022\n\nprocess_id"
  "\030\002 \001(\r\"\244\001\n\016CMsgServerPeer\022\027\n\013player_slot"
  "\030\001 \001(\005:\002-1\022\017\n\007steamid\030\002 \001(\006\022\034\n\003ipc\030\003 \001(\013"
  "2\017.CMsgIPCAddress\022\025\n\rthey_hear_you\030\004 \001(\010"
  "\022\025\n\ryou_hear_them\030\005 \001(\010\022\034\n\024is_listenserv"
  "er_host\030\006 \001(\010\"1\n\020CSVCMsg_PeerList\022\035\n\004pee"
  "r\030\001 \003(\0132\017.CMsgServerPeer\"N\n\034CSVCMsg_Clea"
  "rAllStringTables\022\017\n\007mapname\030\001 \001(\t\022\035\n\025cre"
  "ate_tables_skipped\030\003 \001(\010\"\363\003\n\037ProtoFlatte"
  "nedSerializerField_t\022\024\n\014var_type_sym\030\001 \001"
  "(\005\022\024\n\014var_name_sym\030\002 \001(\005\022\021\n\tbit_count\030\003 "
  "\001(\005\022\021\n\tlow_value\030\004 \001(\002\022\022\n\nhigh_value\030\005 \001"
  "(\002\022\024\n\014encode_flags\030\006 \001(\005\022!\n\031field_serial"
  "izer_name_sym\030\007 \001(\005\022 \n\030field_serializer_"
  "version\030\010 \001(\005\022\025\n\rsend_node_sym\030\t \001(\005\022\027\n\017"
  "var_encoder_sym\030\n \001(\005\022O\n\021polymorphic_typ"
  "es\030\013 \003(\01324.ProtoFlattenedSerializerField"
  "_t.polymorphic_field_t\022\032\n\022var_serializer"
  "_sym\030\014 \001(\005\032r\n\023polymorphic_field_t\022-\n%pol"
  "ymorphic_field_serializer_name_sym\030\001 \001(\005"
  "\022,\n$polymorphic_field_serializer_version"
  "\030\002 \001(\005\"k\n\032ProtoFlattenedSerializer_t\022\033\n\023"
  "serializer_name_sym\030\001 \001(\005\022\032\n\022serializer_"
  "version\030\002 \001(\005\022\024\n\014fields_index\030\003 \003(\005\"\222\001\n\033"
  "CSVCMsg_FlattenedSerializer\0220\n\013serialize"
  "rs\030\001 \003(\0132\033.ProtoFlattenedSerializer_t\022\017\n"
  "\007symbols\030\002 \003(\t\0220\n\006fields\030\003 \003(\0132 .ProtoFl"
  "attenedSerializerField_t\"!\n\021CSVCMsg_Stop"
  "Sound\022\014\n\004guid\030\001 \001(\007\"y\n\036CBidirMsg_Rebroad"
  "castGameEvent\022\024\n\014posttoserver\030\001 \001(\010\022\017\n\007b"
  "uftype\030\002 \001(\005\022\026\n\016clientbitcount\030\003 \001(\r\022\030\n\020"
  "receivingclients\030\004 \001(\004\"2\n\033CBidirMsg_Rebr"
  "oadcastSource\022\023\n\013eventsource\030\001 \001(\005\"\305\006\n\026C"
  "MsgServerNetworkStats\022\021\n\tdedicated\030\001 \001(\010"
  "\022\021\n\tcpu_usage\030\002 \001(\005\022\026\n\016memory_used_mb\030\003 "
  "\001(\005\022\026\n\016memory_free_mb\030\004 \001(\005\022\016\n\006uptime\030\005 "
  "\001(\005\022\023\n\013spawn_count\030\006 \001(\005\022\023\n\013num_clients\030"
  "\010 \001(\005\022\020\n\010num_bots\030\t \001(\005\022\026\n\016num_spectator"
  "s\030\n \001(\005\022\025\n\rnum_tv_relays\030\013 \001(\005\022\013\n\003fps\030\014 "
  "\001(\002\022+\n\005ports\030\021 \003(\0132\034.CMsgServerNetworkSt"
  "ats.Port\022\023\n\013avg_ping_ms\030\022 \001(\002\022\036\n\026avg_eng"
  "ine_latency_out\030\023 \001(\002\022\027\n\017avg_packets_out"
  "\030\024 \001(\002\022\026\n\016avg_packets_in\030\025 \001(\002\022\024\n\014avg_lo"
  "ss_out\030\026 \001(\002\022\023\n\013avg_loss_in\030\027 \001(\002\022\024\n\014avg"
  "_data_out\030\030 \001(\002\022\023\n\013avg_data_in\030\031 \001(\002\022\025\n\r"
  "total_data_in\030\032 \001(\004\022\030\n\020total_packets_in\030"
  "\033 \001(\004\022\026\n\016total_data_out\030\034 \001(\004\022\031\n\021total_p"
  "ackets_out\030\035 \001(\004\022/\n\007players\030\036 \003(\0132\036.CMsg"
  "ServerNetworkStats.Player\032\"\n\004Port\022\014\n\004por"
  "t\030\001 \001(\005\022\014\n\004name\030\002 \001(\t\032\252\001\n\006Player\022\017\n\007stea"
  "mid\030\001 \001(\004\022\023\n\013remote_addr\030\002 \001(\t\022\023\n\013ping_a"
  "vg_ms\030\004 \001(\005\022\027\n\017packet_loss_pct\030\005 \001(\002\022\016\n\006"
  "is_bot\030\006 \001(\010\022\017\n\007loss_in\030\007 \001(\002\022\020\n\010loss_ou"
  "t\030\010 \001(\002\022\031\n\021engine_latency_ms\030\t \001(\005\"\332\001\n\022C"
  "SVCMsg_HltvReplay\022\r\n\005delay\030\001 \001(\005\022\032\n\016prim"
  "ary_target\030\002 \001(\005:\002-1\022\026\n\016replay_stop_at\030\003"
  " \001(\005\022\027\n\017replay_start_at\030\004 \001(\005\022\035\n\025replay_"
  "slowdown_begin\030\005 \001(\005\022\033\n\023replay_slowdown_"
  "end\030\006 \001(\005\022\034\n\024replay_slowdown_rate\030\007 \001(\002\022"
  "\016\n\006reason\030\010 \001(\005\"\205\001\n\022CCLCMsg_HltvReplay\022\017"
  "\n\007request\030\001 \001(\005\022\027\n\017slowdown_length\030\002 \001(\002"
  "\022\025\n\rslowdown_rate\030\003 \001(\002\022\032\n\016primary_targe"
  "t\030\004 \001(\005:\002-1\022\022\n\nevent_time\030\005 \001(\002\"(\n\031CSVCM"
  "sg_Broadcast_Command\022\013\n\003cmd\030\001 \001(\t\"\357\001\n\035CC"
  "LCMsg_HltvFixupOperatorTick\022\014\n\004tick\030\001 \001("
  "\005\022\022\n\nprops_data\030\002 \001(\014\022\033\n\006origin\030\003 \001(\0132\013."
  "CMsgVector\022\037\n\neye_angles\030\004 \001(\0132\013.CMsgQAn"
  "gle\022\025\n\robserver_mode\030\005 \001(\005\022\034\n\024cameraman_"
  "scoreboard\030\006 \001(\010\022\027\n\017observer_target\030\007 \001("
  "\005\022 \n\013view_offset\030\010 \001(\0132\013.CMsgVector\"O\n\037C"
  "SVCMsg_HltvFixupOperatorStatus\022\014\n\004mode\030\001"
  " \001(\r\022\036\n\026override_operator_name\030\002 \001(\t\"\201\001\n"
  "\021CMsgServerUserCmd\022\014\n\004data\030\001 \001(\014\022\022\n\ncmd_"
  "number\030\002 \001(\005\022\027\n\013player_slot\030\003 \001(\005:\002-1\022\034\n"
  "\024server_tick_executed\030\004 \001(\005\022\023\n\013client_ti"
  "ck\030\005 \001(\005\"<\n\024CSVCMsg_UserCommands\022$\n\010comm"
  "ands\030\001 \003(\0132\022.CMsgServerUserCmd*\341\002\n\014CLC_M"
  "essages\022\022\n\016clc_ClientInfo\020\024\022\014\n\010clc_Move\020"
  "\025\022\021\n\rclc_VoiceData\020\026\022\023\n\017clc_BaselineAck\020"
  "\027\022\030\n\024clc_RespondCvarValue\020\031\022\024\n\020clc_FileC"
  "RCCheck\020\032\022\027\n\023clc_LoadingProgress\020\033\022\032\n\026cl"
  "c_SplitPlayerConnect\020\034\022\035\n\031clc_SplitPlaye"
  "rDisconnect\020\036\022\024\n\020clc_ServerStatus\020\037\022\024\n\020c"
  "lc_RequestPause\020!\022\024\n\020clc_CmdKeyValues\020\"\022"
  "\031\n\025clc_RconServerDetails\020#\022\022\n\016clc_HltvRe"
  "play\020$\022\022\n\016clc_Diagnostic\020%*\227\005\n\014SVC_Messa"
  "ges\022\022\n\016svc_ServerInfo\020(\022\033\n\027svc_Flattened"
  "Serializer\020)\022\021\n\rsvc_ClassInfo\020*\022\020\n\014svc_S"
  "etPause\020+\022\031\n\025svc_CreateStringTable\020,\022\031\n\025"
  "svc_UpdateStringTable\020-\022\021\n\rsvc_VoiceInit"
  "\020.\022\021\n\rsvc_VoiceData\020/\022\r\n\tsvc_Print\0200\022\016\n\n"
  "svc_Sounds\0201\022\017\n\013svc_SetView\0202\022\034\n\030svc_Cle"
  "arAllStringTables\0203\022\024\n\020svc_CmdKeyValues\020"
  "4\022\020\n\014svc_BSPDecal\0205\022\023\n\017svc_SplitScreen\0206"
  "\022\026\n\022svc_PacketEntities\0207\022\020\n\014svc_Prefetch"
  "\0208\022\014\n\010svc_Menu\0209\022\024\n\020svc_GetCvarValue\020:\022\021"
  "\n\rsvc_StopSound\020;\022\020\n\014svc_PeerList\020<\022\026\n\022s"
  "vc_PacketReliable\020=\022\022\n\016svc_HLTVStatus\020>\022"
  "\025\n\021svc_ServerSteamID\020\?\022\026\n\022svc_FullFrameS"
  "plit\020F\022\031\n\025svc_RconServerDetails\020G\022\023\n\017svc"
  "_UserMessage\020H\022\031\n\025svc_Broadcast_Command\020"
  "J\022\037\n\033svc_HltvFixupOperatorStatus\020K\022\020\n\014sv"
  "c_UserCmds\020L*g\n\021VoiceDataFormat_t\022\032\n\026VOI"
  "CEDATA_FORMAT_STEAM\020\000\022\033\n\027VOICEDATA_FORMA"
  "T_ENGINE\020\001\022\031\n\025VOICEDATA_FORMAT_OPUS\020\002*B\n"
  "\016RequestPause_t\022\014\n\010RP_PAUSE\020\000\022\016\n\nRP_UNPA"
  "USE\020\001\022\022\n\016RP_TOGGLEPAUSE\020\002*\035\n\014PrefetchTyp"
  "e\022\r\n\tPFT_SOUND\020\000*V\n\027ESplitScreenMessageT"
  "ype\022\033\n\027MSG_SPLITSCREEN_ADDUSER\020\000\022\036\n\032MSG_"
  "SPLITSCREEN_REMOVEUSER\020\001*\263\001\n\025EQueryCvarV"
  "alueStatus\022%\n!eQueryCvarValueStatus_Valu"
  "eIntact\020\000\022&\n\"eQueryCvarValueStatus_CvarN"
  "otFound\020\001\022\"\n\036eQueryCvarValueStatus_NotAC"
  "var\020\002\022\'\n#eQueryCvarValueStatus_CvarProte"
  "cted\020\003*h\n\013DIALOG_TYPE\022\016\n\nDIALOG_MSG\020\000\022\017\n"
  "\013DIALOG_MENU\020\001\022\017\n\013DIALOG_TEXT\020\002\022\020\n\014DIALO"
  "G_ENTRY\020\003\022\025\n\021DIALOG_ASKCONNECT\020\004*+\n\031SVC_"
  "Messages_LowFrequency\022\016\n\tsvc_dummy\020\330\004*a\n"
  "\026Bidirectional_Messages\022\033\n\027bi_Rebroadcas"
  "tGameEvent\020\020\022\030\n\024bi_RebroadcastSource\020\021\022\020"
  "\n\014bi_GameEvent\020\022*M\n#Bidirectional_Messag"
  "es_LowFrequency\022\021\n\014bi_RelayInfo\020\274\005\022\023\n\016bi"
  "_RelayPacket\020\275\005*\241\001\n\021ReplayEventType_t\022\027\n"
  "\023REPLAY_EVENT_CANCEL\020\000\022\026\n\022REPLAY_EVENT_D"
  "EATH\020\001\022\030\n\024REPLAY_EVENT_GENERIC\020\002\022\'\n#REPL"
  "AY_EVENT_STUCK_NEED_FULL_UPDATE\020\003\022\030\n\024REP"
  "LAY_EVENT_VICTORY\020\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_netmessages_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_netmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_netmessages_2eproto = {
    false, false, 11859, descriptor_table_protodef_netmessages_2eproto,
    "netmessages.proto",
    &descriptor_table_netmessages_2eproto_once, descriptor_table_netmessages_2eproto_deps, 1, 77,
    schemas, file_default_instances, TableStruct_netmessages_2eproto::offsets,
    file_level_metadata_netmessages_2eproto, file_level_enum_descriptors_netmessages_2eproto,
    file_level_service_descriptors_netmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_netmessages_2eproto_getter() {
  return &descriptor_table_netmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_netmessages_2eproto(&descriptor_table_netmessages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CLC_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[0];
}
bool CLC_Messages_IsValid(int value) {
  switch (value) {
    case 20:
    case 21:
    case 22:
    case 23:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
    case 31:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SVC_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[1];
}
bool SVC_Messages_IsValid(int value) {
  switch (value) {
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 70:
    case 71:
    case 72:
    case 74:
    case 75:
    case 76:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceDataFormat_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[2];
}
bool VoiceDataFormat_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestPause_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[3];
}
bool RequestPause_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrefetchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[4];
}
bool PrefetchType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScreenMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[5];
}
bool ESplitScreenMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQueryCvarValueStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[6];
}
bool EQueryCvarValueStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DIALOG_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[7];
}
bool DIALOG_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SVC_Messages_LowFrequency_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[8];
}
bool SVC_Messages_LowFrequency_IsValid(int value) {
  switch (value) {
    case 600:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Bidirectional_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[9];
}
bool Bidirectional_Messages_IsValid(int value) {
  switch (value) {
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Bidirectional_Messages_LowFrequency_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[10];
}
bool Bidirectional_Messages_LowFrequency_IsValid(int value) {
  switch (value) {
    case 700:
    case 701:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplayEventType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[11];
}
bool ReplayEventType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CCLCMsg_ClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_ClientInfo>()._impl_._has_bits_);
  static void set_has_send_table_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_hltv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_friends_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_friends_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ClientInfo)
}
CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(const CCLCMsg_ClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ClientInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.friends_name_){}
    , decltype(_impl_.send_table_crc_){}
    , decltype(_impl_.server_count_){}
    , decltype(_impl_.is_hltv_){}
    , decltype(_impl_.friends_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.friends_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friends_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friends_name()) {
    _this->_impl_.friends_name_.Set(from._internal_friends_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.send_table_crc_, &from._impl_.send_table_crc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.friends_id_) -
    reinterpret_cast<char*>(&_impl_.send_table_crc_)) + sizeof(_impl_.friends_id_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ClientInfo)
}

inline void CCLCMsg_ClientInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.friends_name_){}
    , decltype(_impl_.send_table_crc_){0u}
    , decltype(_impl_.server_count_){0u}
    , decltype(_impl_.is_hltv_){false}
    , decltype(_impl_.friends_id_){0u}
  };
  _impl_.friends_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friends_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_ClientInfo::~CCLCMsg_ClientInfo() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.friends_name_.Destroy();
}

void CCLCMsg_ClientInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.friends_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.send_table_crc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.friends_id_) -
        reinterpret_cast<char*>(&_impl_.send_table_crc_)) + sizeof(_impl_.friends_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 send_table_crc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_send_table_crc(&has_bits);
          _impl_.send_table_crc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_count(&has_bits);
          _impl_.server_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hltv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_hltv(&has_bits);
          _impl_.is_hltv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 friends_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_friends_id(&has_bits);
          _impl_.friends_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string friends_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_friends_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_ClientInfo.friends_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 send_table_crc = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_send_table_crc(), target);
  }

  // optional uint32 server_count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_server_count(), target);
  }

  // optional bool is_hltv = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_hltv(), target);
  }

  // optional uint32 friends_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_friends_id(), target);
  }

  // optional string friends_name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friends_name().data(), static_cast<int>(this->_internal_friends_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_ClientInfo.friends_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_friends_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ClientInfo)
  return target;
}

size_t CCLCMsg_ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string friends_name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friends_name());
    }

    // optional fixed32 send_table_crc = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 server_count = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_count());
    }

    // optional bool is_hltv = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 friends_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_friends_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ClientInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ClientInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ClientInfo::GetClassData() const { return &_class_data_; }


void CCLCMsg_ClientInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ClientInfo*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ClientInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ClientInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_friends_name(from._internal_friends_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.send_table_crc_ = from._impl_.send_table_crc_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.server_count_ = from._impl_.server_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_hltv_ = from._impl_.is_hltv_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.friends_id_ = from._impl_.friends_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ClientInfo::CopyFrom(const CCLCMsg_ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ClientInfo::IsInitialized() const {
  return true;
}

void CCLCMsg_ClientInfo::InternalSwap(CCLCMsg_ClientInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friends_name_, lhs_arena,
      &other->_impl_.friends_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_ClientInfo, _impl_.friends_id_)
      + sizeof(CCLCMsg_ClientInfo::_impl_.friends_id_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_ClientInfo, _impl_.send_table_crc_)>(
          reinterpret_cast<char*>(&_impl_.send_table_crc_),
          reinterpret_cast<char*>(&other->_impl_.send_table_crc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ClientInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[0]);
}

// ===================================================================

class CCLCMsg_Move::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_Move>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_command_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_Move::CCLCMsg_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_Move)
}
CCLCMsg_Move::CCLCMsg_Move(const CCLCMsg_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.last_command_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.last_command_number_ = from._impl_.last_command_number_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_Move)
}

inline void CCLCMsg_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.last_command_number_){0u}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_Move::~CCLCMsg_Move() {
  // @@protoc_insertion_point(destructor:CCLCMsg_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CCLCMsg_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_.last_command_number_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_command_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_last_command_number(&has_bits);
          _impl_.last_command_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional uint32 last_command_number = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_last_command_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_Move)
  return target;
}

size_t CCLCMsg_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 last_command_number = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_command_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_Move::GetClassData() const { return &_class_data_; }


void CCLCMsg_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_Move*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.last_command_number_ = from._impl_.last_command_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_Move::CopyFrom(const CCLCMsg_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_Move::IsInitialized() const {
  return true;
}

void CCLCMsg_Move::InternalSwap(CCLCMsg_Move* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.last_command_number_, other->_impl_.last_command_number_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[1]);
}

// ===================================================================

class CMsgVoiceAudio::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgVoiceAudio>()._impl_._has_bits_);
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voice_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sequence_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_section_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_uncompressed_sample_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_voice_level(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgVoiceAudio::CMsgVoiceAudio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgVoiceAudio)
}
CMsgVoiceAudio::CMsgVoiceAudio(const CMsgVoiceAudio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgVoiceAudio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_offsets_){from._impl_.packet_offsets_}
    , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
    , decltype(_impl_.voice_data_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.sequence_bytes_){}
    , decltype(_impl_.section_number_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.uncompressed_sample_offset_){}
    , decltype(_impl_.num_packets_){}
    , decltype(_impl_.voice_level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.voice_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voice_data()) {
    _this->_impl_.voice_data_.Set(from._internal_voice_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.format_, &from._impl_.format_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.voice_level_) -
    reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.voice_level_));
  // @@protoc_insertion_point(copy_constructor:CMsgVoiceAudio)
}

inline void CMsgVoiceAudio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_offsets_){arena}
    , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
    , decltype(_impl_.voice_data_){}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.sequence_bytes_){0}
    , decltype(_impl_.section_number_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.uncompressed_sample_offset_){0u}
    , decltype(_impl_.num_packets_){0u}
    , decltype(_impl_.voice_level_){0}
  };
  _impl_.voice_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgVoiceAudio::~CMsgVoiceAudio() {
  // @@protoc_insertion_point(destructor:CMsgVoiceAudio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgVoiceAudio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packet_offsets_.~RepeatedField();
  _impl_.voice_data_.Destroy();
}

void CMsgVoiceAudio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgVoiceAudio::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgVoiceAudio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packet_offsets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.voice_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.format_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.voice_level_) -
        reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.voice_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgVoiceAudio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::VoiceDataFormat_t_IsValid(val))) {
            _internal_set_format(static_cast<::VoiceDataFormat_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes voice_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_voice_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sequence_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sequence_bytes(&has_bits);
          _impl_.sequence_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 section_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_section_number(&has_bits);
          _impl_.section_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sample_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uncompressed_sample_offset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_uncompressed_sample_offset(&has_bits);
          _impl_.uncompressed_sample_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_packets = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_packets(&has_bits);
          _impl_.num_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 packet_offsets = 8 [packed = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_packet_offsets(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_packet_offsets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float voice_level = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_voice_level(&has_bits);
          _impl_.voice_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgVoiceAudio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgVoiceAudio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_format(), target);
  }

  // optional bytes voice_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_voice_data(), target);
  }

  // optional int32 sequence_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sequence_bytes(), target);
  }

  // optional uint32 section_number = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_section_number(), target);
  }

  // optional uint32 sample_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sample_rate(), target);
  }

  // optional uint32 uncompressed_sample_offset = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_uncompressed_sample_offset(), target);
  }

  // optional uint32 num_packets = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_num_packets(), target);
  }

  // repeated uint32 packet_offsets = 8 [packed = true];
  {
    int byte_size = _impl_._packet_offsets_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          8, _internal_packet_offsets(), byte_size, target);
    }
  }

  // optional float voice_level = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_voice_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgVoiceAudio)
  return target;
}

size_t CMsgVoiceAudio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgVoiceAudio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 packet_offsets = 8 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.packet_offsets_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._packet_offsets_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes voice_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_voice_data());
    }

    // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional int32 sequence_bytes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence_bytes());
    }

    // optional uint32 section_number = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_section_number());
    }

    // optional uint32 sample_rate = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
    }

    // optional uint32 uncompressed_sample_offset = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uncompressed_sample_offset());
    }

    // optional uint32 num_packets = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_packets());
    }

    // optional float voice_level = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgVoiceAudio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgVoiceAudio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgVoiceAudio::GetClassData() const { return &_class_data_; }


void CMsgVoiceAudio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgVoiceAudio*>(&to_msg);
  auto& from = static_cast<const CMsgVoiceAudio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgVoiceAudio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.packet_offsets_.MergeFrom(from._impl_.packet_offsets_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_voice_data(from._internal_voice_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_bytes_ = from._impl_.sequence_bytes_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.section_number_ = from._impl_.section_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.uncompressed_sample_offset_ = from._impl_.uncompressed_sample_offset_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_packets_ = from._impl_.num_packets_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.voice_level_ = from._impl_.voice_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgVoiceAudio::CopyFrom(const CMsgVoiceAudio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgVoiceAudio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgVoiceAudio::IsInitialized() const {
  return true;
}

void CMsgVoiceAudio::InternalSwap(CMsgVoiceAudio* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.packet_offsets_.InternalSwap(&other->_impl_.packet_offsets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voice_data_, lhs_arena,
      &other->_impl_.voice_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgVoiceAudio, _impl_.voice_level_)
      + sizeof(CMsgVoiceAudio::_impl_.voice_level_)
      - PROTOBUF_FIELD_OFFSET(CMsgVoiceAudio, _impl_.format_)>(
          reinterpret_cast<char*>(&_impl_.format_),
          reinterpret_cast<char*>(&other->_impl_.format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgVoiceAudio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[2]);
}

// ===================================================================

class CCLCMsg_VoiceData::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_VoiceData>()._impl_._has_bits_);
  static const ::CMsgVoiceAudio& audio(const CCLCMsg_VoiceData* msg);
  static void set_has_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_xuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVoiceAudio&
CCLCMsg_VoiceData::_Internal::audio(const CCLCMsg_VoiceData* msg) {
  return *msg->_impl_.audio_;
}
CCLCMsg_VoiceData::CCLCMsg_VoiceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_VoiceData)
}
CCLCMsg_VoiceData::CCLCMsg_VoiceData(const CCLCMsg_VoiceData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_VoiceData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){}
    , decltype(_impl_.tick_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::CMsgVoiceAudio(*from._impl_.audio_);
  }
  ::memcpy(&_impl_.xuid_, &from._impl_.xuid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tick_) -
    reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.tick_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_VoiceData)
}

inline void CCLCMsg_VoiceData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){uint64_t{0u}}
    , decltype(_impl_.tick_){0u}
  };
}

CCLCMsg_VoiceData::~CCLCMsg_VoiceData() {
  // @@protoc_insertion_point(destructor:CCLCMsg_VoiceData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_VoiceData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audio_;
}

void CCLCMsg_VoiceData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_VoiceData::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.audio_ != nullptr);
    _impl_.audio_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.xuid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tick_) -
        reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.tick_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_VoiceData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVoiceAudio audio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 xuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_xuid(&has_bits);
          _impl_.xuid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_VoiceData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVoiceAudio audio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 xuid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_xuid(), target);
  }

  // optional uint32 tick = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_VoiceData)
  return target;
}

size_t CCLCMsg_VoiceData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_VoiceData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVoiceAudio audio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audio_);
    }

    // optional fixed64 xuid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 tick = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tick());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_VoiceData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_VoiceData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_VoiceData::GetClassData() const { return &_class_data_; }


void CCLCMsg_VoiceData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_VoiceData*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_VoiceData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_VoiceData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_audio()->::CMsgVoiceAudio::MergeFrom(
          from._internal_audio());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.xuid_ = from._impl_.xuid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_VoiceData::CopyFrom(const CCLCMsg_VoiceData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_VoiceData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_VoiceData::IsInitialized() const {
  return true;
}

void CCLCMsg_VoiceData::InternalSwap(CCLCMsg_VoiceData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_VoiceData, _impl_.tick_)
      + sizeof(CCLCMsg_VoiceData::_impl_.tick_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_VoiceData, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_VoiceData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[3]);
}

// ===================================================================

class CCLCMsg_BaselineAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_BaselineAck>()._impl_._has_bits_);
  static void set_has_baseline_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_baseline_nr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_BaselineAck)
}
CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(const CCLCMsg_BaselineAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_BaselineAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseline_tick_){}
    , decltype(_impl_.baseline_nr_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.baseline_tick_, &from._impl_.baseline_tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.baseline_nr_) -
    reinterpret_cast<char*>(&_impl_.baseline_tick_)) + sizeof(_impl_.baseline_nr_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_BaselineAck)
}

inline void CCLCMsg_BaselineAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseline_tick_){0}
    , decltype(_impl_.baseline_nr_){0}
  };
}

CCLCMsg_BaselineAck::~CCLCMsg_BaselineAck() {
  // @@protoc_insertion_point(destructor:CCLCMsg_BaselineAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_BaselineAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_BaselineAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_BaselineAck::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_BaselineAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.baseline_tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.baseline_nr_) -
        reinterpret_cast<char*>(&_impl_.baseline_tick_)) + sizeof(_impl_.baseline_nr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_BaselineAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 baseline_tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_baseline_tick(&has_bits);
          _impl_.baseline_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline_nr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_baseline_nr(&has_bits);
          _impl_.baseline_nr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_BaselineAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_BaselineAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 baseline_tick = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_baseline_tick(), target);
  }

  // optional int32 baseline_nr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_baseline_nr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_BaselineAck)
  return target;
}

size_t CCLCMsg_BaselineAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_BaselineAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 baseline_tick = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_tick());
    }

    // optional int32 baseline_nr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_nr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_BaselineAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_BaselineAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_BaselineAck::GetClassData() const { return &_class_data_; }


void CCLCMsg_BaselineAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_BaselineAck*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_BaselineAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_BaselineAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.baseline_tick_ = from._impl_.baseline_tick_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.baseline_nr_ = from._impl_.baseline_nr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_BaselineAck::CopyFrom(const CCLCMsg_BaselineAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_BaselineAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_BaselineAck::IsInitialized() const {
  return true;
}

void CCLCMsg_BaselineAck::InternalSwap(CCLCMsg_BaselineAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_BaselineAck, _impl_.baseline_nr_)
      + sizeof(CCLCMsg_BaselineAck::_impl_.baseline_nr_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_BaselineAck, _impl_.baseline_tick_)>(
          reinterpret_cast<char*>(&_impl_.baseline_tick_),
          reinterpret_cast<char*>(&other->_impl_.baseline_tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_BaselineAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[4]);
}

// ===================================================================

class CCLCMsg_ListenEvents::_Internal {
 public:
};

CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ListenEvents)
}
CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(const CCLCMsg_ListenEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ListenEvents* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.event_mask_){from._impl_.event_mask_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ListenEvents)
}

inline void CCLCMsg_ListenEvents::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.event_mask_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CCLCMsg_ListenEvents::~CCLCMsg_ListenEvents() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ListenEvents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ListenEvents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.event_mask_.~RepeatedField();
}

void CCLCMsg_ListenEvents::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ListenEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ListenEvents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.event_mask_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ListenEvents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed32 event_mask = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_event_mask(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_event_mask(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ListenEvents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ListenEvents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed32 event_mask = 1;
  for (int i = 0, n = this->_internal_event_mask_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_event_mask(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ListenEvents)
  return target;
}

size_t CCLCMsg_ListenEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ListenEvents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 event_mask = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_event_mask_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_event_mask_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ListenEvents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ListenEvents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ListenEvents::GetClassData() const { return &_class_data_; }


void CCLCMsg_ListenEvents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ListenEvents*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ListenEvents&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ListenEvents)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.event_mask_.MergeFrom(from._impl_.event_mask_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ListenEvents::CopyFrom(const CCLCMsg_ListenEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ListenEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ListenEvents::IsInitialized() const {
  return true;
}

void CCLCMsg_ListenEvents::InternalSwap(CCLCMsg_ListenEvents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.event_mask_.InternalSwap(&other->_impl_.event_mask_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ListenEvents::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[5]);
}

// ===================================================================

class CCLCMsg_RespondCvarValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RespondCvarValue>()._impl_._has_bits_);
  static void set_has_cookie(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RespondCvarValue)
}
CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(const CCLCMsg_RespondCvarValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RespondCvarValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.cookie_){}
    , decltype(_impl_.status_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cookie_, &from._impl_.cookie_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_code_) -
    reinterpret_cast<char*>(&_impl_.cookie_)) + sizeof(_impl_.status_code_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RespondCvarValue)
}

inline void CCLCMsg_RespondCvarValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.cookie_){0}
    , decltype(_impl_.status_code_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_RespondCvarValue::~CCLCMsg_RespondCvarValue() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RespondCvarValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RespondCvarValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CCLCMsg_RespondCvarValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RespondCvarValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RespondCvarValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.cookie_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.status_code_) -
        reinterpret_cast<char*>(&_impl_.cookie_)) + sizeof(_impl_.status_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RespondCvarValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cookie = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cookie(&has_bits);
          _impl_.cookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 status_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_status_code(&has_bits);
          _impl_.status_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_RespondCvarValue.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_RespondCvarValue.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RespondCvarValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RespondCvarValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cookie = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cookie(), target);
  }

  // optional int32 status_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_status_code(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_RespondCvarValue.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string value = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_RespondCvarValue.value");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RespondCvarValue)
  return target;
}

size_t CCLCMsg_RespondCvarValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RespondCvarValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional int32 cookie = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cookie());
    }

    // optional int32 status_code = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RespondCvarValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RespondCvarValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RespondCvarValue::GetClassData() const { return &_class_data_; }


void CCLCMsg_RespondCvarValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RespondCvarValue*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RespondCvarValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RespondCvarValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cookie_ = from._impl_.cookie_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.status_code_ = from._impl_.status_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RespondCvarValue::CopyFrom(const CCLCMsg_RespondCvarValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RespondCvarValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RespondCvarValue::IsInitialized() const {
  return true;
}

void CCLCMsg_RespondCvarValue::InternalSwap(CCLCMsg_RespondCvarValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_RespondCvarValue, _impl_.status_code_)
      + sizeof(CCLCMsg_RespondCvarValue::_impl_.status_code_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_RespondCvarValue, _impl_.cookie_)>(
          reinterpret_cast<char*>(&_impl_.cookie_),
          reinterpret_cast<char*>(&other->_impl_.cookie_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RespondCvarValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[6]);
}

// ===================================================================

class CCLCMsg_FileCRCCheck::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_FileCRCCheck>()._impl_._has_bits_);
  static void set_has_code_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_code_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_FileCRCCheck)
}
CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(const CCLCMsg_FileCRCCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_FileCRCCheck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.code_path_){}
    , decltype(_impl_.code_filename_){}
    , decltype(_impl_.crc_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.code_path_, &from._impl_.code_path_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.crc_) -
    reinterpret_cast<char*>(&_impl_.code_path_)) + sizeof(_impl_.crc_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_FileCRCCheck)
}

inline void CCLCMsg_FileCRCCheck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.code_path_){0}
    , decltype(_impl_.code_filename_){0}
    , decltype(_impl_.crc_){0u}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_FileCRCCheck::~CCLCMsg_FileCRCCheck() {
  // @@protoc_insertion_point(destructor:CCLCMsg_FileCRCCheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_FileCRCCheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.filename_.Destroy();
}

void CCLCMsg_FileCRCCheck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_FileCRCCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_FileCRCCheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.code_path_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.crc_) -
        reinterpret_cast<char*>(&_impl_.code_path_)) + sizeof(_impl_.crc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_FileCRCCheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 code_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_code_path(&has_bits);
          _impl_.code_path_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_FileCRCCheck.path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 code_filename = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_code_filename(&has_bits);
          _impl_.code_filename_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_FileCRCCheck.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 crc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_crc(&has_bits);
          _impl_.crc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_FileCRCCheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_FileCRCCheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 code_path = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code_path(), target);
  }

  // optional string path = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_FileCRCCheck.path");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional int32 code_filename = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_code_filename(), target);
  }

  // optional string filename = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_FileCRCCheck.filename");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_filename(), target);
  }

  // optional fixed32 crc = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_crc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_FileCRCCheck)
  return target;
}

size_t CCLCMsg_FileCRCCheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_FileCRCCheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional string filename = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int32 code_path = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code_path());
    }

    // optional int32 code_filename = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code_filename());
    }

    // optional fixed32 crc = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_FileCRCCheck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_FileCRCCheck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_FileCRCCheck::GetClassData() const { return &_class_data_; }


void CCLCMsg_FileCRCCheck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_FileCRCCheck*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_FileCRCCheck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_FileCRCCheck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.code_path_ = from._impl_.code_path_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.code_filename_ = from._impl_.code_filename_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.crc_ = from._impl_.crc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_FileCRCCheck::CopyFrom(const CCLCMsg_FileCRCCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_FileCRCCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_FileCRCCheck::IsInitialized() const {
  return true;
}

void CCLCMsg_FileCRCCheck::InternalSwap(CCLCMsg_FileCRCCheck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_FileCRCCheck, _impl_.crc_)
      + sizeof(CCLCMsg_FileCRCCheck::_impl_.crc_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_FileCRCCheck, _impl_.code_path_)>(
          reinterpret_cast<char*>(&_impl_.code_path_),
          reinterpret_cast<char*>(&other->_impl_.code_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_FileCRCCheck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[7]);
}

// ===================================================================

class CCLCMsg_LoadingProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_LoadingProgress>()._impl_._has_bits_);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_LoadingProgress)
}
CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(const CCLCMsg_LoadingProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_LoadingProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.progress_ = from._impl_.progress_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_LoadingProgress)
}

inline void CCLCMsg_LoadingProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){0}
  };
}

CCLCMsg_LoadingProgress::~CCLCMsg_LoadingProgress() {
  // @@protoc_insertion_point(destructor:CCLCMsg_LoadingProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_LoadingProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_LoadingProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_LoadingProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_LoadingProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.progress_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_LoadingProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_LoadingProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_LoadingProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 progress = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_LoadingProgress)
  return target;
}

size_t CCLCMsg_LoadingProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_LoadingProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 progress = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_progress());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_LoadingProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_LoadingProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_LoadingProgress::GetClassData() const { return &_class_data_; }


void CCLCMsg_LoadingProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_LoadingProgress*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_LoadingProgress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_LoadingProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_progress()) {
    _this->_internal_set_progress(from._internal_progress());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_LoadingProgress::CopyFrom(const CCLCMsg_LoadingProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_LoadingProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_LoadingProgress::IsInitialized() const {
  return true;
}

void CCLCMsg_LoadingProgress::InternalSwap(CCLCMsg_LoadingProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.progress_, other->_impl_.progress_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_LoadingProgress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[8]);
}

// ===================================================================

class CCLCMsg_SplitPlayerConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_SplitPlayerConnect>()._impl_._has_bits_);
  static void set_has_playername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_SplitPlayerConnect)
}
CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(const CCLCMsg_SplitPlayerConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_SplitPlayerConnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playername()) {
    _this->_impl_.playername_.Set(from._internal_playername(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_SplitPlayerConnect)
}

inline void CCLCMsg_SplitPlayerConnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
  };
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_SplitPlayerConnect::~CCLCMsg_SplitPlayerConnect() {
  // @@protoc_insertion_point(destructor:CCLCMsg_SplitPlayerConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_SplitPlayerConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.playername_.Destroy();
}

void CCLCMsg_SplitPlayerConnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_SplitPlayerConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_SplitPlayerConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.playername_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_SplitPlayerConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string playername = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_playername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_SplitPlayerConnect.playername");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_SplitPlayerConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_SplitPlayerConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string playername = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_playername().data(), static_cast<int>(this->_internal_playername().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_SplitPlayerConnect.playername");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_playername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_SplitPlayerConnect)
  return target;
}

size_t CCLCMsg_SplitPlayerConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_SplitPlayerConnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string playername = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_playername());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_SplitPlayerConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_SplitPlayerConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_SplitPlayerConnect::GetClassData() const { return &_class_data_; }


void CCLCMsg_SplitPlayerConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_SplitPlayerConnect*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_SplitPlayerConnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_SplitPlayerConnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playername()) {
    _this->_internal_set_playername(from._internal_playername());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_SplitPlayerConnect::CopyFrom(const CCLCMsg_SplitPlayerConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_SplitPlayerConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_SplitPlayerConnect::IsInitialized() const {
  return true;
}

void CCLCMsg_SplitPlayerConnect::InternalSwap(CCLCMsg_SplitPlayerConnect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.playername_, lhs_arena,
      &other->_impl_.playername_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_SplitPlayerConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[9]);
}

// ===================================================================

class CCLCMsg_SplitPlayerDisconnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_SplitPlayerDisconnect>()._impl_._has_bits_);
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_SplitPlayerDisconnect)
}
CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(const CCLCMsg_SplitPlayerDisconnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_SplitPlayerDisconnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.slot_ = from._impl_.slot_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_SplitPlayerDisconnect)
}

inline void CCLCMsg_SplitPlayerDisconnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){0}
  };
}

CCLCMsg_SplitPlayerDisconnect::~CCLCMsg_SplitPlayerDisconnect() {
  // @@protoc_insertion_point(destructor:CCLCMsg_SplitPlayerDisconnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_SplitPlayerDisconnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_SplitPlayerDisconnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_SplitPlayerDisconnect::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_SplitPlayerDisconnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slot_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_SplitPlayerDisconnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_SplitPlayerDisconnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_SplitPlayerDisconnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 slot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_SplitPlayerDisconnect)
  return target;
}

size_t CCLCMsg_SplitPlayerDisconnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_SplitPlayerDisconnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 slot = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_SplitPlayerDisconnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_SplitPlayerDisconnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_SplitPlayerDisconnect::GetClassData() const { return &_class_data_; }


void CCLCMsg_SplitPlayerDisconnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_SplitPlayerDisconnect*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_SplitPlayerDisconnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_SplitPlayerDisconnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_slot()) {
    _this->_internal_set_slot(from._internal_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_SplitPlayerDisconnect::CopyFrom(const CCLCMsg_SplitPlayerDisconnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_SplitPlayerDisconnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_SplitPlayerDisconnect::IsInitialized() const {
  return true;
}

void CCLCMsg_SplitPlayerDisconnect::InternalSwap(CCLCMsg_SplitPlayerDisconnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_SplitPlayerDisconnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[10]);
}

// ===================================================================

class CCLCMsg_ServerStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_ServerStatus>()._impl_._has_bits_);
  static void set_has_simplified(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ServerStatus)
}
CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(const CCLCMsg_ServerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ServerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.simplified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.simplified_ = from._impl_.simplified_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ServerStatus)
}

inline void CCLCMsg_ServerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.simplified_){false}
  };
}

CCLCMsg_ServerStatus::~CCLCMsg_ServerStatus() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ServerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ServerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_ServerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ServerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ServerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.simplified_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ServerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool simplified = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_simplified(&has_bits);
          _impl_.simplified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ServerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ServerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool simplified = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_simplified(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ServerStatus)
  return target;
}

size_t CCLCMsg_ServerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ServerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool simplified = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ServerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ServerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ServerStatus::GetClassData() const { return &_class_data_; }


void CCLCMsg_ServerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ServerStatus*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ServerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ServerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_simplified()) {
    _this->_internal_set_simplified(from._internal_simplified());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ServerStatus::CopyFrom(const CCLCMsg_ServerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ServerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ServerStatus::IsInitialized() const {
  return true;
}

void CCLCMsg_ServerStatus::InternalSwap(CCLCMsg_ServerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.simplified_, other->_impl_.simplified_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ServerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[11]);
}

// ===================================================================

class CCLCMsg_RequestPause::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RequestPause>()._impl_._has_bits_);
  static void set_has_pause_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pause_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_RequestPause::CCLCMsg_RequestPause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RequestPause)
}
CCLCMsg_RequestPause::CCLCMsg_RequestPause(const CCLCMsg_RequestPause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RequestPause* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pause_type_){}
    , decltype(_impl_.pause_group_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pause_type_, &from._impl_.pause_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pause_group_) -
    reinterpret_cast<char*>(&_impl_.pause_type_)) + sizeof(_impl_.pause_group_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RequestPause)
}

inline void CCLCMsg_RequestPause::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pause_type_){0}
    , decltype(_impl_.pause_group_){0}
  };
}

CCLCMsg_RequestPause::~CCLCMsg_RequestPause() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RequestPause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RequestPause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_RequestPause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RequestPause::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RequestPause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.pause_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pause_group_) -
        reinterpret_cast<char*>(&_impl_.pause_type_)) + sizeof(_impl_.pause_group_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RequestPause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::RequestPause_t_IsValid(val))) {
            _internal_set_pause_type(static_cast<::RequestPause_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 pause_group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pause_group(&has_bits);
          _impl_.pause_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RequestPause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RequestPause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pause_type(), target);
  }

  // optional int32 pause_group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pause_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RequestPause)
  return target;
}

size_t CCLCMsg_RequestPause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RequestPause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pause_type());
    }

    // optional int32 pause_group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pause_group());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RequestPause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RequestPause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RequestPause::GetClassData() const { return &_class_data_; }


void CCLCMsg_RequestPause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RequestPause*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RequestPause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RequestPause)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pause_type_ = from._impl_.pause_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pause_group_ = from._impl_.pause_group_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RequestPause::CopyFrom(const CCLCMsg_RequestPause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RequestPause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RequestPause::IsInitialized() const {
  return true;
}

void CCLCMsg_RequestPause::InternalSwap(CCLCMsg_RequestPause* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_RequestPause, _impl_.pause_group_)
      + sizeof(CCLCMsg_RequestPause::_impl_.pause_group_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_RequestPause, _impl_.pause_type_)>(
          reinterpret_cast<char*>(&_impl_.pause_type_),
          reinterpret_cast<char*>(&other->_impl_.pause_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RequestPause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[12]);
}

// ===================================================================

class CCLCMsg_CmdKeyValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_CmdKeyValues>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_CmdKeyValues)
}
CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(const CCLCMsg_CmdKeyValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_CmdKeyValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_CmdKeyValues)
}

inline void CCLCMsg_CmdKeyValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_CmdKeyValues::~CCLCMsg_CmdKeyValues() {
  // @@protoc_insertion_point(destructor:CCLCMsg_CmdKeyValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_CmdKeyValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CCLCMsg_CmdKeyValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_CmdKeyValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_CmdKeyValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_CmdKeyValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_CmdKeyValues)
  return target;
}

size_t CCLCMsg_CmdKeyValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_CmdKeyValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_CmdKeyValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_CmdKeyValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_CmdKeyValues::GetClassData() const { return &_class_data_; }


void CCLCMsg_CmdKeyValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_CmdKeyValues*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_CmdKeyValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_CmdKeyValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_CmdKeyValues::CopyFrom(const CCLCMsg_CmdKeyValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_CmdKeyValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_CmdKeyValues::IsInitialized() const {
  return true;
}

void CCLCMsg_CmdKeyValues::InternalSwap(CCLCMsg_CmdKeyValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_CmdKeyValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[13]);
}

// ===================================================================

class CCLCMsg_RconServerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RconServerDetails>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RconServerDetails)
}
CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(const CCLCMsg_RconServerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RconServerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RconServerDetails)
}

inline void CCLCMsg_RconServerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_RconServerDetails::~CCLCMsg_RconServerDetails() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RconServerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RconServerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
}

void CCLCMsg_RconServerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RconServerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.token_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RconServerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RconServerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RconServerDetails)
  return target;
}

size_t CCLCMsg_RconServerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RconServerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes token = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RconServerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RconServerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RconServerDetails::GetClassData() const { return &_class_data_; }


void CCLCMsg_RconServerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RconServerDetails*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RconServerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RconServerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token()) {
    _this->_internal_set_token(from._internal_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RconServerDetails::CopyFrom(const CCLCMsg_RconServerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RconServerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RconServerDetails::IsInitialized() const {
  return true;
}

void CCLCMsg_RconServerDetails::InternalSwap(CCLCMsg_RconServerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RconServerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[14]);
}

// ===================================================================

class CMsgSource2SystemSpecs::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSource2SystemSpecs>()._impl_._has_bits_);
  static void set_has_cpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_brand(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cpu_model(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cpu_num_physical(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ram_physical_total_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gpu_rendersystem_dll_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gpu_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gpu_driver_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gpu_driver_version_high(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_gpu_driver_version_low(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gpu_dx_support_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gpu_texture_memory_size_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CMsgSource2SystemSpecs::CMsgSource2SystemSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSource2SystemSpecs)
}
CMsgSource2SystemSpecs::CMsgSource2SystemSpecs(const CMsgSource2SystemSpecs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSource2SystemSpecs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_id_){}
    , decltype(_impl_.cpu_brand_){}
    , decltype(_impl_.gpu_rendersystem_dll_name_){}
    , decltype(_impl_.gpu_driver_name_){}
    , decltype(_impl_.cpu_model_){}
    , decltype(_impl_.cpu_num_physical_){}
    , decltype(_impl_.ram_physical_total_mb_){}
    , decltype(_impl_.gpu_vendor_id_){}
    , decltype(_impl_.gpu_driver_version_high_){}
    , decltype(_impl_.gpu_driver_version_low_){}
    , decltype(_impl_.gpu_dx_support_level_){}
    , decltype(_impl_.gpu_texture_memory_size_mb_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_id()) {
    _this->_impl_.cpu_id_.Set(from._internal_cpu_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cpu_brand_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_brand_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_brand()) {
    _this->_impl_.cpu_brand_.Set(from._internal_cpu_brand(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gpu_rendersystem_dll_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_rendersystem_dll_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gpu_rendersystem_dll_name()) {
    _this->_impl_.gpu_rendersystem_dll_name_.Set(from._internal_gpu_rendersystem_dll_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gpu_driver_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_driver_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gpu_driver_name()) {
    _this->_impl_.gpu_driver_name_.Set(from._internal_gpu_driver_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cpu_model_, &from._impl_.cpu_model_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gpu_texture_memory_size_mb_) -
    reinterpret_cast<char*>(&_impl_.cpu_model_)) + sizeof(_impl_.gpu_texture_memory_size_mb_));
  // @@protoc_insertion_point(copy_constructor:CMsgSource2SystemSpecs)
}

inline void CMsgSource2SystemSpecs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_id_){}
    , decltype(_impl_.cpu_brand_){}
    , decltype(_impl_.gpu_rendersystem_dll_name_){}
    , decltype(_impl_.gpu_driver_name_){}
    , decltype(_impl_.cpu_model_){0u}
    , decltype(_impl_.cpu_num_physical_){0u}
    , decltype(_impl_.ram_physical_total_mb_){0u}
    , decltype(_impl_.gpu_vendor_id_){0u}
    , decltype(_impl_.gpu_driver_version_high_){0u}
    , decltype(_impl_.gpu_driver_version_low_){0u}
    , decltype(_impl_.gpu_dx_support_level_){0u}
    , decltype(_impl_.gpu_texture_memory_size_mb_){0u}
  };
  _impl_.cpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cpu_brand_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_brand_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gpu_rendersystem_dll_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_rendersystem_dll_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gpu_driver_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_driver_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSource2SystemSpecs::~CMsgSource2SystemSpecs() {
  // @@protoc_insertion_point(destructor:CMsgSource2SystemSpecs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSource2SystemSpecs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cpu_id_.Destroy();
  _impl_.cpu_brand_.Destroy();
  _impl_.gpu_rendersystem_dll_name_.Destroy();
  _impl_.gpu_driver_name_.Destroy();
}

void CMsgSource2SystemSpecs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSource2SystemSpecs::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSource2SystemSpecs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cpu_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cpu_brand_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.gpu_rendersystem_dll_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.gpu_driver_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.cpu_model_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gpu_vendor_id_) -
        reinterpret_cast<char*>(&_impl_.cpu_model_)) + sizeof(_impl_.gpu_vendor_id_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.gpu_driver_version_high_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gpu_texture_memory_size_mb_) -
        reinterpret_cast<char*>(&_impl_.gpu_driver_version_high_)) + sizeof(_impl_.gpu_texture_memory_size_mb_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSource2SystemSpecs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cpu_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cpu_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSource2SystemSpecs.cpu_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string cpu_brand = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cpu_brand();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSource2SystemSpecs.cpu_brand");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cpu_model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cpu_model(&has_bits);
          _impl_.cpu_model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cpu_num_physical = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cpu_num_physical(&has_bits);
          _impl_.cpu_num_physical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ram_physical_total_mb = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_ram_physical_total_mb(&has_bits);
          _impl_.ram_physical_total_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gpu_rendersystem_dll_name = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_gpu_rendersystem_dll_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSource2SystemSpecs.gpu_rendersystem_dll_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpu_vendor_id = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_gpu_vendor_id(&has_bits);
          _impl_.gpu_vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gpu_driver_name = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_gpu_driver_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSource2SystemSpecs.gpu_driver_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpu_driver_version_high = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_gpu_driver_version_high(&has_bits);
          _impl_.gpu_driver_version_high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpu_driver_version_low = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_gpu_driver_version_low(&has_bits);
          _impl_.gpu_driver_version_low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpu_dx_support_level = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_gpu_dx_support_level(&has_bits);
          _impl_.gpu_dx_support_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpu_texture_memory_size_mb = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_gpu_texture_memory_size_mb(&has_bits);
          _impl_.gpu_texture_memory_size_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSource2SystemSpecs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSource2SystemSpecs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string cpu_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cpu_id().data(), static_cast<int>(this->_internal_cpu_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSource2SystemSpecs.cpu_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cpu_id(), target);
  }

  // optional string cpu_brand = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cpu_brand().data(), static_cast<int>(this->_internal_cpu_brand().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSource2SystemSpecs.cpu_brand");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cpu_brand(), target);
  }

  // optional uint32 cpu_model = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_cpu_model(), target);
  }

  // optional uint32 cpu_num_physical = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cpu_num_physical(), target);
  }

  // optional uint32 ram_physical_total_mb = 21;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_ram_physical_total_mb(), target);
  }

  // optional string gpu_rendersystem_dll_name = 41;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gpu_rendersystem_dll_name().data(), static_cast<int>(this->_internal_gpu_rendersystem_dll_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSource2SystemSpecs.gpu_rendersystem_dll_name");
    target = stream->WriteStringMaybeAliased(
        41, this->_internal_gpu_rendersystem_dll_name(), target);
  }

  // optional uint32 gpu_vendor_id = 42;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(42, this->_internal_gpu_vendor_id(), target);
  }

  // optional string gpu_driver_name = 43;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gpu_driver_name().data(), static_cast<int>(this->_internal_gpu_driver_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSource2SystemSpecs.gpu_driver_name");
    target = stream->WriteStringMaybeAliased(
        43, this->_internal_gpu_driver_name(), target);
  }

  // optional uint32 gpu_driver_version_high = 44;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(44, this->_internal_gpu_driver_version_high(), target);
  }

  // optional uint32 gpu_driver_version_low = 45;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(45, this->_internal_gpu_driver_version_low(), target);
  }

  // optional uint32 gpu_dx_support_level = 46;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(46, this->_internal_gpu_dx_support_level(), target);
  }

  // optional uint32 gpu_texture_memory_size_mb = 47;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(47, this->_internal_gpu_texture_memory_size_mb(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSource2SystemSpecs)
  return target;
}

size_t CMsgSource2SystemSpecs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSource2SystemSpecs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string cpu_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_id());
    }

    // optional string cpu_brand = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_brand());
    }

    // optional string gpu_rendersystem_dll_name = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gpu_rendersystem_dll_name());
    }

    // optional string gpu_driver_name = 43;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gpu_driver_name());
    }

    // optional uint32 cpu_model = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpu_model());
    }

    // optional uint32 cpu_num_physical = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpu_num_physical());
    }

    // optional uint32 ram_physical_total_mb = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ram_physical_total_mb());
    }

    // optional uint32 gpu_vendor_id = 42;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpu_vendor_id());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 gpu_driver_version_high = 44;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpu_driver_version_high());
    }

    // optional uint32 gpu_driver_version_low = 45;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpu_driver_version_low());
    }

    // optional uint32 gpu_dx_support_level = 46;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpu_dx_support_level());
    }

    // optional uint32 gpu_texture_memory_size_mb = 47;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpu_texture_memory_size_mb());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSource2SystemSpecs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSource2SystemSpecs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSource2SystemSpecs::GetClassData() const { return &_class_data_; }


void CMsgSource2SystemSpecs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSource2SystemSpecs*>(&to_msg);
  auto& from = static_cast<const CMsgSource2SystemSpecs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSource2SystemSpecs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cpu_id(from._internal_cpu_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cpu_brand(from._internal_cpu_brand());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_gpu_rendersystem_dll_name(from._internal_gpu_rendersystem_dll_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_gpu_driver_name(from._internal_gpu_driver_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cpu_model_ = from._impl_.cpu_model_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cpu_num_physical_ = from._impl_.cpu_num_physical_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ram_physical_total_mb_ = from._impl_.ram_physical_total_mb_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gpu_vendor_id_ = from._impl_.gpu_vendor_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.gpu_driver_version_high_ = from._impl_.gpu_driver_version_high_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.gpu_driver_version_low_ = from._impl_.gpu_driver_version_low_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gpu_dx_support_level_ = from._impl_.gpu_dx_support_level_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.gpu_texture_memory_size_mb_ = from._impl_.gpu_texture_memory_size_mb_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSource2SystemSpecs::CopyFrom(const CMsgSource2SystemSpecs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSource2SystemSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSource2SystemSpecs::IsInitialized() const {
  return true;
}

void CMsgSource2SystemSpecs::InternalSwap(CMsgSource2SystemSpecs* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_id_, lhs_arena,
      &other->_impl_.cpu_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_brand_, lhs_arena,
      &other->_impl_.cpu_brand_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gpu_rendersystem_dll_name_, lhs_arena,
      &other->_impl_.gpu_rendersystem_dll_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gpu_driver_name_, lhs_arena,
      &other->_impl_.gpu_driver_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSource2SystemSpecs, _impl_.gpu_texture_memory_size_mb_)
      + sizeof(CMsgSource2SystemSpecs::_impl_.gpu_texture_memory_size_mb_)
      - PROTOBUF_FIELD_OFFSET(CMsgSource2SystemSpecs, _impl_.cpu_model_)>(
          reinterpret_cast<char*>(&_impl_.cpu_model_),
          reinterpret_cast<char*>(&other->_impl_.cpu_model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSource2SystemSpecs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[15]);
}

// ===================================================================

class CMsgSource2VProfLiteReportItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSource2VProfLiteReportItem>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_usec_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_usec_avg_active(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_usec_p50_active(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_usec_p99_active(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_usec_avg_all(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_usec_p50_all(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_usec_p99_all(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgSource2VProfLiteReportItem::CMsgSource2VProfLiteReportItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSource2VProfLiteReportItem)
}
CMsgSource2VProfLiteReportItem::CMsgSource2VProfLiteReportItem(const CMsgSource2VProfLiteReportItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSource2VProfLiteReportItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.active_samples_){}
    , decltype(_impl_.usec_max_){}
    , decltype(_impl_.usec_avg_active_){}
    , decltype(_impl_.usec_p50_active_){}
    , decltype(_impl_.usec_p99_active_){}
    , decltype(_impl_.usec_avg_all_){}
    , decltype(_impl_.usec_p50_all_){}
    , decltype(_impl_.usec_p99_all_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.active_samples_, &from._impl_.active_samples_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.usec_p99_all_) -
    reinterpret_cast<char*>(&_impl_.active_samples_)) + sizeof(_impl_.usec_p99_all_));
  // @@protoc_insertion_point(copy_constructor:CMsgSource2VProfLiteReportItem)
}

inline void CMsgSource2VProfLiteReportItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.active_samples_){0u}
    , decltype(_impl_.usec_max_){0u}
    , decltype(_impl_.usec_avg_active_){0u}
    , decltype(_impl_.usec_p50_active_){0u}
    , decltype(_impl_.usec_p99_active_){0u}
    , decltype(_impl_.usec_avg_all_){0u}
    , decltype(_impl_.usec_p50_all_){0u}
    , decltype(_impl_.usec_p99_all_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSource2VProfLiteReportItem::~CMsgSource2VProfLiteReportItem() {
  // @@protoc_insertion_point(destructor:CMsgSource2VProfLiteReportItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSource2VProfLiteReportItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgSource2VProfLiteReportItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSource2VProfLiteReportItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSource2VProfLiteReportItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.active_samples_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.usec_p50_all_) -
        reinterpret_cast<char*>(&_impl_.active_samples_)) + sizeof(_impl_.usec_p50_all_));
  }
  _impl_.usec_p99_all_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSource2VProfLiteReportItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSource2VProfLiteReportItem.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active_samples = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_samples(&has_bits);
          _impl_.active_samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_usec_max(&has_bits);
          _impl_.usec_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_avg_active = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_usec_avg_active(&has_bits);
          _impl_.usec_avg_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_p50_active = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_usec_p50_active(&has_bits);
          _impl_.usec_p50_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_p99_active = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_usec_p99_active(&has_bits);
          _impl_.usec_p99_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_avg_all = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_usec_avg_all(&has_bits);
          _impl_.usec_avg_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_p50_all = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_usec_p50_all(&has_bits);
          _impl_.usec_p50_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usec_p99_all = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_usec_p99_all(&has_bits);
          _impl_.usec_p99_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSource2VProfLiteReportItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSource2VProfLiteReportItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSource2VProfLiteReportItem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 active_samples = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_active_samples(), target);
  }

  // optional uint32 usec_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_usec_max(), target);
  }

  // optional uint32 usec_avg_active = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_usec_avg_active(), target);
  }

  // optional uint32 usec_p50_active = 12;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_usec_p50_active(), target);
  }

  // optional uint32 usec_p99_active = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_usec_p99_active(), target);
  }

  // optional uint32 usec_avg_all = 21;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_usec_avg_all(), target);
  }

  // optional uint32 usec_p50_all = 22;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_usec_p50_all(), target);
  }

  // optional uint32 usec_p99_all = 23;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_usec_p99_all(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSource2VProfLiteReportItem)
  return target;
}

size_t CMsgSource2VProfLiteReportItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSource2VProfLiteReportItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 active_samples = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active_samples());
    }

    // optional uint32 usec_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usec_max());
    }

    // optional uint32 usec_avg_active = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usec_avg_active());
    }

    // optional uint32 usec_p50_active = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usec_p50_active());
    }

    // optional uint32 usec_p99_active = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usec_p99_active());
    }

    // optional uint32 usec_avg_all = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_usec_avg_all());
    }

    // optional uint32 usec_p50_all = 22;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_usec_p50_all());
    }

  }
  // optional uint32 usec_p99_all = 23;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_usec_p99_all());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSource2VProfLiteReportItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSource2VProfLiteReportItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSource2VProfLiteReportItem::GetClassData() const { return &_class_data_; }


void CMsgSource2VProfLiteReportItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSource2VProfLiteReportItem*>(&to_msg);
  auto& from = static_cast<const CMsgSource2VProfLiteReportItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSource2VProfLiteReportItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_samples_ = from._impl_.active_samples_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.usec_max_ = from._impl_.usec_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.usec_avg_active_ = from._impl_.usec_avg_active_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.usec_p50_active_ = from._impl_.usec_p50_active_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.usec_p99_active_ = from._impl_.usec_p99_active_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.usec_avg_all_ = from._impl_.usec_avg_all_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.usec_p50_all_ = from._impl_.usec_p50_all_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_usec_p99_all(from._internal_usec_p99_all());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSource2VProfLiteReportItem::CopyFrom(const CMsgSource2VProfLiteReportItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSource2VProfLiteReportItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSource2VProfLiteReportItem::IsInitialized() const {
  return true;
}

void CMsgSource2VProfLiteReportItem::InternalSwap(CMsgSource2VProfLiteReportItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSource2VProfLiteReportItem, _impl_.usec_p99_all_)
      + sizeof(CMsgSource2VProfLiteReportItem::_impl_.usec_p99_all_)
      - PROTOBUF_FIELD_OFFSET(CMsgSource2VProfLiteReportItem, _impl_.active_samples_)>(
          reinterpret_cast<char*>(&_impl_.active_samples_),
          reinterpret_cast<char*>(&other->_impl_.active_samples_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSource2VProfLiteReportItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[16]);
}

// ===================================================================

class CMsgSource2VProfLiteReport::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSource2VProfLiteReport>()._impl_._has_bits_);
  static const ::CMsgSource2VProfLiteReportItem& total(const CMsgSource2VProfLiteReport* msg);
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_discarded_frames(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSource2VProfLiteReportItem&
CMsgSource2VProfLiteReport::_Internal::total(const CMsgSource2VProfLiteReport* msg) {
  return *msg->_impl_.total_;
}
CMsgSource2VProfLiteReport::CMsgSource2VProfLiteReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSource2VProfLiteReport)
}
CMsgSource2VProfLiteReport::CMsgSource2VProfLiteReport(const CMsgSource2VProfLiteReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSource2VProfLiteReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.total_){nullptr}
    , decltype(_impl_.discarded_frames_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_total()) {
    _this->_impl_.total_ = new ::CMsgSource2VProfLiteReportItem(*from._impl_.total_);
  }
  _this->_impl_.discarded_frames_ = from._impl_.discarded_frames_;
  // @@protoc_insertion_point(copy_constructor:CMsgSource2VProfLiteReport)
}

inline void CMsgSource2VProfLiteReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.total_){nullptr}
    , decltype(_impl_.discarded_frames_){0u}
  };
}

CMsgSource2VProfLiteReport::~CMsgSource2VProfLiteReport() {
  // @@protoc_insertion_point(destructor:CMsgSource2VProfLiteReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSource2VProfLiteReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.total_;
}

void CMsgSource2VProfLiteReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSource2VProfLiteReport::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSource2VProfLiteReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.total_ != nullptr);
    _impl_.total_->Clear();
  }
  _impl_.discarded_frames_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSource2VProfLiteReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSource2VProfLiteReportItem total = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_total(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSource2VProfLiteReportItem items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 discarded_frames = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_discarded_frames(&has_bits);
          _impl_.discarded_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSource2VProfLiteReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSource2VProfLiteReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSource2VProfLiteReportItem total = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::total(this),
        _Internal::total(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgSource2VProfLiteReportItem items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 discarded_frames = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_discarded_frames(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSource2VProfLiteReport)
  return target;
}

size_t CMsgSource2VProfLiteReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSource2VProfLiteReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSource2VProfLiteReportItem items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSource2VProfLiteReportItem total = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_);
    }

    // optional uint32 discarded_frames = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_discarded_frames());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSource2VProfLiteReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSource2VProfLiteReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSource2VProfLiteReport::GetClassData() const { return &_class_data_; }


void CMsgSource2VProfLiteReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSource2VProfLiteReport*>(&to_msg);
  auto& from = static_cast<const CMsgSource2VProfLiteReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSource2VProfLiteReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_total()->::CMsgSource2VProfLiteReportItem::MergeFrom(
          from._internal_total());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.discarded_frames_ = from._impl_.discarded_frames_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSource2VProfLiteReport::CopyFrom(const CMsgSource2VProfLiteReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSource2VProfLiteReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSource2VProfLiteReport::IsInitialized() const {
  return true;
}

void CMsgSource2VProfLiteReport::InternalSwap(CMsgSource2VProfLiteReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSource2VProfLiteReport, _impl_.discarded_frames_)
      + sizeof(CMsgSource2VProfLiteReport::_impl_.discarded_frames_)
      - PROTOBUF_FIELD_OFFSET(CMsgSource2VProfLiteReport, _impl_.total_)>(
          reinterpret_cast<char*>(&_impl_.total_),
          reinterpret_cast<char*>(&other->_impl_.total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSource2VProfLiteReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[17]);
}

// ===================================================================

class CCLCMsg_Diagnostic::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_Diagnostic>()._impl_._has_bits_);
  static const ::CMsgSource2SystemSpecs& system_specs(const CCLCMsg_Diagnostic* msg);
  static void set_has_system_specs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSource2VProfLiteReport& vprof_report(const CCLCMsg_Diagnostic* msg);
  static void set_has_vprof_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSource2SystemSpecs&
CCLCMsg_Diagnostic::_Internal::system_specs(const CCLCMsg_Diagnostic* msg) {
  return *msg->_impl_.system_specs_;
}
const ::CMsgSource2VProfLiteReport&
CCLCMsg_Diagnostic::_Internal::vprof_report(const CCLCMsg_Diagnostic* msg) {
  return *msg->_impl_.vprof_report_;
}
CCLCMsg_Diagnostic::CCLCMsg_Diagnostic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_Diagnostic)
}
CCLCMsg_Diagnostic::CCLCMsg_Diagnostic(const CCLCMsg_Diagnostic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_Diagnostic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_specs_){nullptr}
    , decltype(_impl_.vprof_report_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_system_specs()) {
    _this->_impl_.system_specs_ = new ::CMsgSource2SystemSpecs(*from._impl_.system_specs_);
  }
  if (from._internal_has_vprof_report()) {
    _this->_impl_.vprof_report_ = new ::CMsgSource2VProfLiteReport(*from._impl_.vprof_report_);
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_Diagnostic)
}

inline void CCLCMsg_Diagnostic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_specs_){nullptr}
    , decltype(_impl_.vprof_report_){nullptr}
  };
}

CCLCMsg_Diagnostic::~CCLCMsg_Diagnostic() {
  // @@protoc_insertion_point(destructor:CCLCMsg_Diagnostic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_Diagnostic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.system_specs_;
  if (this != internal_default_instance()) delete _impl_.vprof_report_;
}

void CCLCMsg_Diagnostic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_Diagnostic::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_Diagnostic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.system_specs_ != nullptr);
      _impl_.system_specs_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.vprof_report_ != nullptr);
      _impl_.vprof_report_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_Diagnostic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSource2SystemSpecs system_specs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_specs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSource2VProfLiteReport vprof_report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_vprof_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_Diagnostic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_Diagnostic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSource2SystemSpecs system_specs = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::system_specs(this),
        _Internal::system_specs(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSource2VProfLiteReport vprof_report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::vprof_report(this),
        _Internal::vprof_report(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_Diagnostic)
  return target;
}

size_t CCLCMsg_Diagnostic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_Diagnostic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSource2SystemSpecs system_specs = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_specs_);
    }

    // optional .CMsgSource2VProfLiteReport vprof_report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vprof_report_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_Diagnostic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_Diagnostic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_Diagnostic::GetClassData() const { return &_class_data_; }


void CCLCMsg_Diagnostic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_Diagnostic*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_Diagnostic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_Diagnostic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_system_specs()->::CMsgSource2SystemSpecs::MergeFrom(
          from._internal_system_specs());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vprof_report()->::CMsgSource2VProfLiteReport::MergeFrom(
          from._internal_vprof_report());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_Diagnostic::CopyFrom(const CCLCMsg_Diagnostic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_Diagnostic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_Diagnostic::IsInitialized() const {
  return true;
}

void CCLCMsg_Diagnostic::InternalSwap(CCLCMsg_Diagnostic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_Diagnostic, _impl_.vprof_report_)
      + sizeof(CCLCMsg_Diagnostic::_impl_.vprof_report_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_Diagnostic, _impl_.system_specs_)>(
          reinterpret_cast<char*>(&_impl_.system_specs_),
          reinterpret_cast<char*>(&other->_impl_.system_specs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_Diagnostic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[18]);
}

// ===================================================================

class CSource2Metrics_MatchPerfSummary_Notification_Client::_Internal {
 public:
  using HasBits = decltype(std::declval<CSource2Metrics_MatchPerfSummary_Notification_Client>()._impl_._has_bits_);
  static const ::CMsgSource2SystemSpecs& system_specs(const CSource2Metrics_MatchPerfSummary_Notification_Client* msg);
  static void set_has_system_specs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSource2VProfLiteReport& profile(const CSource2Metrics_MatchPerfSummary_Notification_Client* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_build_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSource2SystemSpecs&
CSource2Metrics_MatchPerfSummary_Notification_Client::_Internal::system_specs(const CSource2Metrics_MatchPerfSummary_Notification_Client* msg) {
  return *msg->_impl_.system_specs_;
}
const ::CMsgSource2VProfLiteReport&
CSource2Metrics_MatchPerfSummary_Notification_Client::_Internal::profile(const CSource2Metrics_MatchPerfSummary_Notification_Client* msg) {
  return *msg->_impl_.profile_;
}
CSource2Metrics_MatchPerfSummary_Notification_Client::CSource2Metrics_MatchPerfSummary_Notification_Client(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSource2Metrics_MatchPerfSummary_Notification.Client)
}
CSource2Metrics_MatchPerfSummary_Notification_Client::CSource2Metrics_MatchPerfSummary_Notification_Client(const CSource2Metrics_MatchPerfSummary_Notification_Client& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSource2Metrics_MatchPerfSummary_Notification_Client* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_specs_){nullptr}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.build_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_system_specs()) {
    _this->_impl_.system_specs_ = new ::CMsgSource2SystemSpecs(*from._impl_.system_specs_);
  }
  if (from._internal_has_profile()) {
    _this->_impl_.profile_ = new ::CMsgSource2VProfLiteReport(*from._impl_.profile_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.build_id_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.build_id_));
  // @@protoc_insertion_point(copy_constructor:CSource2Metrics_MatchPerfSummary_Notification.Client)
}

inline void CSource2Metrics_MatchPerfSummary_Notification_Client::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_specs_){nullptr}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.build_id_){0u}
  };
}

CSource2Metrics_MatchPerfSummary_Notification_Client::~CSource2Metrics_MatchPerfSummary_Notification_Client() {
  // @@protoc_insertion_point(destructor:CSource2Metrics_MatchPerfSummary_Notification.Client)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSource2Metrics_MatchPerfSummary_Notification_Client::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.system_specs_;
  if (this != internal_default_instance()) delete _impl_.profile_;
}

void CSource2Metrics_MatchPerfSummary_Notification_Client::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSource2Metrics_MatchPerfSummary_Notification_Client::Clear() {
// @@protoc_insertion_point(message_clear_start:CSource2Metrics_MatchPerfSummary_Notification.Client)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.system_specs_ != nullptr);
      _impl_.system_specs_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.profile_ != nullptr);
      _impl_.profile_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.build_id_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.build_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSource2Metrics_MatchPerfSummary_Notification_Client::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSource2SystemSpecs system_specs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_specs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSource2VProfLiteReport profile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 build_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_build_id(&has_bits);
          _impl_.build_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSource2Metrics_MatchPerfSummary_Notification_Client::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSource2Metrics_MatchPerfSummary_Notification.Client)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSource2SystemSpecs system_specs = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::system_specs(this),
        _Internal::system_specs(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSource2VProfLiteReport profile = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  // optional uint32 build_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_build_id(), target);
  }

  // optional fixed64 steamid = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSource2Metrics_MatchPerfSummary_Notification.Client)
  return target;
}

size_t CSource2Metrics_MatchPerfSummary_Notification_Client::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSource2Metrics_MatchPerfSummary_Notification.Client)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSource2SystemSpecs system_specs = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_specs_);
    }

    // optional .CMsgSource2VProfLiteReport profile = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.profile_);
    }

    // optional fixed64 steamid = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 build_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_build_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSource2Metrics_MatchPerfSummary_Notification_Client::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSource2Metrics_MatchPerfSummary_Notification_Client::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSource2Metrics_MatchPerfSummary_Notification_Client::GetClassData() const { return &_class_data_; }


void CSource2Metrics_MatchPerfSummary_Notification_Client::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSource2Metrics_MatchPerfSummary_Notification_Client*>(&to_msg);
  auto& from = static_cast<const CSource2Metrics_MatchPerfSummary_Notification_Client&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSource2Metrics_MatchPerfSummary_Notification.Client)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_system_specs()->::CMsgSource2SystemSpecs::MergeFrom(
          from._internal_system_specs());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_profile()->::CMsgSource2VProfLiteReport::MergeFrom(
          from._internal_profile());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.build_id_ = from._impl_.build_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSource2Metrics_MatchPerfSummary_Notification_Client::CopyFrom(const CSource2Metrics_MatchPerfSummary_Notification_Client& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSource2Metrics_MatchPerfSummary_Notification.Client)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSource2Metrics_MatchPerfSummary_Notification_Client::IsInitialized() const {
  return true;
}

void CSource2Metrics_MatchPerfSummary_Notification_Client::InternalSwap(CSource2Metrics_MatchPerfSummary_Notification_Client* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.build_id_)
      + sizeof(CSource2Metrics_MatchPerfSummary_Notification_Client::_impl_.build_id_)
      - PROTOBUF_FIELD_OFFSET(CSource2Metrics_MatchPerfSummary_Notification_Client, _impl_.system_specs_)>(
          reinterpret_cast<char*>(&_impl_.system_specs_),
          reinterpret_cast<char*>(&other->_impl_.system_specs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSource2Metrics_MatchPerfSummary_Notification_Client::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[19]);
}

// ===================================================================

class CSource2Metrics_MatchPerfSummary_Notification::_Internal {
 public:
  using HasBits = decltype(std::declval<CSource2Metrics_MatchPerfSummary_Notification>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_build_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgSource2VProfLiteReport& server_profile(const CSource2Metrics_MatchPerfSummary_Notification* msg);
  static void set_has_server_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSource2VProfLiteReport&
CSource2Metrics_MatchPerfSummary_Notification::_Internal::server_profile(const CSource2Metrics_MatchPerfSummary_Notification* msg) {
  return *msg->_impl_.server_profile_;
}
CSource2Metrics_MatchPerfSummary_Notification::CSource2Metrics_MatchPerfSummary_Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSource2Metrics_MatchPerfSummary_Notification)
}
CSource2Metrics_MatchPerfSummary_Notification::CSource2Metrics_MatchPerfSummary_Notification(const CSource2Metrics_MatchPerfSummary_Notification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSource2Metrics_MatchPerfSummary_Notification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clients_){from._impl_.clients_}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.map_){}
    , decltype(_impl_.server_profile_){nullptr}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.server_build_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_mode()) {
    _this->_impl_.game_mode_.Set(from._internal_game_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_map()) {
    _this->_impl_.map_.Set(from._internal_map(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_server_profile()) {
    _this->_impl_.server_profile_ = new ::CMsgSource2VProfLiteReport(*from._impl_.server_profile_);
  }
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.server_build_id_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.server_build_id_));
  // @@protoc_insertion_point(copy_constructor:CSource2Metrics_MatchPerfSummary_Notification)
}

inline void CSource2Metrics_MatchPerfSummary_Notification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clients_){arena}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.map_){}
    , decltype(_impl_.server_profile_){nullptr}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.server_build_id_){0u}
  };
  _impl_.game_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSource2Metrics_MatchPerfSummary_Notification::~CSource2Metrics_MatchPerfSummary_Notification() {
  // @@protoc_insertion_point(destructor:CSource2Metrics_MatchPerfSummary_Notification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSource2Metrics_MatchPerfSummary_Notification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clients_.~RepeatedPtrField();
  _impl_.game_mode_.Destroy();
  _impl_.map_.Destroy();
  if (this != internal_default_instance()) delete _impl_.server_profile_;
}

void CSource2Metrics_MatchPerfSummary_Notification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSource2Metrics_MatchPerfSummary_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:CSource2Metrics_MatchPerfSummary_Notification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clients_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_mode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.map_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.server_profile_ != nullptr);
      _impl_.server_profile_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_build_id_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.server_build_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSource2Metrics_MatchPerfSummary_Notification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string game_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_game_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSource2Metrics_MatchPerfSummary_Notification.game_mode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_build_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_server_build_id(&has_bits);
          _impl_.server_build_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSource2VProfLiteReport server_profile = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_server_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSource2Metrics_MatchPerfSummary_Notification.Client clients = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clients(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string map = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_map();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSource2Metrics_MatchPerfSummary_Notification.map");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSource2Metrics_MatchPerfSummary_Notification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSource2Metrics_MatchPerfSummary_Notification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string game_mode = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_mode().data(), static_cast<int>(this->_internal_game_mode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSource2Metrics_MatchPerfSummary_Notification.game_mode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_game_mode(), target);
  }

  // optional uint32 server_build_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_server_build_id(), target);
  }

  // optional .CMsgSource2VProfLiteReport server_profile = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::server_profile(this),
        _Internal::server_profile(this).GetCachedSize(), target, stream);
  }

  // repeated .CSource2Metrics_MatchPerfSummary_Notification.Client clients = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_clients_size()); i < n; i++) {
    const auto& repfield = this->_internal_clients(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string map = 20;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_map().data(), static_cast<int>(this->_internal_map().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSource2Metrics_MatchPerfSummary_Notification.map");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_map(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSource2Metrics_MatchPerfSummary_Notification)
  return target;
}

size_t CSource2Metrics_MatchPerfSummary_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSource2Metrics_MatchPerfSummary_Notification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSource2Metrics_MatchPerfSummary_Notification.Client clients = 11;
  total_size += 1UL * this->_internal_clients_size();
  for (const auto& msg : this->_impl_.clients_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string game_mode = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_mode());
    }

    // optional string map = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_map());
    }

    // optional .CMsgSource2VProfLiteReport server_profile = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.server_profile_);
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 server_build_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_build_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSource2Metrics_MatchPerfSummary_Notification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSource2Metrics_MatchPerfSummary_Notification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSource2Metrics_MatchPerfSummary_Notification::GetClassData() const { return &_class_data_; }


void CSource2Metrics_MatchPerfSummary_Notification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSource2Metrics_MatchPerfSummary_Notification*>(&to_msg);
  auto& from = static_cast<const CSource2Metrics_MatchPerfSummary_Notification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSource2Metrics_MatchPerfSummary_Notification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.clients_.MergeFrom(from._impl_.clients_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_mode(from._internal_game_mode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_map(from._internal_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_server_profile()->::CMsgSource2VProfLiteReport::MergeFrom(
          from._internal_server_profile());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.server_build_id_ = from._impl_.server_build_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSource2Metrics_MatchPerfSummary_Notification::CopyFrom(const CSource2Metrics_MatchPerfSummary_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSource2Metrics_MatchPerfSummary_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSource2Metrics_MatchPerfSummary_Notification::IsInitialized() const {
  return true;
}

void CSource2Metrics_MatchPerfSummary_Notification::InternalSwap(CSource2Metrics_MatchPerfSummary_Notification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.clients_.InternalSwap(&other->_impl_.clients_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_mode_, lhs_arena,
      &other->_impl_.game_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_, lhs_arena,
      &other->_impl_.map_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSource2Metrics_MatchPerfSummary_Notification, _impl_.server_build_id_)
      + sizeof(CSource2Metrics_MatchPerfSummary_Notification::_impl_.server_build_id_)
      - PROTOBUF_FIELD_OFFSET(CSource2Metrics_MatchPerfSummary_Notification, _impl_.server_profile_)>(
          reinterpret_cast<char*>(&_impl_.server_profile_),
          reinterpret_cast<char*>(&other->_impl_.server_profile_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSource2Metrics_MatchPerfSummary_Notification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[20]);
}

// ===================================================================

class CSVCMsg_ServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ServerInfo>()._impl_._has_bits_);
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_server_count(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_dedicated(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_hltv(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_c_os(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_max_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_max_classes(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_tick_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_game_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_map_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sky_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_host_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_addon_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CSVCMsg_GameSessionConfiguration& game_session_config(const CSVCMsg_ServerInfo* msg);
  static void set_has_game_session_config(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_game_session_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CSVCMsg_GameSessionConfiguration&
CSVCMsg_ServerInfo::_Internal::game_session_config(const CSVCMsg_ServerInfo* msg) {
  return *msg->_impl_.game_session_config_;
}
void CSVCMsg_ServerInfo::clear_game_session_config() {
  if (_impl_.game_session_config_ != nullptr) _impl_.game_session_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ServerInfo)
}
CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(const CSVCMsg_ServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_dir_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.sky_name_){}
    , decltype(_impl_.host_name_){}
    , decltype(_impl_.addon_name_){}
    , decltype(_impl_.game_session_manifest_){}
    , decltype(_impl_.game_session_config_){nullptr}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.server_count_){}
    , decltype(_impl_.is_dedicated_){}
    , decltype(_impl_.is_hltv_){}
    , decltype(_impl_.c_os_){}
    , decltype(_impl_.max_clients_){}
    , decltype(_impl_.max_classes_){}
    , decltype(_impl_.tick_interval_){}
    , decltype(_impl_.player_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_dir()) {
    _this->_impl_.game_dir_.Set(from._internal_game_dir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_map_name()) {
    _this->_impl_.map_name_.Set(from._internal_map_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sky_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sky_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sky_name()) {
    _this->_impl_.sky_name_.Set(from._internal_sky_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host_name()) {
    _this->_impl_.host_name_.Set(from._internal_host_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.addon_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.addon_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_addon_name()) {
    _this->_impl_.addon_name_.Set(from._internal_addon_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_session_manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_session_manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_session_manifest()) {
    _this->_impl_.game_session_manifest_.Set(from._internal_game_session_manifest(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_game_session_config()) {
    _this->_impl_.game_session_config_ = new ::CSVCMsg_GameSessionConfiguration(*from._impl_.game_session_config_);
  }
  ::memcpy(&_impl_.protocol_, &from._impl_.protocol_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_slot_) -
    reinterpret_cast<char*>(&_impl_.protocol_)) + sizeof(_impl_.player_slot_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ServerInfo)
}

inline void CSVCMsg_ServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_dir_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.sky_name_){}
    , decltype(_impl_.host_name_){}
    , decltype(_impl_.addon_name_){}
    , decltype(_impl_.game_session_manifest_){}
    , decltype(_impl_.game_session_config_){nullptr}
    , decltype(_impl_.protocol_){0}
    , decltype(_impl_.server_count_){0}
    , decltype(_impl_.is_dedicated_){false}
    , decltype(_impl_.is_hltv_){false}
    , decltype(_impl_.c_os_){0}
    , decltype(_impl_.max_clients_){0}
    , decltype(_impl_.max_classes_){0}
    , decltype(_impl_.tick_interval_){0}
    , decltype(_impl_.player_slot_){-1}
  };
  _impl_.game_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sky_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sky_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.addon_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.addon_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_session_manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_session_manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ServerInfo::~CSVCMsg_ServerInfo() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_dir_.Destroy();
  _impl_.map_name_.Destroy();
  _impl_.sky_name_.Destroy();
  _impl_.host_name_.Destroy();
  _impl_.addon_name_.Destroy();
  _impl_.game_session_manifest_.Destroy();
  if (this != internal_default_instance()) delete _impl_.game_session_config_;
}

void CSVCMsg_ServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_dir_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.map_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.sky_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.host_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.addon_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.game_session_manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.game_session_config_ != nullptr);
      _impl_.game_session_config_->Clear();
    }
  }
  _impl_.protocol_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.server_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tick_interval_) -
        reinterpret_cast<char*>(&_impl_.server_count_)) + sizeof(_impl_.tick_interval_));
    _impl_.player_slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 protocol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_protocol(&has_bits);
          _impl_.protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 server_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_count(&has_bits);
          _impl_.server_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dedicated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_dedicated(&has_bits);
          _impl_.is_dedicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hltv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_hltv(&has_bits);
          _impl_.is_hltv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 c_os = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_c_os(&has_bits);
          _impl_.c_os_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_clients = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_max_clients(&has_bits);
          _impl_.max_clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_classes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_max_classes(&has_bits);
          _impl_.max_classes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_slot = 12 [default = -1];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float tick_interval = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_tick_interval(&has_bits);
          _impl_.tick_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string game_dir = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_game_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.game_dir");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string map_name = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_map_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.map_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string sky_name = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_sky_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.sky_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string host_name = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_host_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.host_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string addon_name = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_addon_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.addon_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_session_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_session_manifest = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_game_session_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 protocol = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_protocol(), target);
  }

  // optional int32 server_count = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_server_count(), target);
  }

  // optional bool is_dedicated = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_dedicated(), target);
  }

  // optional bool is_hltv = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_hltv(), target);
  }

  // optional int32 c_os = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_c_os(), target);
  }

  // optional int32 max_clients = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_max_clients(), target);
  }

  // optional int32 max_classes = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_max_classes(), target);
  }

  // optional int32 player_slot = 12 [default = -1];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_player_slot(), target);
  }

  // optional float tick_interval = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_tick_interval(), target);
  }

  // optional string game_dir = 14;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_dir().data(), static_cast<int>(this->_internal_game_dir().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.game_dir");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_game_dir(), target);
  }

  // optional string map_name = 15;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_map_name().data(), static_cast<int>(this->_internal_map_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.map_name");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_map_name(), target);
  }

  // optional string sky_name = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sky_name().data(), static_cast<int>(this->_internal_sky_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.sky_name");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_sky_name(), target);
  }

  // optional string host_name = 17;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_host_name().data(), static_cast<int>(this->_internal_host_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.host_name");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_host_name(), target);
  }

  // optional string addon_name = 18;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_addon_name().data(), static_cast<int>(this->_internal_addon_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.addon_name");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_addon_name(), target);
  }

  // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::game_session_config(this),
        _Internal::game_session_config(this).GetCachedSize(), target, stream);
  }

  // optional bytes game_session_manifest = 20;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_game_session_manifest(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ServerInfo)
  return target;
}

size_t CSVCMsg_ServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string game_dir = 14;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_dir());
    }

    // optional string map_name = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_map_name());
    }

    // optional string sky_name = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sky_name());
    }

    // optional string host_name = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host_name());
    }

    // optional string addon_name = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_addon_name());
    }

    // optional bytes game_session_manifest = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_session_manifest());
    }

    // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.game_session_config_);
    }

    // optional int32 protocol = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_protocol());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 server_count = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_server_count());
    }

    // optional bool is_dedicated = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_hltv = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 c_os = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_c_os());
    }

    // optional int32 max_clients = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_clients());
    }

    // optional int32 max_classes = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_classes());
    }

    // optional float tick_interval = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional int32 player_slot = 12 [default = -1];
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ServerInfo::GetClassData() const { return &_class_data_; }


void CSVCMsg_ServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ServerInfo*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_dir(from._internal_game_dir());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_map_name(from._internal_map_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_sky_name(from._internal_sky_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_host_name(from._internal_host_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_addon_name(from._internal_addon_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_game_session_manifest(from._internal_game_session_manifest());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_game_session_config()->::CSVCMsg_GameSessionConfiguration::MergeFrom(
          from._internal_game_session_config());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.protocol_ = from._impl_.protocol_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.server_count_ = from._impl_.server_count_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_dedicated_ = from._impl_.is_dedicated_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_hltv_ = from._impl_.is_hltv_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.c_os_ = from._impl_.c_os_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.max_clients_ = from._impl_.max_clients_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_classes_ = from._impl_.max_classes_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.tick_interval_ = from._impl_.tick_interval_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ServerInfo::CopyFrom(const CSVCMsg_ServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ServerInfo::IsInitialized() const {
  return true;
}

void CSVCMsg_ServerInfo::InternalSwap(CSVCMsg_ServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_dir_, lhs_arena,
      &other->_impl_.game_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_name_, lhs_arena,
      &other->_impl_.map_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sky_name_, lhs_arena,
      &other->_impl_.sky_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_name_, lhs_arena,
      &other->_impl_.host_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.addon_name_, lhs_arena,
      &other->_impl_.addon_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_session_manifest_, lhs_arena,
      &other->_impl_.game_session_manifest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_ServerInfo, _impl_.tick_interval_)
      + sizeof(CSVCMsg_ServerInfo::_impl_.tick_interval_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_ServerInfo, _impl_.game_session_config_)>(
          reinterpret_cast<char*>(&_impl_.game_session_config_),
          reinterpret_cast<char*>(&other->_impl_.game_session_config_));
  swap(_impl_.player_slot_, other->_impl_.player_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[21]);
}

// ===================================================================

class CSVCMsg_ClassInfo_class_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClassInfo_class_t>()._impl_._has_bits_);
  static void set_has_class_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_class_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClassInfo.class_t)
}
CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(const CSVCMsg_ClassInfo_class_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClassInfo_class_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.class_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_class_name()) {
    _this->_impl_.class_name_.Set(from._internal_class_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.class_id_ = from._impl_.class_id_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClassInfo.class_t)
}

inline void CSVCMsg_ClassInfo_class_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.class_id_){0}
  };
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ClassInfo_class_t::~CSVCMsg_ClassInfo_class_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClassInfo.class_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClassInfo_class_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class_name_.Destroy();
}

void CSVCMsg_ClassInfo_class_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClassInfo_class_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClassInfo.class_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.class_name_.ClearNonDefaultToEmpty();
  }
  _impl_.class_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClassInfo_class_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 class_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_class_id(&has_bits);
          _impl_.class_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string class_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_class_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ClassInfo.class_t.class_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClassInfo_class_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClassInfo.class_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 class_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_class_id(), target);
  }

  // optional string class_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_class_name().data(), static_cast<int>(this->_internal_class_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ClassInfo.class_t.class_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_class_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClassInfo.class_t)
  return target;
}

size_t CSVCMsg_ClassInfo_class_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClassInfo.class_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string class_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_class_name());
    }

    // optional int32 class_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_class_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClassInfo_class_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClassInfo_class_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClassInfo_class_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClassInfo_class_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClassInfo_class_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClassInfo_class_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClassInfo.class_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_class_name(from._internal_class_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.class_id_ = from._impl_.class_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClassInfo_class_t::CopyFrom(const CSVCMsg_ClassInfo_class_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClassInfo.class_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClassInfo_class_t::IsInitialized() const {
  return true;
}

void CSVCMsg_ClassInfo_class_t::InternalSwap(CSVCMsg_ClassInfo_class_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class_name_, lhs_arena,
      &other->_impl_.class_name_, rhs_arena
  );
  swap(_impl_.class_id_, other->_impl_.class_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClassInfo_class_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[22]);
}

// ===================================================================

class CSVCMsg_ClassInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClassInfo>()._impl_._has_bits_);
  static void set_has_create_on_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClassInfo)
}
CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(const CSVCMsg_ClassInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClassInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.classes_){from._impl_.classes_}
    , decltype(_impl_.create_on_client_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.create_on_client_ = from._impl_.create_on_client_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClassInfo)
}

inline void CSVCMsg_ClassInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.classes_){arena}
    , decltype(_impl_.create_on_client_){false}
  };
}

CSVCMsg_ClassInfo::~CSVCMsg_ClassInfo() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClassInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClassInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.classes_.~RepeatedPtrField();
}

void CSVCMsg_ClassInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClassInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClassInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.classes_.Clear();
  _impl_.create_on_client_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClassInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool create_on_client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_create_on_client(&has_bits);
          _impl_.create_on_client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_classes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClassInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClassInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool create_on_client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_create_on_client(), target);
  }

  // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_classes_size()); i < n; i++) {
    const auto& repfield = this->_internal_classes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClassInfo)
  return target;
}

size_t CSVCMsg_ClassInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClassInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
  total_size += 1UL * this->_internal_classes_size();
  for (const auto& msg : this->_impl_.classes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool create_on_client = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClassInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClassInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClassInfo::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClassInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClassInfo*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClassInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClassInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.classes_.MergeFrom(from._impl_.classes_);
  if (from._internal_has_create_on_client()) {
    _this->_internal_set_create_on_client(from._internal_create_on_client());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClassInfo::CopyFrom(const CSVCMsg_ClassInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClassInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClassInfo::IsInitialized() const {
  return true;
}

void CSVCMsg_ClassInfo::InternalSwap(CSVCMsg_ClassInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.classes_.InternalSwap(&other->_impl_.classes_);
  swap(_impl_.create_on_client_, other->_impl_.create_on_client_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClassInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[23]);
}

// ===================================================================

class CSVCMsg_SetPause::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SetPause>()._impl_._has_bits_);
  static void set_has_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_SetPause::CSVCMsg_SetPause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SetPause)
}
CSVCMsg_SetPause::CSVCMsg_SetPause(const CSVCMsg_SetPause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SetPause* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.paused_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.paused_ = from._impl_.paused_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SetPause)
}

inline void CSVCMsg_SetPause::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.paused_){false}
  };
}

CSVCMsg_SetPause::~CSVCMsg_SetPause() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SetPause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SetPause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SetPause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SetPause::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SetPause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.paused_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SetPause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool paused = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_paused(&has_bits);
          _impl_.paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SetPause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SetPause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool paused = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_paused(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SetPause)
  return target;
}

size_t CSVCMsg_SetPause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SetPause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool paused = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SetPause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SetPause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SetPause::GetClassData() const { return &_class_data_; }


void CSVCMsg_SetPause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SetPause*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SetPause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SetPause)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_paused()) {
    _this->_internal_set_paused(from._internal_paused());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SetPause::CopyFrom(const CSVCMsg_SetPause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SetPause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SetPause::IsInitialized() const {
  return true;
}

void CSVCMsg_SetPause::InternalSwap(CSVCMsg_SetPause* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.paused_, other->_impl_.paused_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SetPause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[24]);
}

// ===================================================================

class CSVCMsg_VoiceInit::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_VoiceInit>()._impl_._has_bits_);
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_VoiceInit)
}
CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(const CSVCMsg_VoiceInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_VoiceInit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec()) {
    _this->_impl_.codec_.Set(from._internal_codec(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.quality_, &from._impl_.quality_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_VoiceInit)
}

inline void CSVCMsg_VoiceInit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.quality_){0}
    , decltype(_impl_.version_){0}
  };
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_VoiceInit::~CSVCMsg_VoiceInit() {
  // @@protoc_insertion_point(destructor:CSVCMsg_VoiceInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_VoiceInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.codec_.Destroy();
}

void CSVCMsg_VoiceInit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_VoiceInit::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_VoiceInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.codec_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.quality_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_VoiceInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 quality = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string codec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_codec();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_VoiceInit.codec");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_VoiceInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_VoiceInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 quality = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_quality(), target);
  }

  // optional string codec = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_codec().data(), static_cast<int>(this->_internal_codec().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_VoiceInit.codec");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_codec(), target);
  }

  // optional int32 version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_VoiceInit)
  return target;
}

size_t CSVCMsg_VoiceInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_VoiceInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string codec = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_codec());
    }

    // optional int32 quality = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_quality());
    }

    // optional int32 version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_VoiceInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_VoiceInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_VoiceInit::GetClassData() const { return &_class_data_; }


void CSVCMsg_VoiceInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_VoiceInit*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_VoiceInit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_VoiceInit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_codec(from._internal_codec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_VoiceInit::CopyFrom(const CSVCMsg_VoiceInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_VoiceInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_VoiceInit::IsInitialized() const {
  return true;
}

void CSVCMsg_VoiceInit::InternalSwap(CSVCMsg_VoiceInit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.codec_, lhs_arena,
      &other->_impl_.codec_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceInit, _impl_.version_)
      + sizeof(CSVCMsg_VoiceInit::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceInit, _impl_.quality_)>(
          reinterpret_cast<char*>(&_impl_.quality_),
          reinterpret_cast<char*>(&other->_impl_.quality_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_VoiceInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[25]);
}

// ===================================================================

class CSVCMsg_Print::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Print>()._impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Print::CSVCMsg_Print(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Print)
}
CSVCMsg_Print::CSVCMsg_Print(const CSVCMsg_Print& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Print* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Print)
}

inline void CSVCMsg_Print::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Print::~CSVCMsg_Print() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Print)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Print::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void CSVCMsg_Print::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Print::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Print)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Print::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_Print.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Print::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Print)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_Print.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Print)
  return target;
}

size_t CSVCMsg_Print::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Print)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Print::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Print::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Print::GetClassData() const { return &_class_data_; }


void CSVCMsg_Print::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Print*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Print&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Print)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Print::CopyFrom(const CSVCMsg_Print& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Print)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Print::IsInitialized() const {
  return true;
}

void CSVCMsg_Print::InternalSwap(CSVCMsg_Print* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Print::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[26]);
}

// ===================================================================

class CSVCMsg_Sounds_sounddata_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Sounds_sounddata_t>()._impl_._has_bits_);
  static void set_has_origin_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_origin_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_origin_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_delay_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sound_num(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_sound_num_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_speaker_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_sound_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_sentence(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_ambient(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_sound_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Sounds.sounddata_t)
}
CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(const CSVCMsg_Sounds_sounddata_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Sounds_sounddata_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_x_){}
    , decltype(_impl_.origin_y_){}
    , decltype(_impl_.origin_z_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.delay_value_){}
    , decltype(_impl_.sequence_number_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.sound_num_){}
    , decltype(_impl_.sound_num_handle_){}
    , decltype(_impl_.speaker_entity_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.sound_level_){}
    , decltype(_impl_.is_sentence_){}
    , decltype(_impl_.is_ambient_){}
    , decltype(_impl_.guid_){}
    , decltype(_impl_.sound_resource_id_){}
    , decltype(_impl_.entity_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.origin_x_, &from._impl_.origin_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_index_) -
    reinterpret_cast<char*>(&_impl_.origin_x_)) + sizeof(_impl_.entity_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Sounds.sounddata_t)
}

inline void CSVCMsg_Sounds_sounddata_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_x_){0}
    , decltype(_impl_.origin_y_){0}
    , decltype(_impl_.origin_z_){0}
    , decltype(_impl_.volume_){0u}
    , decltype(_impl_.delay_value_){0}
    , decltype(_impl_.sequence_number_){0}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.sound_num_){0u}
    , decltype(_impl_.sound_num_handle_){0u}
    , decltype(_impl_.speaker_entity_){0}
    , decltype(_impl_.random_seed_){0}
    , decltype(_impl_.sound_level_){0}
    , decltype(_impl_.is_sentence_){false}
    , decltype(_impl_.is_ambient_){false}
    , decltype(_impl_.guid_){0u}
    , decltype(_impl_.sound_resource_id_){uint64_t{0u}}
    , decltype(_impl_.entity_index_){-1}
  };
}

CSVCMsg_Sounds_sounddata_t::~CSVCMsg_Sounds_sounddata_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Sounds.sounddata_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Sounds_sounddata_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_Sounds_sounddata_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Sounds_sounddata_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Sounds.sounddata_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.origin_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pitch_) -
        reinterpret_cast<char*>(&_impl_.origin_x_)) + sizeof(_impl_.pitch_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_ambient_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.is_ambient_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.guid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sound_resource_id_) -
        reinterpret_cast<char*>(&_impl_.guid_)) + sizeof(_impl_.sound_resource_id_));
    _impl_.entity_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Sounds_sounddata_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 origin_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_origin_x(&has_bits);
          _impl_.origin_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 origin_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_origin_y(&has_bits);
          _impl_.origin_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 origin_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_origin_z(&has_bits);
          _impl_.origin_z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 volume = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float delay_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_delay_value(&has_bits);
          _impl_.delay_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sequence_number = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_sequence_number(&has_bits);
          _impl_.sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity_index = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 channel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_channel(&has_bits);
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pitch = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pitch(&has_bits);
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sound_num = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_sound_num(&has_bits);
          _impl_.sound_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 sound_num_handle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_sound_num_handle(&has_bits);
          _impl_.sound_num_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 speaker_entity = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_speaker_entity(&has_bits);
          _impl_.speaker_entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sound_level = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_sound_level(&has_bits);
          _impl_.sound_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_sentence = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_sentence(&has_bits);
          _impl_.is_sentence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ambient = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_ambient(&has_bits);
          _impl_.is_ambient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 guid = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_guid(&has_bits);
          _impl_.guid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sound_resource_id = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _Internal::set_has_sound_resource_id(&has_bits);
          _impl_.sound_resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Sounds_sounddata_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Sounds.sounddata_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 origin_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_origin_x(), target);
  }

  // optional sint32 origin_y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_origin_y(), target);
  }

  // optional sint32 origin_z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_origin_z(), target);
  }

  // optional uint32 volume = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_volume(), target);
  }

  // optional float delay_value = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_delay_value(), target);
  }

  // optional int32 sequence_number = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_sequence_number(), target);
  }

  // optional int32 entity_index = 7 [default = -1];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_entity_index(), target);
  }

  // optional int32 channel = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_channel(), target);
  }

  // optional int32 pitch = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_pitch(), target);
  }

  // optional int32 flags = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_flags(), target);
  }

  // optional uint32 sound_num = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_sound_num(), target);
  }

  // optional fixed32 sound_num_handle = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(12, this->_internal_sound_num_handle(), target);
  }

  // optional int32 speaker_entity = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_speaker_entity(), target);
  }

  // optional int32 random_seed = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_random_seed(), target);
  }

  // optional int32 sound_level = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_sound_level(), target);
  }

  // optional bool is_sentence = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_is_sentence(), target);
  }

  // optional bool is_ambient = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_ambient(), target);
  }

  // optional uint32 guid = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_guid(), target);
  }

  // optional fixed64 sound_resource_id = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(19, this->_internal_sound_resource_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Sounds.sounddata_t)
  return target;
}

size_t CSVCMsg_Sounds_sounddata_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Sounds.sounddata_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional sint32 origin_x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_x());
    }

    // optional sint32 origin_y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_y());
    }

    // optional sint32 origin_z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_z());
    }

    // optional uint32 volume = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_volume());
    }

    // optional float delay_value = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 sequence_number = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence_number());
    }

    // optional int32 channel = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
    }

    // optional int32 pitch = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pitch());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 flags = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 sound_num = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sound_num());
    }

    // optional fixed32 sound_num_handle = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional int32 speaker_entity = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_speaker_entity());
    }

    // optional int32 random_seed = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_random_seed());
    }

    // optional int32 sound_level = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sound_level());
    }

    // optional bool is_sentence = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_ambient = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 guid = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_guid());
    }

    // optional fixed64 sound_resource_id = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional int32 entity_index = 7 [default = -1];
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Sounds_sounddata_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Sounds_sounddata_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Sounds_sounddata_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_Sounds_sounddata_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Sounds_sounddata_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Sounds_sounddata_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Sounds.sounddata_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.origin_x_ = from._impl_.origin_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.origin_y_ = from._impl_.origin_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.origin_z_ = from._impl_.origin_z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.delay_value_ = from._impl_.delay_value_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sequence_number_ = from._impl_.sequence_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.channel_ = from._impl_.channel_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pitch_ = from._impl_.pitch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.sound_num_ = from._impl_.sound_num_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sound_num_handle_ = from._impl_.sound_num_handle_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.speaker_entity_ = from._impl_.speaker_entity_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.sound_level_ = from._impl_.sound_level_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_sentence_ = from._impl_.is_sentence_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_ambient_ = from._impl_.is_ambient_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.guid_ = from._impl_.guid_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.sound_resource_id_ = from._impl_.sound_resource_id_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Sounds_sounddata_t::CopyFrom(const CSVCMsg_Sounds_sounddata_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Sounds.sounddata_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Sounds_sounddata_t::IsInitialized() const {
  return true;
}

void CSVCMsg_Sounds_sounddata_t::InternalSwap(CSVCMsg_Sounds_sounddata_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_Sounds_sounddata_t, _impl_.sound_resource_id_)
      + sizeof(CSVCMsg_Sounds_sounddata_t::_impl_.sound_resource_id_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_Sounds_sounddata_t, _impl_.origin_x_)>(
          reinterpret_cast<char*>(&_impl_.origin_x_),
          reinterpret_cast<char*>(&other->_impl_.origin_x_));
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Sounds_sounddata_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[27]);
}

// ===================================================================

class CSVCMsg_Sounds::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Sounds>()._impl_._has_bits_);
  static void set_has_reliable_sound(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Sounds::CSVCMsg_Sounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Sounds)
}
CSVCMsg_Sounds::CSVCMsg_Sounds(const CSVCMsg_Sounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Sounds* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sounds_){from._impl_.sounds_}
    , decltype(_impl_.reliable_sound_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.reliable_sound_ = from._impl_.reliable_sound_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Sounds)
}

inline void CSVCMsg_Sounds::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sounds_){arena}
    , decltype(_impl_.reliable_sound_){false}
  };
}

CSVCMsg_Sounds::~CSVCMsg_Sounds() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Sounds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Sounds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sounds_.~RepeatedPtrField();
}

void CSVCMsg_Sounds::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Sounds::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Sounds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sounds_.Clear();
  _impl_.reliable_sound_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Sounds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable_sound = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable_sound(&has_bits);
          _impl_.reliable_sound_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sounds(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Sounds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Sounds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reliable_sound = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable_sound(), target);
  }

  // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sounds_size()); i < n; i++) {
    const auto& repfield = this->_internal_sounds(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Sounds)
  return target;
}

size_t CSVCMsg_Sounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Sounds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
  total_size += 1UL * this->_internal_sounds_size();
  for (const auto& msg : this->_impl_.sounds_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool reliable_sound = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Sounds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Sounds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Sounds::GetClassData() const { return &_class_data_; }


void CSVCMsg_Sounds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Sounds*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Sounds&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Sounds)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sounds_.MergeFrom(from._impl_.sounds_);
  if (from._internal_has_reliable_sound()) {
    _this->_internal_set_reliable_sound(from._internal_reliable_sound());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Sounds::CopyFrom(const CSVCMsg_Sounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Sounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Sounds::IsInitialized() const {
  return true;
}

void CSVCMsg_Sounds::InternalSwap(CSVCMsg_Sounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sounds_.InternalSwap(&other->_impl_.sounds_);
  swap(_impl_.reliable_sound_, other->_impl_.reliable_sound_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Sounds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[28]);
}

// ===================================================================

class CSVCMsg_Prefetch::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Prefetch>()._impl_._has_bits_);
  static void set_has_sound_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_Prefetch::CSVCMsg_Prefetch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Prefetch)
}
CSVCMsg_Prefetch::CSVCMsg_Prefetch(const CSVCMsg_Prefetch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Prefetch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sound_index_){}
    , decltype(_impl_.resource_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sound_index_, &from._impl_.sound_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resource_type_) -
    reinterpret_cast<char*>(&_impl_.sound_index_)) + sizeof(_impl_.resource_type_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Prefetch)
}

inline void CSVCMsg_Prefetch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sound_index_){0}
    , decltype(_impl_.resource_type_){0}
  };
}

CSVCMsg_Prefetch::~CSVCMsg_Prefetch() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Prefetch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Prefetch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_Prefetch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Prefetch::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Prefetch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.sound_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.resource_type_) -
        reinterpret_cast<char*>(&_impl_.sound_index_)) + sizeof(_impl_.resource_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Prefetch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sound_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sound_index(&has_bits);
          _impl_.sound_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PrefetchType_IsValid(val))) {
            _internal_set_resource_type(static_cast<::PrefetchType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Prefetch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Prefetch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 sound_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sound_index(), target);
  }

  // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_resource_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Prefetch)
  return target;
}

size_t CSVCMsg_Prefetch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Prefetch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 sound_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sound_index());
    }

    // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_resource_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Prefetch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Prefetch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Prefetch::GetClassData() const { return &_class_data_; }


void CSVCMsg_Prefetch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Prefetch*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Prefetch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Prefetch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sound_index_ = from._impl_.sound_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resource_type_ = from._impl_.resource_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Prefetch::CopyFrom(const CSVCMsg_Prefetch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Prefetch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Prefetch::IsInitialized() const {
  return true;
}

void CSVCMsg_Prefetch::InternalSwap(CSVCMsg_Prefetch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_Prefetch, _impl_.resource_type_)
      + sizeof(CSVCMsg_Prefetch::_impl_.resource_type_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_Prefetch, _impl_.sound_index_)>(
          reinterpret_cast<char*>(&_impl_.sound_index_),
          reinterpret_cast<char*>(&other->_impl_.sound_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Prefetch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[29]);
}

// ===================================================================

class CSVCMsg_SetView::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SetView>()._impl_._has_bits_);
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_SetView::CSVCMsg_SetView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SetView)
}
CSVCMsg_SetView::CSVCMsg_SetView(const CSVCMsg_SetView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SetView* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){}
    , decltype(_impl_.slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.entity_index_, &from._impl_.entity_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.slot_) -
    reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.slot_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SetView)
}

inline void CSVCMsg_SetView::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){-1}
    , decltype(_impl_.slot_){-1}
  };
}

CSVCMsg_SetView::~CSVCMsg_SetView() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SetView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SetView::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SetView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SetView::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SetView)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.entity_index_ = -1;
    _impl_.slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SetView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 entity_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SetView::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SetView)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity_index = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_entity_index(), target);
  }

  // optional int32 slot = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SetView)
  return target;
}

size_t CSVCMsg_SetView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SetView)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 entity_index = 1 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

    // optional int32 slot = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SetView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SetView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SetView::GetClassData() const { return &_class_data_; }


void CSVCMsg_SetView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SetView*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SetView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SetView)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_ = from._impl_.slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SetView::CopyFrom(const CSVCMsg_SetView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SetView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SetView::IsInitialized() const {
  return true;
}

void CSVCMsg_SetView::InternalSwap(CSVCMsg_SetView* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SetView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[30]);
}

// ===================================================================

class CSVCMsg_FixAngle::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_FixAngle>()._impl_._has_bits_);
  static void set_has_relative(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& angle(const CSVCMsg_FixAngle* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgQAngle&
CSVCMsg_FixAngle::_Internal::angle(const CSVCMsg_FixAngle* msg) {
  return *msg->_impl_.angle_;
}
void CSVCMsg_FixAngle::clear_angle() {
  if (_impl_.angle_ != nullptr) _impl_.angle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_FixAngle::CSVCMsg_FixAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FixAngle)
}
CSVCMsg_FixAngle::CSVCMsg_FixAngle(const CSVCMsg_FixAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FixAngle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
    , decltype(_impl_.relative_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_angle()) {
    _this->_impl_.angle_ = new ::CMsgQAngle(*from._impl_.angle_);
  }
  _this->_impl_.relative_ = from._impl_.relative_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FixAngle)
}

inline void CSVCMsg_FixAngle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
    , decltype(_impl_.relative_){false}
  };
}

CSVCMsg_FixAngle::~CSVCMsg_FixAngle() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FixAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FixAngle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.angle_;
}

void CSVCMsg_FixAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FixAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FixAngle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.angle_ != nullptr);
    _impl_.angle_->Clear();
  }
  _impl_.relative_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FixAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool relative = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_relative(&has_bits);
          _impl_.relative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FixAngle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FixAngle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool relative = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_relative(), target);
  }

  // optional .CMsgQAngle angle = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angle(this),
        _Internal::angle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FixAngle)
  return target;
}

size_t CSVCMsg_FixAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FixAngle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgQAngle angle = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angle_);
    }

    // optional bool relative = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FixAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FixAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FixAngle::GetClassData() const { return &_class_data_; }


void CSVCMsg_FixAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FixAngle*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FixAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FixAngle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_angle()->::CMsgQAngle::MergeFrom(
          from._internal_angle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.relative_ = from._impl_.relative_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FixAngle::CopyFrom(const CSVCMsg_FixAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FixAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FixAngle::IsInitialized() const {
  return true;
}

void CSVCMsg_FixAngle::InternalSwap(CSVCMsg_FixAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_FixAngle, _impl_.relative_)
      + sizeof(CSVCMsg_FixAngle::_impl_.relative_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_FixAngle, _impl_.angle_)>(
          reinterpret_cast<char*>(&_impl_.angle_),
          reinterpret_cast<char*>(&other->_impl_.angle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FixAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[31]);
}

// ===================================================================

class CSVCMsg_CrosshairAngle::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CrosshairAngle>()._impl_._has_bits_);
  static const ::CMsgQAngle& angle(const CSVCMsg_CrosshairAngle* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgQAngle&
CSVCMsg_CrosshairAngle::_Internal::angle(const CSVCMsg_CrosshairAngle* msg) {
  return *msg->_impl_.angle_;
}
void CSVCMsg_CrosshairAngle::clear_angle() {
  if (_impl_.angle_ != nullptr) _impl_.angle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CrosshairAngle)
}
CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(const CSVCMsg_CrosshairAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CrosshairAngle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_angle()) {
    _this->_impl_.angle_ = new ::CMsgQAngle(*from._impl_.angle_);
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CrosshairAngle)
}

inline void CSVCMsg_CrosshairAngle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
  };
}

CSVCMsg_CrosshairAngle::~CSVCMsg_CrosshairAngle() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CrosshairAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CrosshairAngle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.angle_;
}

void CSVCMsg_CrosshairAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CrosshairAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CrosshairAngle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.angle_ != nullptr);
    _impl_.angle_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CrosshairAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgQAngle angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_angle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CrosshairAngle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CrosshairAngle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgQAngle angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::angle(this),
        _Internal::angle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CrosshairAngle)
  return target;
}

size_t CSVCMsg_CrosshairAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CrosshairAngle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgQAngle angle = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angle_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CrosshairAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CrosshairAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CrosshairAngle::GetClassData() const { return &_class_data_; }


void CSVCMsg_CrosshairAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CrosshairAngle*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CrosshairAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CrosshairAngle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_angle()) {
    _this->_internal_mutable_angle()->::CMsgQAngle::MergeFrom(
        from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CrosshairAngle::CopyFrom(const CSVCMsg_CrosshairAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CrosshairAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CrosshairAngle::IsInitialized() const {
  return true;
}

void CSVCMsg_CrosshairAngle::InternalSwap(CSVCMsg_CrosshairAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CrosshairAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[32]);
}

// ===================================================================

class CSVCMsg_BSPDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_BSPDecal>()._impl_._has_bits_);
  static const ::CMsgVector& pos(const CSVCMsg_BSPDecal* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_decal_texture_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_model_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CSVCMsg_BSPDecal::_Internal::pos(const CSVCMsg_BSPDecal* msg) {
  return *msg->_impl_.pos_;
}
void CSVCMsg_BSPDecal::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_BSPDecal)
}
CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(const CSVCMsg_BSPDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_BSPDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.decal_texture_index_){}
    , decltype(_impl_.model_index_){}
    , decltype(_impl_.low_priority_){}
    , decltype(_impl_.entity_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  ::memcpy(&_impl_.decal_texture_index_, &from._impl_.decal_texture_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_index_) -
    reinterpret_cast<char*>(&_impl_.decal_texture_index_)) + sizeof(_impl_.entity_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_BSPDecal)
}

inline void CSVCMsg_BSPDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.decal_texture_index_){0}
    , decltype(_impl_.model_index_){0}
    , decltype(_impl_.low_priority_){false}
    , decltype(_impl_.entity_index_){-1}
  };
}

CSVCMsg_BSPDecal::~CSVCMsg_BSPDecal() {
  // @@protoc_insertion_point(destructor:CSVCMsg_BSPDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_BSPDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void CSVCMsg_BSPDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_BSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_BSPDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.decal_texture_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.low_priority_) -
        reinterpret_cast<char*>(&_impl_.decal_texture_index_)) + sizeof(_impl_.low_priority_));
    _impl_.entity_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_BSPDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 decal_texture_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_decal_texture_index(&has_bits);
          _impl_.decal_texture_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity_index = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 model_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_model_index(&has_bits);
          _impl_.model_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_priority = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_low_priority(&has_bits);
          _impl_.low_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_BSPDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_BSPDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional int32 decal_texture_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_decal_texture_index(), target);
  }

  // optional int32 entity_index = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entity_index(), target);
  }

  // optional int32 model_index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_model_index(), target);
  }

  // optional bool low_priority = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_low_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_BSPDecal)
  return target;
}

size_t CSVCMsg_BSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_BSPDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional int32 decal_texture_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_decal_texture_index());
    }

    // optional int32 model_index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_index());
    }

    // optional bool low_priority = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int32 entity_index = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_BSPDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_BSPDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_BSPDecal::GetClassData() const { return &_class_data_; }


void CSVCMsg_BSPDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_BSPDecal*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_BSPDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_BSPDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.decal_texture_index_ = from._impl_.decal_texture_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.model_index_ = from._impl_.model_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.low_priority_ = from._impl_.low_priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_BSPDecal::CopyFrom(const CSVCMsg_BSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_BSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_BSPDecal::IsInitialized() const {
  return true;
}

void CSVCMsg_BSPDecal::InternalSwap(CSVCMsg_BSPDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_BSPDecal, _impl_.low_priority_)
      + sizeof(CSVCMsg_BSPDecal::_impl_.low_priority_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_BSPDecal, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_BSPDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[33]);
}

// ===================================================================

class CSVCMsg_SplitScreen::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SplitScreen>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SplitScreen)
}
CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(const CSVCMsg_SplitScreen& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SplitScreen* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.player_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_index_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.player_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SplitScreen)
}

inline void CSVCMsg_SplitScreen::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.player_index_){-1}
  };
}

CSVCMsg_SplitScreen::~CSVCMsg_SplitScreen() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SplitScreen)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SplitScreen::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SplitScreen::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SplitScreen::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SplitScreen)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.slot_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.slot_));
    _impl_.player_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SplitScreen::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESplitScreenMessageType_IsValid(val))) {
            _internal_set_type(static_cast<::ESplitScreenMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_index = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_player_index(&has_bits);
          _impl_.player_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SplitScreen::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SplitScreen)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int32 slot = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot(), target);
  }

  // optional int32 player_index = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_player_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SplitScreen)
  return target;
}

size_t CSVCMsg_SplitScreen::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SplitScreen)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 slot = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
    }

    // optional int32 player_index = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SplitScreen::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SplitScreen::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SplitScreen::GetClassData() const { return &_class_data_; }


void CSVCMsg_SplitScreen::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SplitScreen*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SplitScreen&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SplitScreen)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_ = from._impl_.slot_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_index_ = from._impl_.player_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SplitScreen::CopyFrom(const CSVCMsg_SplitScreen& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SplitScreen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SplitScreen::IsInitialized() const {
  return true;
}

void CSVCMsg_SplitScreen::InternalSwap(CSVCMsg_SplitScreen* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SplitScreen, _impl_.slot_)
      + sizeof(CSVCMsg_SplitScreen::_impl_.slot_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SplitScreen, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
  swap(_impl_.player_index_, other->_impl_.player_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SplitScreen::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[34]);
}

// ===================================================================

class CSVCMsg_GetCvarValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GetCvarValue>()._impl_._has_bits_);
  static void set_has_cookie(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cvar_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GetCvarValue)
}
CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(const CSVCMsg_GetCvarValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GetCvarValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cvar_name_){}
    , decltype(_impl_.cookie_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cvar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cvar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cvar_name()) {
    _this->_impl_.cvar_name_.Set(from._internal_cvar_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.cookie_ = from._impl_.cookie_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GetCvarValue)
}

inline void CSVCMsg_GetCvarValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cvar_name_){}
    , decltype(_impl_.cookie_){0}
  };
  _impl_.cvar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cvar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GetCvarValue::~CSVCMsg_GetCvarValue() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GetCvarValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GetCvarValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cvar_name_.Destroy();
}

void CSVCMsg_GetCvarValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GetCvarValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GetCvarValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cvar_name_.ClearNonDefaultToEmpty();
  }
  _impl_.cookie_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GetCvarValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cookie = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cookie(&has_bits);
          _impl_.cookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cvar_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cvar_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GetCvarValue.cvar_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GetCvarValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GetCvarValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cookie = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cookie(), target);
  }

  // optional string cvar_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cvar_name().data(), static_cast<int>(this->_internal_cvar_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GetCvarValue.cvar_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cvar_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GetCvarValue)
  return target;
}

size_t CSVCMsg_GetCvarValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GetCvarValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string cvar_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cvar_name());
    }

    // optional int32 cookie = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cookie());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GetCvarValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GetCvarValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GetCvarValue::GetClassData() const { return &_class_data_; }


void CSVCMsg_GetCvarValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GetCvarValue*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GetCvarValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GetCvarValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cvar_name(from._internal_cvar_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cookie_ = from._impl_.cookie_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GetCvarValue::CopyFrom(const CSVCMsg_GetCvarValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GetCvarValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GetCvarValue::IsInitialized() const {
  return true;
}

void CSVCMsg_GetCvarValue::InternalSwap(CSVCMsg_GetCvarValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cvar_name_, lhs_arena,
      &other->_impl_.cvar_name_, rhs_arena
  );
  swap(_impl_.cookie_, other->_impl_.cookie_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GetCvarValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[35]);
}

// ===================================================================

class CSVCMsg_Menu::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Menu>()._impl_._has_bits_);
  static void set_has_dialog_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_menu_key_values(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Menu::CSVCMsg_Menu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Menu)
}
CSVCMsg_Menu::CSVCMsg_Menu(const CSVCMsg_Menu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Menu* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.menu_key_values_){}
    , decltype(_impl_.dialog_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.menu_key_values_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.menu_key_values_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_menu_key_values()) {
    _this->_impl_.menu_key_values_.Set(from._internal_menu_key_values(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.dialog_type_ = from._impl_.dialog_type_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Menu)
}

inline void CSVCMsg_Menu::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.menu_key_values_){}
    , decltype(_impl_.dialog_type_){0}
  };
  _impl_.menu_key_values_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.menu_key_values_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Menu::~CSVCMsg_Menu() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Menu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Menu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.menu_key_values_.Destroy();
}

void CSVCMsg_Menu::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Menu::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Menu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.menu_key_values_.ClearNonDefaultToEmpty();
  }
  _impl_.dialog_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Menu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dialog_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dialog_type(&has_bits);
          _impl_.dialog_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes menu_key_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_menu_key_values();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Menu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Menu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dialog_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dialog_type(), target);
  }

  // optional bytes menu_key_values = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_menu_key_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Menu)
  return target;
}

size_t CSVCMsg_Menu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Menu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes menu_key_values = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_menu_key_values());
    }

    // optional int32 dialog_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dialog_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Menu::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Menu::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Menu::GetClassData() const { return &_class_data_; }


void CSVCMsg_Menu::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Menu*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Menu&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Menu)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_menu_key_values(from._internal_menu_key_values());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dialog_type_ = from._impl_.dialog_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Menu::CopyFrom(const CSVCMsg_Menu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Menu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Menu::IsInitialized() const {
  return true;
}

void CSVCMsg_Menu::InternalSwap(CSVCMsg_Menu* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.menu_key_values_, lhs_arena,
      &other->_impl_.menu_key_values_, rhs_arena
  );
  swap(_impl_.dialog_type_, other->_impl_.dialog_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Menu::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[36]);
}

// ===================================================================

class CSVCMsg_UserMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_UserMessage>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_passthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_UserMessage::CSVCMsg_UserMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_UserMessage)
}
CSVCMsg_UserMessage::CSVCMsg_UserMessage(const CSVCMsg_UserMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_UserMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_type_){}
    , decltype(_impl_.passthrough_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_type_, &from._impl_.msg_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.passthrough_) -
    reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.passthrough_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_UserMessage)
}

inline void CSVCMsg_UserMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_type_){0}
    , decltype(_impl_.passthrough_){0}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_UserMessage::~CSVCMsg_UserMessage() {
  // @@protoc_insertion_point(destructor:CSVCMsg_UserMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_UserMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void CSVCMsg_UserMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_UserMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_UserMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.msg_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passthrough_) -
        reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.passthrough_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_UserMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes msg_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passthrough = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_passthrough(&has_bits);
          _impl_.passthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_UserMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_UserMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes msg_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_msg_data(), target);
  }

  // optional int32 passthrough = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_passthrough(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_UserMessage)
  return target;
}

size_t CSVCMsg_UserMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_UserMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes msg_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_msg_data());
    }

    // optional int32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_msg_type());
    }

    // optional int32 passthrough = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passthrough());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_UserMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_UserMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_UserMessage::GetClassData() const { return &_class_data_; }


void CSVCMsg_UserMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_UserMessage*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_UserMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_UserMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.passthrough_ = from._impl_.passthrough_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_UserMessage::CopyFrom(const CSVCMsg_UserMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_UserMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_UserMessage::IsInitialized() const {
  return true;
}

void CSVCMsg_UserMessage::InternalSwap(CSVCMsg_UserMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_UserMessage, _impl_.passthrough_)
      + sizeof(CSVCMsg_UserMessage::_impl_.passthrough_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_UserMessage, _impl_.msg_type_)>(
          reinterpret_cast<char*>(&_impl_.msg_type_),
          reinterpret_cast<char*>(&other->_impl_.msg_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_UserMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[37]);
}

// ===================================================================

class CSVCMsg_SendTable_sendprop_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SendTable_sendprop_t>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_var_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dt_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_elements(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_low_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_high_value(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SendTable.sendprop_t)
}
CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(const CSVCMsg_SendTable_sendprop_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SendTable_sendprop_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_name_){}
    , decltype(_impl_.dt_name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.num_elements_){}
    , decltype(_impl_.low_value_){}
    , decltype(_impl_.high_value_){}
    , decltype(_impl_.num_bits_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_var_name()) {
    _this->_impl_.var_name_.Set(from._internal_var_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dt_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dt_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dt_name()) {
    _this->_impl_.dt_name_.Set(from._internal_dt_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bits_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.num_bits_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SendTable.sendprop_t)
}

inline void CSVCMsg_SendTable_sendprop_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_name_){}
    , decltype(_impl_.dt_name_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.num_elements_){0}
    , decltype(_impl_.low_value_){0}
    , decltype(_impl_.high_value_){0}
    , decltype(_impl_.num_bits_){0}
  };
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dt_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dt_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_SendTable_sendprop_t::~CSVCMsg_SendTable_sendprop_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SendTable.sendprop_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SendTable_sendprop_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_name_.Destroy();
  _impl_.dt_name_.Destroy();
}

void CSVCMsg_SendTable_sendprop_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SendTable_sendprop_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SendTable.sendprop_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.var_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dt_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_value_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.high_value_));
  }
  _impl_.num_bits_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SendTable_sendprop_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string var_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_var_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.sendprop_t.var_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 priority = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dt_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_dt_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.sendprop_t.dt_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_elements = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_elements(&has_bits);
          _impl_.num_elements_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float low_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_low_value(&has_bits);
          _impl_.low_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float high_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_high_value(&has_bits);
          _impl_.high_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_bits = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_num_bits(&has_bits);
          _impl_.num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SendTable_sendprop_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SendTable.sendprop_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional string var_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_var_name().data(), static_cast<int>(this->_internal_var_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.sendprop_t.var_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_var_name(), target);
  }

  // optional int32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional int32 priority = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_priority(), target);
  }

  // optional string dt_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dt_name().data(), static_cast<int>(this->_internal_dt_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.sendprop_t.dt_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_dt_name(), target);
  }

  // optional int32 num_elements = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_num_elements(), target);
  }

  // optional float low_value = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_low_value(), target);
  }

  // optional float high_value = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_high_value(), target);
  }

  // optional int32 num_bits = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_num_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SendTable.sendprop_t)
  return target;
}

size_t CSVCMsg_SendTable_sendprop_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SendTable.sendprop_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string var_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_var_name());
    }

    // optional string dt_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dt_name());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional int32 priority = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
    }

    // optional int32 num_elements = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_elements());
    }

    // optional float low_value = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float high_value = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional int32 num_bits = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bits());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SendTable_sendprop_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SendTable_sendprop_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SendTable_sendprop_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_SendTable_sendprop_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SendTable_sendprop_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SendTable_sendprop_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SendTable.sendprop_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_var_name(from._internal_var_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dt_name(from._internal_dt_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.num_elements_ = from._impl_.num_elements_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.low_value_ = from._impl_.low_value_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.high_value_ = from._impl_.high_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_num_bits(from._internal_num_bits());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SendTable_sendprop_t::CopyFrom(const CSVCMsg_SendTable_sendprop_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SendTable.sendprop_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SendTable_sendprop_t::IsInitialized() const {
  return true;
}

void CSVCMsg_SendTable_sendprop_t::InternalSwap(CSVCMsg_SendTable_sendprop_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_name_, lhs_arena,
      &other->_impl_.var_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dt_name_, lhs_arena,
      &other->_impl_.dt_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable_sendprop_t, _impl_.num_bits_)
      + sizeof(CSVCMsg_SendTable_sendprop_t::_impl_.num_bits_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable_sendprop_t, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SendTable_sendprop_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[38]);
}

// ===================================================================

class CSVCMsg_SendTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SendTable>()._impl_._has_bits_);
  static void set_has_is_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_table_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needs_decoder(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_SendTable::CSVCMsg_SendTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SendTable)
}
CSVCMsg_SendTable::CSVCMsg_SendTable(const CSVCMsg_SendTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SendTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_){from._impl_.props_}
    , decltype(_impl_.net_table_name_){}
    , decltype(_impl_.is_end_){}
    , decltype(_impl_.needs_decoder_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_table_name()) {
    _this->_impl_.net_table_name_.Set(from._internal_net_table_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_end_, &from._impl_.is_end_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.needs_decoder_) -
    reinterpret_cast<char*>(&_impl_.is_end_)) + sizeof(_impl_.needs_decoder_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SendTable)
}

inline void CSVCMsg_SendTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_){arena}
    , decltype(_impl_.net_table_name_){}
    , decltype(_impl_.is_end_){false}
    , decltype(_impl_.needs_decoder_){false}
  };
  _impl_.net_table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_SendTable::~CSVCMsg_SendTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SendTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SendTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.props_.~RepeatedPtrField();
  _impl_.net_table_name_.Destroy();
}

void CSVCMsg_SendTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SendTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SendTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.props_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_table_name_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.is_end_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.needs_decoder_) -
      reinterpret_cast<char*>(&_impl_.is_end_)) + sizeof(_impl_.needs_decoder_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SendTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_end(&has_bits);
          _impl_.is_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string net_table_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_net_table_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.net_table_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_decoder = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_needs_decoder(&has_bits);
          _impl_.needs_decoder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_props(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SendTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SendTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_end = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_end(), target);
  }

  // optional string net_table_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_net_table_name().data(), static_cast<int>(this->_internal_net_table_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.net_table_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_net_table_name(), target);
  }

  // optional bool needs_decoder = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_needs_decoder(), target);
  }

  // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_props_size()); i < n; i++) {
    const auto& repfield = this->_internal_props(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SendTable)
  return target;
}

size_t CSVCMsg_SendTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SendTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
  total_size += 1UL * this->_internal_props_size();
  for (const auto& msg : this->_impl_.props_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string net_table_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_net_table_name());
    }

    // optional bool is_end = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool needs_decoder = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SendTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SendTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SendTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_SendTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SendTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SendTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SendTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.props_.MergeFrom(from._impl_.props_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_table_name(from._internal_net_table_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_end_ = from._impl_.is_end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.needs_decoder_ = from._impl_.needs_decoder_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SendTable::CopyFrom(const CSVCMsg_SendTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SendTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SendTable::IsInitialized() const {
  return true;
}

void CSVCMsg_SendTable::InternalSwap(CSVCMsg_SendTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.props_.InternalSwap(&other->_impl_.props_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_table_name_, lhs_arena,
      &other->_impl_.net_table_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable, _impl_.needs_decoder_)
      + sizeof(CSVCMsg_SendTable::_impl_.needs_decoder_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable, _impl_.is_end_)>(
          reinterpret_cast<char*>(&_impl_.is_end_),
          reinterpret_cast<char*>(&other->_impl_.is_end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SendTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[39]);
}

// ===================================================================

class CSVCMsg_GameEventList_key_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GameEventList_key_t>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList.key_t)
}
CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(const CSVCMsg_GameEventList_key_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList_key_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList.key_t)
}

inline void CSVCMsg_GameEventList_key_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GameEventList_key_t::~CSVCMsg_GameEventList_key_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList.key_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList_key_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CSVCMsg_GameEventList_key_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList_key_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList.key_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList_key_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GameEventList.key_t.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList_key_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList.key_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GameEventList.key_t.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList.key_t)
  return target;
}

size_t CSVCMsg_GameEventList_key_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList.key_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList_key_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList_key_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList_key_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList_key_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList_key_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList_key_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList.key_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList_key_t::CopyFrom(const CSVCMsg_GameEventList_key_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList.key_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList_key_t::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList_key_t::InternalSwap(CSVCMsg_GameEventList_key_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList_key_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[40]);
}

// ===================================================================

class CSVCMsg_GameEventList_descriptor_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GameEventList_descriptor_t>()._impl_._has_bits_);
  static void set_has_eventid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList.descriptor_t)
}
CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(const CSVCMsg_GameEventList_descriptor_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList_descriptor_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.eventid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.eventid_ = from._impl_.eventid_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList.descriptor_t)
}

inline void CSVCMsg_GameEventList_descriptor_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.eventid_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GameEventList_descriptor_t::~CSVCMsg_GameEventList_descriptor_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList.descriptor_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList_descriptor_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CSVCMsg_GameEventList_descriptor_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList_descriptor_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList.descriptor_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.eventid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList_descriptor_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eventid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eventid(&has_bits);
          _impl_.eventid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GameEventList.descriptor_t.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_GameEventList.key_t keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList_descriptor_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList.descriptor_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eventid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eventid(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GameEventList.descriptor_t.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated .CSVCMsg_GameEventList.key_t keys = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList.descriptor_t)
  return target;
}

size_t CSVCMsg_GameEventList_descriptor_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList.descriptor_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.key_t keys = 3;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 eventid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eventid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList_descriptor_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList_descriptor_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList_descriptor_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList_descriptor_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList_descriptor_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList_descriptor_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList.descriptor_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.eventid_ = from._impl_.eventid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList_descriptor_t::CopyFrom(const CSVCMsg_GameEventList_descriptor_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList.descriptor_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList_descriptor_t::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList_descriptor_t::InternalSwap(CSVCMsg_GameEventList_descriptor_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.eventid_, other->_impl_.eventid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList_descriptor_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[41]);
}

// ===================================================================

class CSVCMsg_GameEventList::_Internal {
 public:
};

CSVCMsg_GameEventList::CSVCMsg_GameEventList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList)
}
CSVCMsg_GameEventList::CSVCMsg_GameEventList(const CSVCMsg_GameEventList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.descriptors_){from._impl_.descriptors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList)
}

inline void CSVCMsg_GameEventList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.descriptors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_GameEventList::~CSVCMsg_GameEventList() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.descriptors_.~RepeatedPtrField();
}

void CSVCMsg_GameEventList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.descriptors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_descriptors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_descriptors_size()); i < n; i++) {
    const auto& repfield = this->_internal_descriptors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList)
  return target;
}

size_t CSVCMsg_GameEventList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
  total_size += 1UL * this->_internal_descriptors_size();
  for (const auto& msg : this->_impl_.descriptors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.descriptors_.MergeFrom(from._impl_.descriptors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList::CopyFrom(const CSVCMsg_GameEventList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList::InternalSwap(CSVCMsg_GameEventList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.descriptors_.InternalSwap(&other->_impl_.descriptors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[42]);
}

// ===================================================================

class CSVCMsg_PacketEntities_alternate_baseline_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities_alternate_baseline_t>()._impl_._has_bits_);
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_baseline_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities.alternate_baseline_t)
}
CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(const CSVCMsg_PacketEntities_alternate_baseline_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities_alternate_baseline_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){}
    , decltype(_impl_.baseline_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.entity_index_, &from._impl_.entity_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.baseline_index_) -
    reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.baseline_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities.alternate_baseline_t)
}

inline void CSVCMsg_PacketEntities_alternate_baseline_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){0}
    , decltype(_impl_.baseline_index_){0}
  };
}

CSVCMsg_PacketEntities_alternate_baseline_t::~CSVCMsg_PacketEntities_alternate_baseline_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities.alternate_baseline_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities_alternate_baseline_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.entity_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.baseline_index_) -
        reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.baseline_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities_alternate_baseline_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 entity_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_baseline_index(&has_bits);
          _impl_.baseline_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities_alternate_baseline_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_entity_index(), target);
  }

  // optional int32 baseline_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_baseline_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities.alternate_baseline_t)
  return target;
}

size_t CSVCMsg_PacketEntities_alternate_baseline_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 entity_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

    // optional int32 baseline_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities_alternate_baseline_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities_alternate_baseline_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities_alternate_baseline_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities_alternate_baseline_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities_alternate_baseline_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities_alternate_baseline_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.baseline_index_ = from._impl_.baseline_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::CopyFrom(const CSVCMsg_PacketEntities_alternate_baseline_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities_alternate_baseline_t::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities_alternate_baseline_t::InternalSwap(CSVCMsg_PacketEntities_alternate_baseline_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.baseline_index_)
      + sizeof(CSVCMsg_PacketEntities_alternate_baseline_t::_impl_.baseline_index_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.entity_index_)>(
          reinterpret_cast<char*>(&_impl_.entity_index_),
          reinterpret_cast<char*>(&other->_impl_.entity_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities_alternate_baseline_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[43]);
}

// ===================================================================

class CSVCMsg_PacketEntities_non_transmitted_entities_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities_non_transmitted_entities_t>()._impl_._has_bits_);
  static void set_has_header_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
}
CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(const CSVCMsg_PacketEntities_non_transmitted_entities_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities_non_transmitted_entities_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.header_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.header_count_ = from._impl_.header_count_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
}

inline void CSVCMsg_PacketEntities_non_transmitted_entities_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.header_count_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_PacketEntities_non_transmitted_entities_t::~CSVCMsg_PacketEntities_non_transmitted_entities_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities_non_transmitted_entities_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_.header_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities_non_transmitted_entities_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 header_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_header_count(&has_bits);
          _impl_.header_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities_non_transmitted_entities_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 header_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_header_count(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  return target;
}

size_t CSVCMsg_PacketEntities_non_transmitted_entities_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 header_count = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_header_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities_non_transmitted_entities_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities_non_transmitted_entities_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities_non_transmitted_entities_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities_non_transmitted_entities_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.header_count_ = from._impl_.header_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::CopyFrom(const CSVCMsg_PacketEntities_non_transmitted_entities_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities_non_transmitted_entities_t::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::InternalSwap(CSVCMsg_PacketEntities_non_transmitted_entities_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.header_count_, other->_impl_.header_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities_non_transmitted_entities_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[44]);
}

// ===================================================================

class CSVCMsg_PacketEntities::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities>()._impl_._has_bits_);
  static void set_has_max_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_updated_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_legacy_is_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_update_baseline(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_baseline(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_delta_from(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_entity_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pending_full_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_active_spawngroup_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_max_spawngroup_creationsequence(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_last_cmd_number_executed(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_last_cmd_number_recv_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_server_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_serialized_entities(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_has_pvs_vis_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::CSVCMsg_PacketEntities_non_transmitted_entities_t& non_transmitted_entities(const CSVCMsg_PacketEntities* msg);
  static void set_has_non_transmitted_entities(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cq_starved_command_ticks(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_cq_discarded_command_ticks(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_dev_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CSVCMsg_PacketEntities_non_transmitted_entities_t&
CSVCMsg_PacketEntities::_Internal::non_transmitted_entities(const CSVCMsg_PacketEntities* msg) {
  return *msg->_impl_.non_transmitted_entities_;
}
CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities)
}
CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(const CSVCMsg_PacketEntities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alternate_baselines_){from._impl_.alternate_baselines_}
    , decltype(_impl_.cmd_recv_status_){from._impl_.cmd_recv_status_}
    , /*decltype(_impl_._cmd_recv_status_cached_byte_size_)*/{0}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.serialized_entities_){}
    , decltype(_impl_.dev_padding_){}
    , decltype(_impl_.non_transmitted_entities_){nullptr}
    , decltype(_impl_.max_entries_){}
    , decltype(_impl_.updated_entries_){}
    , decltype(_impl_.baseline_){}
    , decltype(_impl_.legacy_is_delta_){}
    , decltype(_impl_.update_baseline_){}
    , decltype(_impl_.pending_full_frame_){}
    , decltype(_impl_.delta_from_){}
    , decltype(_impl_.active_spawngroup_handle_){}
    , decltype(_impl_.max_spawngroup_creationsequence_){}
    , decltype(_impl_.last_cmd_number_executed_){}
    , decltype(_impl_.server_tick_){}
    , decltype(_impl_.has_pvs_vis_bits_){}
    , decltype(_impl_.last_cmd_number_recv_delta_){}
    , decltype(_impl_.cq_starved_command_ticks_){}
    , decltype(_impl_.cq_discarded_command_ticks_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_data()) {
    _this->_impl_.entity_data_.Set(from._internal_entity_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serialized_entities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_entities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_entities()) {
    _this->_impl_.serialized_entities_.Set(from._internal_serialized_entities(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dev_padding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_padding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dev_padding()) {
    _this->_impl_.dev_padding_.Set(from._internal_dev_padding(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_non_transmitted_entities()) {
    _this->_impl_.non_transmitted_entities_ = new ::CSVCMsg_PacketEntities_non_transmitted_entities_t(*from._impl_.non_transmitted_entities_);
  }
  ::memcpy(&_impl_.max_entries_, &from._impl_.max_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cq_discarded_command_ticks_) -
    reinterpret_cast<char*>(&_impl_.max_entries_)) + sizeof(_impl_.cq_discarded_command_ticks_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities)
}

inline void CSVCMsg_PacketEntities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alternate_baselines_){arena}
    , decltype(_impl_.cmd_recv_status_){arena}
    , /*decltype(_impl_._cmd_recv_status_cached_byte_size_)*/{0}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.serialized_entities_){}
    , decltype(_impl_.dev_padding_){}
    , decltype(_impl_.non_transmitted_entities_){nullptr}
    , decltype(_impl_.max_entries_){0}
    , decltype(_impl_.updated_entries_){0}
    , decltype(_impl_.baseline_){0}
    , decltype(_impl_.legacy_is_delta_){false}
    , decltype(_impl_.update_baseline_){false}
    , decltype(_impl_.pending_full_frame_){false}
    , decltype(_impl_.delta_from_){0}
    , decltype(_impl_.active_spawngroup_handle_){0u}
    , decltype(_impl_.max_spawngroup_creationsequence_){0u}
    , decltype(_impl_.last_cmd_number_executed_){0u}
    , decltype(_impl_.server_tick_){0u}
    , decltype(_impl_.has_pvs_vis_bits_){0u}
    , decltype(_impl_.last_cmd_number_recv_delta_){0}
    , decltype(_impl_.cq_starved_command_ticks_){0u}
    , decltype(_impl_.cq_discarded_command_ticks_){0u}
  };
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_entities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_entities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dev_padding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_padding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_PacketEntities::~CSVCMsg_PacketEntities() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.alternate_baselines_.~RepeatedPtrField();
  _impl_.cmd_recv_status_.~RepeatedField();
  _impl_.entity_data_.Destroy();
  _impl_.serialized_entities_.Destroy();
  _impl_.dev_padding_.Destroy();
  if (this != internal_default_instance()) delete _impl_.non_transmitted_entities_;
}

void CSVCMsg_PacketEntities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.alternate_baselines_.Clear();
  _impl_.cmd_recv_status_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.entity_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.serialized_entities_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.dev_padding_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.non_transmitted_entities_ != nullptr);
      _impl_.non_transmitted_entities_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.max_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.legacy_is_delta_) -
        reinterpret_cast<char*>(&_impl_.max_entries_)) + sizeof(_impl_.legacy_is_delta_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.update_baseline_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.has_pvs_vis_bits_) -
        reinterpret_cast<char*>(&_impl_.update_baseline_)) + sizeof(_impl_.has_pvs_vis_bits_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.last_cmd_number_recv_delta_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cq_discarded_command_ticks_) -
        reinterpret_cast<char*>(&_impl_.last_cmd_number_recv_delta_)) + sizeof(_impl_.cq_discarded_command_ticks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 max_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_max_entries(&has_bits);
          _impl_.max_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 updated_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_updated_entries(&has_bits);
          _impl_.updated_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool legacy_is_delta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_legacy_is_delta(&has_bits);
          _impl_.legacy_is_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool update_baseline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_update_baseline(&has_bits);
          _impl_.update_baseline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_baseline(&has_bits);
          _impl_.baseline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 delta_from = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_delta_from(&has_bits);
          _impl_.delta_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes entity_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_entity_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pending_full_frame = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pending_full_frame(&has_bits);
          _impl_.pending_full_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active_spawngroup_handle = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_active_spawngroup_handle(&has_bits);
          _impl_.active_spawngroup_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_spawngroup_creationsequence = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_max_spawngroup_creationsequence(&has_bits);
          _impl_.max_spawngroup_creationsequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_cmd_number_executed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_last_cmd_number_executed(&has_bits);
          _impl_.last_cmd_number_executed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_tick = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_server_tick(&has_bits);
          _impl_.server_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_entities = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_serialized_entities();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alternate_baselines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 has_pvs_vis_bits = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_pvs_vis_bits(&has_bits);
          _impl_.has_pvs_vis_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 last_cmd_number_recv_delta = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_last_cmd_number_recv_delta(&has_bits);
          _impl_.last_cmd_number_recv_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_non_transmitted_entities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cq_starved_command_ticks = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_cq_starved_command_ticks(&has_bits);
          _impl_.cq_starved_command_ticks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cq_discarded_command_ticks = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_cq_discarded_command_ticks(&has_bits);
          _impl_.cq_discarded_command_ticks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sint32 cmd_recv_status = 22 [packed = true];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_cmd_recv_status(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 176) {
          _internal_add_cmd_recv_status(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dev_padding = 999;
      case 999:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_dev_padding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 max_entries = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_entries(), target);
  }

  // optional int32 updated_entries = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_updated_entries(), target);
  }

  // optional bool legacy_is_delta = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_legacy_is_delta(), target);
  }

  // optional bool update_baseline = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_update_baseline(), target);
  }

  // optional int32 baseline = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_baseline(), target);
  }

  // optional int32 delta_from = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_delta_from(), target);
  }

  // optional bytes entity_data = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_entity_data(), target);
  }

  // optional bool pending_full_frame = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_pending_full_frame(), target);
  }

  // optional uint32 active_spawngroup_handle = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_active_spawngroup_handle(), target);
  }

  // optional uint32 max_spawngroup_creationsequence = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_max_spawngroup_creationsequence(), target);
  }

  // optional uint32 last_cmd_number_executed = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_last_cmd_number_executed(), target);
  }

  // optional uint32 server_tick = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_server_tick(), target);
  }

  // optional bytes serialized_entities = 13;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_serialized_entities(), target);
  }

  // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alternate_baselines_size()); i < n; i++) {
    const auto& repfield = this->_internal_alternate_baselines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 has_pvs_vis_bits = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_has_pvs_vis_bits(), target);
  }

  // optional sint32 last_cmd_number_recv_delta = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(17, this->_internal_last_cmd_number_recv_delta(), target);
  }

  // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::non_transmitted_entities(this),
        _Internal::non_transmitted_entities(this).GetCachedSize(), target, stream);
  }

  // optional uint32 cq_starved_command_ticks = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_cq_starved_command_ticks(), target);
  }

  // optional uint32 cq_discarded_command_ticks = 21;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_cq_discarded_command_ticks(), target);
  }

  // repeated sint32 cmd_recv_status = 22 [packed = true];
  {
    int byte_size = _impl_._cmd_recv_status_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteSInt32Packed(
          22, _internal_cmd_recv_status(), byte_size, target);
    }
  }

  // optional bytes dev_padding = 999;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        999, this->_internal_dev_padding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities)
  return target;
}

size_t CSVCMsg_PacketEntities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
  total_size += 1UL * this->_internal_alternate_baselines_size();
  for (const auto& msg : this->_impl_.alternate_baselines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated sint32 cmd_recv_status = 22 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      SInt32Size(this->_impl_.cmd_recv_status_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._cmd_recv_status_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes entity_data = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_entity_data());
    }

    // optional bytes serialized_entities = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_entities());
    }

    // optional bytes dev_padding = 999;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dev_padding());
    }

    // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.non_transmitted_entities_);
    }

    // optional int32 max_entries = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_entries());
    }

    // optional int32 updated_entries = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_updated_entries());
    }

    // optional int32 baseline = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline());
    }

    // optional bool legacy_is_delta = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool update_baseline = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool pending_full_frame = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int32 delta_from = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delta_from());
    }

    // optional uint32 active_spawngroup_handle = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active_spawngroup_handle());
    }

    // optional uint32 max_spawngroup_creationsequence = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_spawngroup_creationsequence());
    }

    // optional uint32 last_cmd_number_executed = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_cmd_number_executed());
    }

    // optional uint32 server_tick = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_tick());
    }

    // optional uint32 has_pvs_vis_bits = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_has_pvs_vis_bits());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional sint32 last_cmd_number_recv_delta = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::SInt32Size(
          this->_internal_last_cmd_number_recv_delta());
    }

    // optional uint32 cq_starved_command_ticks = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_cq_starved_command_ticks());
    }

    // optional uint32 cq_discarded_command_ticks = 21;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_cq_discarded_command_ticks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.alternate_baselines_.MergeFrom(from._impl_.alternate_baselines_);
  _this->_impl_.cmd_recv_status_.MergeFrom(from._impl_.cmd_recv_status_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_data(from._internal_entity_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_serialized_entities(from._internal_serialized_entities());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_dev_padding(from._internal_dev_padding());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_non_transmitted_entities()->::CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeFrom(
          from._internal_non_transmitted_entities());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.max_entries_ = from._impl_.max_entries_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.updated_entries_ = from._impl_.updated_entries_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.baseline_ = from._impl_.baseline_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.legacy_is_delta_ = from._impl_.legacy_is_delta_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.update_baseline_ = from._impl_.update_baseline_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pending_full_frame_ = from._impl_.pending_full_frame_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.delta_from_ = from._impl_.delta_from_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.active_spawngroup_handle_ = from._impl_.active_spawngroup_handle_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.max_spawngroup_creationsequence_ = from._impl_.max_spawngroup_creationsequence_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.last_cmd_number_executed_ = from._impl_.last_cmd_number_executed_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.server_tick_ = from._impl_.server_tick_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.has_pvs_vis_bits_ = from._impl_.has_pvs_vis_bits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.last_cmd_number_recv_delta_ = from._impl_.last_cmd_number_recv_delta_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.cq_starved_command_ticks_ = from._impl_.cq_starved_command_ticks_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.cq_discarded_command_ticks_ = from._impl_.cq_discarded_command_ticks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities::CopyFrom(const CSVCMsg_PacketEntities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities::InternalSwap(CSVCMsg_PacketEntities* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.alternate_baselines_.InternalSwap(&other->_impl_.alternate_baselines_);
  _impl_.cmd_recv_status_.InternalSwap(&other->_impl_.cmd_recv_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_data_, lhs_arena,
      &other->_impl_.entity_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_entities_, lhs_arena,
      &other->_impl_.serialized_entities_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dev_padding_, lhs_arena,
      &other->_impl_.dev_padding_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities, _impl_.cq_discarded_command_ticks_)
      + sizeof(CSVCMsg_PacketEntities::_impl_.cq_discarded_command_ticks_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities, _impl_.non_transmitted_entities_)>(
          reinterpret_cast<char*>(&_impl_.non_transmitted_entities_),
          reinterpret_cast<char*>(&other->_impl_.non_transmitted_entities_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[45]);
}

// ===================================================================

class CSVCMsg_TempEntities::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_TempEntities>()._impl_._has_bits_);
  static void set_has_reliable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_entity_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_TempEntities::CSVCMsg_TempEntities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_TempEntities)
}
CSVCMsg_TempEntities::CSVCMsg_TempEntities(const CSVCMsg_TempEntities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_TempEntities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.reliable_){}
    , decltype(_impl_.num_entries_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_data()) {
    _this->_impl_.entity_data_.Set(from._internal_entity_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.reliable_, &from._impl_.reliable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_entries_) -
    reinterpret_cast<char*>(&_impl_.reliable_)) + sizeof(_impl_.num_entries_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_TempEntities)
}

inline void CSVCMsg_TempEntities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.reliable_){false}
    , decltype(_impl_.num_entries_){0}
  };
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_TempEntities::~CSVCMsg_TempEntities() {
  // @@protoc_insertion_point(destructor:CSVCMsg_TempEntities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_TempEntities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entity_data_.Destroy();
}

void CSVCMsg_TempEntities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_TempEntities::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_TempEntities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.entity_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.reliable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_entries_) -
        reinterpret_cast<char*>(&_impl_.reliable_)) + sizeof(_impl_.num_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_TempEntities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable(&has_bits);
          _impl_.reliable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_entries(&has_bits);
          _impl_.num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes entity_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_entity_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_TempEntities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_TempEntities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reliable = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable(), target);
  }

  // optional int32 num_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_entries(), target);
  }

  // optional bytes entity_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_entity_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_TempEntities)
  return target;
}

size_t CSVCMsg_TempEntities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_TempEntities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes entity_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_entity_data());
    }

    // optional bool reliable = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 num_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_TempEntities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_TempEntities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_TempEntities::GetClassData() const { return &_class_data_; }


void CSVCMsg_TempEntities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_TempEntities*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_TempEntities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_TempEntities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_data(from._internal_entity_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.reliable_ = from._impl_.reliable_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_entries_ = from._impl_.num_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_TempEntities::CopyFrom(const CSVCMsg_TempEntities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_TempEntities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_TempEntities::IsInitialized() const {
  return true;
}

void CSVCMsg_TempEntities::InternalSwap(CSVCMsg_TempEntities* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_data_, lhs_arena,
      &other->_impl_.entity_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_TempEntities, _impl_.num_entries_)
      + sizeof(CSVCMsg_TempEntities::_impl_.num_entries_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_TempEntities, _impl_.reliable_)>(
          reinterpret_cast<char*>(&_impl_.reliable_),
          reinterpret_cast<char*>(&other->_impl_.reliable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_TempEntities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[46]);
}

// ===================================================================

class CSVCMsg_CreateStringTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CreateStringTable>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_data_fixed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_data_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_data_size_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_string_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uncompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_data_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_using_varint_bitcounts(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CreateStringTable)
}
CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(const CSVCMsg_CreateStringTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CreateStringTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.num_entries_){}
    , decltype(_impl_.user_data_size_){}
    , decltype(_impl_.user_data_size_bits_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.user_data_fixed_size_){}
    , decltype(_impl_.data_compressed_){}
    , decltype(_impl_.using_varint_bitcounts_){}
    , decltype(_impl_.uncompressed_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_data()) {
    _this->_impl_.string_data_.Set(from._internal_string_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.num_entries_, &from._impl_.num_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uncompressed_size_) -
    reinterpret_cast<char*>(&_impl_.num_entries_)) + sizeof(_impl_.uncompressed_size_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CreateStringTable)
}

inline void CSVCMsg_CreateStringTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.num_entries_){0}
    , decltype(_impl_.user_data_size_){0}
    , decltype(_impl_.user_data_size_bits_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.user_data_fixed_size_){false}
    , decltype(_impl_.data_compressed_){false}
    , decltype(_impl_.using_varint_bitcounts_){false}
    , decltype(_impl_.uncompressed_size_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_CreateStringTable::~CSVCMsg_CreateStringTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CreateStringTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CreateStringTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.string_data_.Destroy();
}

void CSVCMsg_CreateStringTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CreateStringTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CreateStringTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.string_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.num_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_compressed_) -
        reinterpret_cast<char*>(&_impl_.num_entries_)) + sizeof(_impl_.data_compressed_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.using_varint_bitcounts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uncompressed_size_) -
        reinterpret_cast<char*>(&_impl_.using_varint_bitcounts_)) + sizeof(_impl_.uncompressed_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CreateStringTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_CreateStringTable.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_entries(&has_bits);
          _impl_.num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_data_fixed_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_data_fixed_size(&has_bits);
          _impl_.user_data_fixed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_data_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_user_data_size(&has_bits);
          _impl_.user_data_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_data_size_bits = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_user_data_size_bits(&has_bits);
          _impl_.user_data_size_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes string_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_string_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uncompressed_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_uncompressed_size(&has_bits);
          _impl_.uncompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool data_compressed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_data_compressed(&has_bits);
          _impl_.data_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool using_varint_bitcounts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_using_varint_bitcounts(&has_bits);
          _impl_.using_varint_bitcounts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CreateStringTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CreateStringTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_CreateStringTable.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 num_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_entries(), target);
  }

  // optional bool user_data_fixed_size = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_user_data_fixed_size(), target);
  }

  // optional int32 user_data_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_user_data_size(), target);
  }

  // optional int32 user_data_size_bits = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_user_data_size_bits(), target);
  }

  // optional int32 flags = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_flags(), target);
  }

  // optional bytes string_data = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_string_data(), target);
  }

  // optional int32 uncompressed_size = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_uncompressed_size(), target);
  }

  // optional bool data_compressed = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_data_compressed(), target);
  }

  // optional bool using_varint_bitcounts = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_using_varint_bitcounts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CreateStringTable)
  return target;
}

size_t CSVCMsg_CreateStringTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CreateStringTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes string_data = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_string_data());
    }

    // optional int32 num_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

    // optional int32 user_data_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_data_size());
    }

    // optional int32 user_data_size_bits = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_data_size_bits());
    }

    // optional int32 flags = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional bool user_data_fixed_size = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool data_compressed = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool using_varint_bitcounts = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 uncompressed_size = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uncompressed_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CreateStringTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CreateStringTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CreateStringTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_CreateStringTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CreateStringTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CreateStringTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CreateStringTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_string_data(from._internal_string_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_entries_ = from._impl_.num_entries_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.user_data_size_ = from._impl_.user_data_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.user_data_size_bits_ = from._impl_.user_data_size_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.user_data_fixed_size_ = from._impl_.user_data_fixed_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.data_compressed_ = from._impl_.data_compressed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.using_varint_bitcounts_ = from._impl_.using_varint_bitcounts_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.uncompressed_size_ = from._impl_.uncompressed_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CreateStringTable::CopyFrom(const CSVCMsg_CreateStringTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CreateStringTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CreateStringTable::IsInitialized() const {
  return true;
}

void CSVCMsg_CreateStringTable::InternalSwap(CSVCMsg_CreateStringTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_data_, lhs_arena,
      &other->_impl_.string_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_CreateStringTable, _impl_.uncompressed_size_)
      + sizeof(CSVCMsg_CreateStringTable::_impl_.uncompressed_size_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_CreateStringTable, _impl_.num_entries_)>(
          reinterpret_cast<char*>(&_impl_.num_entries_),
          reinterpret_cast<char*>(&other->_impl_.num_entries_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CreateStringTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[47]);
}

// ===================================================================

class CSVCMsg_UpdateStringTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_UpdateStringTable>()._impl_._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_changed_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_string_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_UpdateStringTable)
}
CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(const CSVCMsg_UpdateStringTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_UpdateStringTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.table_id_){}
    , decltype(_impl_.num_changed_entries_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_data()) {
    _this->_impl_.string_data_.Set(from._internal_string_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.table_id_, &from._impl_.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_changed_entries_) -
    reinterpret_cast<char*>(&_impl_.table_id_)) + sizeof(_impl_.num_changed_entries_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_UpdateStringTable)
}

inline void CSVCMsg_UpdateStringTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.table_id_){0}
    , decltype(_impl_.num_changed_entries_){0}
  };
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_UpdateStringTable::~CSVCMsg_UpdateStringTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_UpdateStringTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_UpdateStringTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.string_data_.Destroy();
}

void CSVCMsg_UpdateStringTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_UpdateStringTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_UpdateStringTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.string_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_changed_entries_) -
        reinterpret_cast<char*>(&_impl_.table_id_)) + sizeof(_impl_.num_changed_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_UpdateStringTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          _impl_.table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_changed_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_changed_entries(&has_bits);
          _impl_.num_changed_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes string_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_string_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_UpdateStringTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_UpdateStringTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 table_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_table_id(), target);
  }

  // optional int32 num_changed_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_changed_entries(), target);
  }

  // optional bytes string_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_string_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_UpdateStringTable)
  return target;
}

size_t CSVCMsg_UpdateStringTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_UpdateStringTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes string_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_string_data());
    }

    // optional int32 table_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_table_id());
    }

    // optional int32 num_changed_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_changed_entries());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_UpdateStringTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_UpdateStringTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_UpdateStringTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_UpdateStringTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_UpdateStringTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_UpdateStringTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_UpdateStringTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_string_data(from._internal_string_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.table_id_ = from._impl_.table_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_changed_entries_ = from._impl_.num_changed_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_UpdateStringTable::CopyFrom(const CSVCMsg_UpdateStringTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_UpdateStringTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_UpdateStringTable::IsInitialized() const {
  return true;
}

void CSVCMsg_UpdateStringTable::InternalSwap(CSVCMsg_UpdateStringTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_data_, lhs_arena,
      &other->_impl_.string_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_UpdateStringTable, _impl_.num_changed_entries_)
      + sizeof(CSVCMsg_UpdateStringTable::_impl_.num_changed_entries_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_UpdateStringTable, _impl_.table_id_)>(
          reinterpret_cast<char*>(&_impl_.table_id_),
          reinterpret_cast<char*>(&other->_impl_.table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_UpdateStringTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[48]);
}

// ===================================================================

class CSVCMsg_VoiceData::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_VoiceData>()._impl_._has_bits_);
  static const ::CMsgVoiceAudio& audio(const CSVCMsg_VoiceData* msg);
  static void set_has_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_proximity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_xuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_audible_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_passthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CMsgVoiceAudio&
CSVCMsg_VoiceData::_Internal::audio(const CSVCMsg_VoiceData* msg) {
  return *msg->_impl_.audio_;
}
CSVCMsg_VoiceData::CSVCMsg_VoiceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_VoiceData)
}
CSVCMsg_VoiceData::CSVCMsg_VoiceData(const CSVCMsg_VoiceData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_VoiceData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){}
    , decltype(_impl_.proximity_){}
    , decltype(_impl_.audible_mask_){}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.passthrough_){}
    , decltype(_impl_.client_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::CMsgVoiceAudio(*from._impl_.audio_);
  }
  ::memcpy(&_impl_.xuid_, &from._impl_.xuid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_) -
    reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.client_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_VoiceData)
}

inline void CSVCMsg_VoiceData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){uint64_t{0u}}
    , decltype(_impl_.proximity_){false}
    , decltype(_impl_.audible_mask_){0}
    , decltype(_impl_.tick_){0u}
    , decltype(_impl_.passthrough_){0}
    , decltype(_impl_.client_){-1}
  };
}

CSVCMsg_VoiceData::~CSVCMsg_VoiceData() {
  // @@protoc_insertion_point(destructor:CSVCMsg_VoiceData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_VoiceData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audio_;
}

void CSVCMsg_VoiceData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_VoiceData::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.audio_ != nullptr);
    _impl_.audio_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.xuid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passthrough_) -
        reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.passthrough_));
    _impl_.client_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_VoiceData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVoiceAudio audio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client(&has_bits);
          _impl_.client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool proximity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_proximity(&has_bits);
          _impl_.proximity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 xuid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_xuid(&has_bits);
          _impl_.xuid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audible_mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_audible_mask(&has_bits);
          _impl_.audible_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tick = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passthrough = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_passthrough(&has_bits);
          _impl_.passthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_VoiceData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVoiceAudio audio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // optional int32 client = 2 [default = -1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_client(), target);
  }

  // optional bool proximity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_proximity(), target);
  }

  // optional fixed64 xuid = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_xuid(), target);
  }

  // optional int32 audible_mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_audible_mask(), target);
  }

  // optional uint32 tick = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_tick(), target);
  }

  // optional int32 passthrough = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_passthrough(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_VoiceData)
  return target;
}

size_t CSVCMsg_VoiceData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_VoiceData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .CMsgVoiceAudio audio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audio_);
    }

    // optional fixed64 xuid = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool proximity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 audible_mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audible_mask());
    }

    // optional uint32 tick = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tick());
    }

    // optional int32 passthrough = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passthrough());
    }

    // optional int32 client = 2 [default = -1];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_VoiceData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_VoiceData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_VoiceData::GetClassData() const { return &_class_data_; }


void CSVCMsg_VoiceData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_VoiceData*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_VoiceData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_VoiceData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_audio()->::CMsgVoiceAudio::MergeFrom(
          from._internal_audio());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.xuid_ = from._impl_.xuid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.proximity_ = from._impl_.proximity_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.audible_mask_ = from._impl_.audible_mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.passthrough_ = from._impl_.passthrough_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.client_ = from._impl_.client_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_VoiceData::CopyFrom(const CSVCMsg_VoiceData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_VoiceData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_VoiceData::IsInitialized() const {
  return true;
}

void CSVCMsg_VoiceData::InternalSwap(CSVCMsg_VoiceData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceData, _impl_.passthrough_)
      + sizeof(CSVCMsg_VoiceData::_impl_.passthrough_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceData, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
  swap(_impl_.client_, other->_impl_.client_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_VoiceData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[49]);
}

// ===================================================================

class CSVCMsg_PacketReliable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketReliable>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_messagessize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketReliable)
}
CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(const CSVCMsg_PacketReliable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketReliable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.messagessize_){}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.state_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketReliable)
}

inline void CSVCMsg_PacketReliable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.messagessize_){0}
    , decltype(_impl_.state_){false}
  };
}

CSVCMsg_PacketReliable::~CSVCMsg_PacketReliable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketReliable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketReliable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_PacketReliable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketReliable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketReliable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.state_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketReliable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 messagessize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_messagessize(&has_bits);
          _impl_.messagessize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketReliable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketReliable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional int32 messagessize = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_messagessize(), target);
  }

  // optional bool state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketReliable)
  return target;
}

size_t CSVCMsg_PacketReliable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketReliable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 messagessize = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_messagessize());
    }

    // optional bool state = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketReliable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketReliable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketReliable::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketReliable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketReliable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketReliable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketReliable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.messagessize_ = from._impl_.messagessize_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketReliable::CopyFrom(const CSVCMsg_PacketReliable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketReliable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketReliable::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketReliable::InternalSwap(CSVCMsg_PacketReliable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketReliable, _impl_.state_)
      + sizeof(CSVCMsg_PacketReliable::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketReliable, _impl_.tick_)>(
          reinterpret_cast<char*>(&_impl_.tick_),
          reinterpret_cast<char*>(&other->_impl_.tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketReliable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[50]);
}

// ===================================================================

class CSVCMsg_FullFrameSplit::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_FullFrameSplit>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_section(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FullFrameSplit)
}
CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(const CSVCMsg_FullFrameSplit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FullFrameSplit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.section_){}
    , decltype(_impl_.total_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.total_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FullFrameSplit)
}

inline void CSVCMsg_FullFrameSplit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.section_){0}
    , decltype(_impl_.total_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_FullFrameSplit::~CSVCMsg_FullFrameSplit() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FullFrameSplit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FullFrameSplit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_FullFrameSplit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FullFrameSplit::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FullFrameSplit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FullFrameSplit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_section(&has_bits);
          _impl_.section_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total(&has_bits);
          _impl_.total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FullFrameSplit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FullFrameSplit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional int32 section = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_section(), target);
  }

  // optional int32 total = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_total(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FullFrameSplit)
  return target;
}

size_t CSVCMsg_FullFrameSplit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FullFrameSplit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 section = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_section());
    }

    // optional int32 total = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FullFrameSplit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FullFrameSplit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FullFrameSplit::GetClassData() const { return &_class_data_; }


void CSVCMsg_FullFrameSplit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FullFrameSplit*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FullFrameSplit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FullFrameSplit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.section_ = from._impl_.section_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.total_ = from._impl_.total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FullFrameSplit::CopyFrom(const CSVCMsg_FullFrameSplit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FullFrameSplit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FullFrameSplit::IsInitialized() const {
  return true;
}

void CSVCMsg_FullFrameSplit::InternalSwap(CSVCMsg_FullFrameSplit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_FullFrameSplit, _impl_.total_)
      + sizeof(CSVCMsg_FullFrameSplit::_impl_.total_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_FullFrameSplit, _impl_.tick_)>(
          reinterpret_cast<char*>(&_impl_.tick_),
          reinterpret_cast<char*>(&other->_impl_.tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FullFrameSplit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[51]);
}

// ===================================================================

class CSVCMsg_HLTVStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HLTVStatus>()._impl_._has_bits_);
  static void set_has_master(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slots(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_proxies(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HLTVStatus)
}
CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(const CSVCMsg_HLTVStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HLTVStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_){}
    , decltype(_impl_.clients_){}
    , decltype(_impl_.slots_){}
    , decltype(_impl_.proxies_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.master_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.master_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_master()) {
    _this->_impl_.master_.Set(from._internal_master(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.clients_, &from._impl_.clients_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxies_) -
    reinterpret_cast<char*>(&_impl_.clients_)) + sizeof(_impl_.proxies_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HLTVStatus)
}

inline void CSVCMsg_HLTVStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_){}
    , decltype(_impl_.clients_){0}
    , decltype(_impl_.slots_){0}
    , decltype(_impl_.proxies_){0}
  };
  _impl_.master_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.master_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_HLTVStatus::~CSVCMsg_HLTVStatus() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HLTVStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HLTVStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_.Destroy();
}

void CSVCMsg_HLTVStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HLTVStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HLTVStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.master_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.clients_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.proxies_) -
        reinterpret_cast<char*>(&_impl_.clients_)) + sizeof(_impl_.proxies_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HLTVStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string master = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_master();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_HLTVStatus.master");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 clients = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clients(&has_bits);
          _impl_.clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slots = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_slots(&has_bits);
          _impl_.slots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 proxies = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_proxies(&has_bits);
          _impl_.proxies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HLTVStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HLTVStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string master = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_master().data(), static_cast<int>(this->_internal_master().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_HLTVStatus.master");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_master(), target);
  }

  // optional int32 clients = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_clients(), target);
  }

  // optional int32 slots = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_slots(), target);
  }

  // optional int32 proxies = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_proxies(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HLTVStatus)
  return target;
}

size_t CSVCMsg_HLTVStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HLTVStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string master = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_master());
    }

    // optional int32 clients = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_clients());
    }

    // optional int32 slots = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slots());
    }

    // optional int32 proxies = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_proxies());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HLTVStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HLTVStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HLTVStatus::GetClassData() const { return &_class_data_; }


void CSVCMsg_HLTVStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HLTVStatus*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HLTVStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HLTVStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_master(from._internal_master());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.clients_ = from._impl_.clients_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.slots_ = from._impl_.slots_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.proxies_ = from._impl_.proxies_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HLTVStatus::CopyFrom(const CSVCMsg_HLTVStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HLTVStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HLTVStatus::IsInitialized() const {
  return true;
}

void CSVCMsg_HLTVStatus::InternalSwap(CSVCMsg_HLTVStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.master_, lhs_arena,
      &other->_impl_.master_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_HLTVStatus, _impl_.proxies_)
      + sizeof(CSVCMsg_HLTVStatus::_impl_.proxies_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_HLTVStatus, _impl_.clients_)>(
          reinterpret_cast<char*>(&_impl_.clients_),
          reinterpret_cast<char*>(&other->_impl_.clients_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HLTVStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[52]);
}

// ===================================================================

class CSVCMsg_ServerSteamID::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ServerSteamID>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ServerSteamID)
}
CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(const CSVCMsg_ServerSteamID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ServerSteamID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.steam_id_ = from._impl_.steam_id_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ServerSteamID)
}

inline void CSVCMsg_ServerSteamID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
  };
}

CSVCMsg_ServerSteamID::~CSVCMsg_ServerSteamID() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ServerSteamID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ServerSteamID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_ServerSteamID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ServerSteamID::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ServerSteamID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ServerSteamID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ServerSteamID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ServerSteamID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ServerSteamID)
  return target;
}

size_t CSVCMsg_ServerSteamID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ServerSteamID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 steam_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steam_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ServerSteamID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ServerSteamID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ServerSteamID::GetClassData() const { return &_class_data_; }


void CSVCMsg_ServerSteamID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ServerSteamID*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ServerSteamID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ServerSteamID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steam_id()) {
    _this->_internal_set_steam_id(from._internal_steam_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ServerSteamID::CopyFrom(const CSVCMsg_ServerSteamID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ServerSteamID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ServerSteamID::IsInitialized() const {
  return true;
}

void CSVCMsg_ServerSteamID::InternalSwap(CSVCMsg_ServerSteamID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steam_id_, other->_impl_.steam_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ServerSteamID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[53]);
}

// ===================================================================

class CSVCMsg_CmdKeyValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CmdKeyValues>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CmdKeyValues)
}
CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(const CSVCMsg_CmdKeyValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CmdKeyValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CmdKeyValues)
}

inline void CSVCMsg_CmdKeyValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_CmdKeyValues::~CSVCMsg_CmdKeyValues() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CmdKeyValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CmdKeyValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_CmdKeyValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CmdKeyValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CmdKeyValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CmdKeyValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CmdKeyValues)
  return target;
}

size_t CSVCMsg_CmdKeyValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CmdKeyValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CmdKeyValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CmdKeyValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CmdKeyValues::GetClassData() const { return &_class_data_; }


void CSVCMsg_CmdKeyValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CmdKeyValues*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CmdKeyValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CmdKeyValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CmdKeyValues::CopyFrom(const CSVCMsg_CmdKeyValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CmdKeyValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CmdKeyValues::IsInitialized() const {
  return true;
}

void CSVCMsg_CmdKeyValues::InternalSwap(CSVCMsg_CmdKeyValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CmdKeyValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[54]);
}

// ===================================================================

class CSVCMsg_RconServerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_RconServerDetails>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_details(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_RconServerDetails)
}
CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(const CSVCMsg_RconServerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_RconServerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.details_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.details_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_details()) {
    _this->_impl_.details_.Set(from._internal_details(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_RconServerDetails)
}

inline void CSVCMsg_RconServerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.details_){}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.details_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_RconServerDetails::~CSVCMsg_RconServerDetails() {
  // @@protoc_insertion_point(destructor:CSVCMsg_RconServerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_RconServerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  _impl_.details_.Destroy();
}

void CSVCMsg_RconServerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_RconServerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.details_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_RconServerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_details();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_RconServerDetails.details");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_RconServerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional string details = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_details().data(), static_cast<int>(this->_internal_details().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_RconServerDetails.details");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_details(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_RconServerDetails)
  return target;
}

size_t CSVCMsg_RconServerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_RconServerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional string details = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_details());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_RconServerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_RconServerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_RconServerDetails::GetClassData() const { return &_class_data_; }


void CSVCMsg_RconServerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_RconServerDetails*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_RconServerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_RconServerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_details(from._internal_details());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_RconServerDetails::CopyFrom(const CSVCMsg_RconServerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_RconServerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_RconServerDetails::IsInitialized() const {
  return true;
}

void CSVCMsg_RconServerDetails::InternalSwap(CSVCMsg_RconServerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.details_, lhs_arena,
      &other->_impl_.details_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_RconServerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[55]);
}

// ===================================================================

class CMsgIPCAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgIPCAddress>()._impl_._has_bits_);
  static void set_has_computer_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_process_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgIPCAddress::CMsgIPCAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgIPCAddress)
}
CMsgIPCAddress::CMsgIPCAddress(const CMsgIPCAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgIPCAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_guid_){}
    , decltype(_impl_.process_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.computer_guid_, &from._impl_.computer_guid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.process_id_) -
    reinterpret_cast<char*>(&_impl_.computer_guid_)) + sizeof(_impl_.process_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgIPCAddress)
}

inline void CMsgIPCAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_guid_){uint64_t{0u}}
    , decltype(_impl_.process_id_){0u}
  };
}

CMsgIPCAddress::~CMsgIPCAddress() {
  // @@protoc_insertion_point(destructor:CMsgIPCAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgIPCAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgIPCAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgIPCAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgIPCAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.computer_guid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.process_id_) -
        reinterpret_cast<char*>(&_impl_.computer_guid_)) + sizeof(_impl_.process_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgIPCAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 computer_guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_computer_guid(&has_bits);
          _impl_.computer_guid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 process_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_process_id(&has_bits);
          _impl_.process_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgIPCAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgIPCAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 computer_guid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_computer_guid(), target);
  }

  // optional uint32 process_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_process_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgIPCAddress)
  return target;
}

size_t CMsgIPCAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgIPCAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 computer_guid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 process_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgIPCAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgIPCAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgIPCAddress::GetClassData() const { return &_class_data_; }


void CMsgIPCAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgIPCAddress*>(&to_msg);
  auto& from = static_cast<const CMsgIPCAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgIPCAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.computer_guid_ = from._impl_.computer_guid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.process_id_ = from._impl_.process_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgIPCAddress::CopyFrom(const CMsgIPCAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgIPCAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgIPCAddress::IsInitialized() const {
  return true;
}

void CMsgIPCAddress::InternalSwap(CMsgIPCAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgIPCAddress, _impl_.process_id_)
      + sizeof(CMsgIPCAddress::_impl_.process_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgIPCAddress, _impl_.computer_guid_)>(
          reinterpret_cast<char*>(&_impl_.computer_guid_),
          reinterpret_cast<char*>(&other->_impl_.computer_guid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgIPCAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[56]);
}

// ===================================================================

class CMsgServerPeer::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerPeer>()._impl_._has_bits_);
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgIPCAddress& ipc(const CMsgServerPeer* msg);
  static void set_has_ipc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_they_hear_you(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_you_hear_them(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_listenserver_host(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgIPCAddress&
CMsgServerPeer::_Internal::ipc(const CMsgServerPeer* msg) {
  return *msg->_impl_.ipc_;
}
CMsgServerPeer::CMsgServerPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerPeer)
}
CMsgServerPeer::CMsgServerPeer(const CMsgServerPeer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerPeer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipc_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.they_hear_you_){}
    , decltype(_impl_.you_hear_them_){}
    , decltype(_impl_.is_listenserver_host_){}
    , decltype(_impl_.player_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ipc()) {
    _this->_impl_.ipc_ = new ::CMsgIPCAddress(*from._impl_.ipc_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_slot_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.player_slot_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerPeer)
}

inline void CMsgServerPeer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipc_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.they_hear_you_){false}
    , decltype(_impl_.you_hear_them_){false}
    , decltype(_impl_.is_listenserver_host_){false}
    , decltype(_impl_.player_slot_){-1}
  };
}

CMsgServerPeer::~CMsgServerPeer() {
  // @@protoc_insertion_point(destructor:CMsgServerPeer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerPeer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ipc_;
}

void CMsgServerPeer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerPeer::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerPeer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.ipc_ != nullptr);
    _impl_.ipc_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_listenserver_host_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.is_listenserver_host_));
    _impl_.player_slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerPeer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_slot = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgIPCAddress ipc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool they_hear_you = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_they_hear_you(&has_bits);
          _impl_.they_hear_you_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool you_hear_them = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_you_hear_them(&has_bits);
          _impl_.you_hear_them_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_listenserver_host = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_listenserver_host(&has_bits);
          _impl_.is_listenserver_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerPeer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerPeer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_slot = 1 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_slot(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional .CMsgIPCAddress ipc = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ipc(this),
        _Internal::ipc(this).GetCachedSize(), target, stream);
  }

  // optional bool they_hear_you = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_they_hear_you(), target);
  }

  // optional bool you_hear_them = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_you_hear_them(), target);
  }

  // optional bool is_listenserver_host = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_listenserver_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerPeer)
  return target;
}

size_t CMsgServerPeer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerPeer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CMsgIPCAddress ipc = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ipc_);
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool they_hear_you = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool you_hear_them = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_listenserver_host = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 player_slot = 1 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerPeer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerPeer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerPeer::GetClassData() const { return &_class_data_; }


void CMsgServerPeer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerPeer*>(&to_msg);
  auto& from = static_cast<const CMsgServerPeer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerPeer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ipc()->::CMsgIPCAddress::MergeFrom(
          from._internal_ipc());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.they_hear_you_ = from._impl_.they_hear_you_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.you_hear_them_ = from._impl_.you_hear_them_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_listenserver_host_ = from._impl_.is_listenserver_host_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerPeer::CopyFrom(const CMsgServerPeer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerPeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerPeer::IsInitialized() const {
  return true;
}

void CMsgServerPeer::InternalSwap(CMsgServerPeer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerPeer, _impl_.is_listenserver_host_)
      + sizeof(CMsgServerPeer::_impl_.is_listenserver_host_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerPeer, _impl_.ipc_)>(
          reinterpret_cast<char*>(&_impl_.ipc_),
          reinterpret_cast<char*>(&other->_impl_.ipc_));
  swap(_impl_.player_slot_, other->_impl_.player_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerPeer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[57]);
}

// ===================================================================

class CSVCMsg_PeerList::_Internal {
 public:
};

CSVCMsg_PeerList::CSVCMsg_PeerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PeerList)
}
CSVCMsg_PeerList::CSVCMsg_PeerList(const CSVCMsg_PeerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PeerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peer_){from._impl_.peer_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PeerList)
}

inline void CSVCMsg_PeerList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.peer_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_PeerList::~CSVCMsg_PeerList() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PeerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PeerList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peer_.~RepeatedPtrField();
}

void CSVCMsg_PeerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PeerList::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PeerList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peer_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PeerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgServerPeer peer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PeerList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PeerList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgServerPeer peer = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peer_size()); i < n; i++) {
    const auto& repfield = this->_internal_peer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PeerList)
  return target;
}

size_t CSVCMsg_PeerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PeerList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgServerPeer peer = 1;
  total_size += 1UL * this->_internal_peer_size();
  for (const auto& msg : this->_impl_.peer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PeerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PeerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PeerList::GetClassData() const { return &_class_data_; }


void CSVCMsg_PeerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PeerList*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PeerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PeerList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peer_.MergeFrom(from._impl_.peer_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PeerList::CopyFrom(const CSVCMsg_PeerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PeerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PeerList::IsInitialized() const {
  return true;
}

void CSVCMsg_PeerList::InternalSwap(CSVCMsg_PeerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.peer_.InternalSwap(&other->_impl_.peer_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PeerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[58]);
}

// ===================================================================

class CSVCMsg_ClearAllStringTables::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClearAllStringTables>()._impl_._has_bits_);
  static void set_has_mapname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_create_tables_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClearAllStringTables)
}
CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(const CSVCMsg_ClearAllStringTables& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClearAllStringTables* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapname_){}
    , decltype(_impl_.create_tables_skipped_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mapname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mapname()) {
    _this->_impl_.mapname_.Set(from._internal_mapname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.create_tables_skipped_ = from._impl_.create_tables_skipped_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClearAllStringTables)
}

inline void CSVCMsg_ClearAllStringTables::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapname_){}
    , decltype(_impl_.create_tables_skipped_){false}
  };
  _impl_.mapname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ClearAllStringTables::~CSVCMsg_ClearAllStringTables() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClearAllStringTables)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClearAllStringTables::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mapname_.Destroy();
}

void CSVCMsg_ClearAllStringTables::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClearAllStringTables::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClearAllStringTables)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.mapname_.ClearNonDefaultToEmpty();
  }
  _impl_.create_tables_skipped_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClearAllStringTables::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string mapname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mapname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ClearAllStringTables.mapname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool create_tables_skipped = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_create_tables_skipped(&has_bits);
          _impl_.create_tables_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClearAllStringTables::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClearAllStringTables)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string mapname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mapname().data(), static_cast<int>(this->_internal_mapname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ClearAllStringTables.mapname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mapname(), target);
  }

  // optional bool create_tables_skipped = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_create_tables_skipped(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClearAllStringTables)
  return target;
}

size_t CSVCMsg_ClearAllStringTables::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClearAllStringTables)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string mapname = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mapname());
    }

    // optional bool create_tables_skipped = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClearAllStringTables::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClearAllStringTables::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClearAllStringTables::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClearAllStringTables::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClearAllStringTables*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClearAllStringTables&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClearAllStringTables)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_mapname(from._internal_mapname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.create_tables_skipped_ = from._impl_.create_tables_skipped_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClearAllStringTables::CopyFrom(const CSVCMsg_ClearAllStringTables& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClearAllStringTables)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClearAllStringTables::IsInitialized() const {
  return true;
}

void CSVCMsg_ClearAllStringTables::InternalSwap(CSVCMsg_ClearAllStringTables* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mapname_, lhs_arena,
      &other->_impl_.mapname_, rhs_arena
  );
  swap(_impl_.create_tables_skipped_, other->_impl_.create_tables_skipped_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClearAllStringTables::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[59]);
}

// ===================================================================

class ProtoFlattenedSerializerField_t_polymorphic_field_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializerField_t_polymorphic_field_t>()._impl_._has_bits_);
  static void set_has_polymorphic_field_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_polymorphic_field_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
}
ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(const ProtoFlattenedSerializerField_t_polymorphic_field_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializerField_t_polymorphic_field_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_field_serializer_name_sym_){}
    , decltype(_impl_.polymorphic_field_serializer_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.polymorphic_field_serializer_name_sym_, &from._impl_.polymorphic_field_serializer_name_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_version_) -
    reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_)) + sizeof(_impl_.polymorphic_field_serializer_version_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
}

inline void ProtoFlattenedSerializerField_t_polymorphic_field_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_field_serializer_name_sym_){0}
    , decltype(_impl_.polymorphic_field_serializer_version_){0}
  };
}

ProtoFlattenedSerializerField_t_polymorphic_field_t::~ProtoFlattenedSerializerField_t_polymorphic_field_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializerField_t_polymorphic_field_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.polymorphic_field_serializer_name_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_version_) -
        reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_)) + sizeof(_impl_.polymorphic_field_serializer_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializerField_t_polymorphic_field_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 polymorphic_field_serializer_name_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_polymorphic_field_serializer_name_sym(&has_bits);
          _impl_.polymorphic_field_serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 polymorphic_field_serializer_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_polymorphic_field_serializer_version(&has_bits);
          _impl_.polymorphic_field_serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializerField_t_polymorphic_field_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 polymorphic_field_serializer_name_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_polymorphic_field_serializer_name_sym(), target);
  }

  // optional int32 polymorphic_field_serializer_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_polymorphic_field_serializer_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  return target;
}

size_t ProtoFlattenedSerializerField_t_polymorphic_field_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 polymorphic_field_serializer_name_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_polymorphic_field_serializer_name_sym());
    }

    // optional int32 polymorphic_field_serializer_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_polymorphic_field_serializer_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializerField_t_polymorphic_field_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializerField_t_polymorphic_field_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializerField_t_polymorphic_field_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializerField_t_polymorphic_field_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializerField_t_polymorphic_field_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializerField_t_polymorphic_field_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.polymorphic_field_serializer_name_sym_ = from._impl_.polymorphic_field_serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.polymorphic_field_serializer_version_ = from._impl_.polymorphic_field_serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::CopyFrom(const ProtoFlattenedSerializerField_t_polymorphic_field_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializerField_t_polymorphic_field_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::InternalSwap(ProtoFlattenedSerializerField_t_polymorphic_field_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_version_)
      + sizeof(ProtoFlattenedSerializerField_t_polymorphic_field_t::_impl_.polymorphic_field_serializer_version_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_name_sym_)>(
          reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_),
          reinterpret_cast<char*>(&other->_impl_.polymorphic_field_serializer_name_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializerField_t_polymorphic_field_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[60]);
}

// ===================================================================

class ProtoFlattenedSerializerField_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializerField_t>()._impl_._has_bits_);
  static void set_has_var_type_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_var_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bit_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_high_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_encode_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_field_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_field_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_send_node_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_var_encoder_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_var_serializer_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializerField_t)
}
ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(const ProtoFlattenedSerializerField_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializerField_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_types_){from._impl_.polymorphic_types_}
    , decltype(_impl_.var_type_sym_){}
    , decltype(_impl_.var_name_sym_){}
    , decltype(_impl_.bit_count_){}
    , decltype(_impl_.low_value_){}
    , decltype(_impl_.high_value_){}
    , decltype(_impl_.encode_flags_){}
    , decltype(_impl_.field_serializer_name_sym_){}
    , decltype(_impl_.field_serializer_version_){}
    , decltype(_impl_.send_node_sym_){}
    , decltype(_impl_.var_encoder_sym_){}
    , decltype(_impl_.var_serializer_sym_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.var_type_sym_, &from._impl_.var_type_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.var_serializer_sym_) -
    reinterpret_cast<char*>(&_impl_.var_type_sym_)) + sizeof(_impl_.var_serializer_sym_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializerField_t)
}

inline void ProtoFlattenedSerializerField_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_types_){arena}
    , decltype(_impl_.var_type_sym_){0}
    , decltype(_impl_.var_name_sym_){0}
    , decltype(_impl_.bit_count_){0}
    , decltype(_impl_.low_value_){0}
    , decltype(_impl_.high_value_){0}
    , decltype(_impl_.encode_flags_){0}
    , decltype(_impl_.field_serializer_name_sym_){0}
    , decltype(_impl_.field_serializer_version_){0}
    , decltype(_impl_.send_node_sym_){0}
    , decltype(_impl_.var_encoder_sym_){0}
    , decltype(_impl_.var_serializer_sym_){0}
  };
}

ProtoFlattenedSerializerField_t::~ProtoFlattenedSerializerField_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializerField_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializerField_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.polymorphic_types_.~RepeatedPtrField();
}

void ProtoFlattenedSerializerField_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializerField_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializerField_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.polymorphic_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.var_type_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.field_serializer_version_) -
        reinterpret_cast<char*>(&_impl_.var_type_sym_)) + sizeof(_impl_.field_serializer_version_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.send_node_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.var_serializer_sym_) -
        reinterpret_cast<char*>(&_impl_.send_node_sym_)) + sizeof(_impl_.var_serializer_sym_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializerField_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 var_type_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_var_type_sym(&has_bits);
          _impl_.var_type_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_name_sym = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_var_name_sym(&has_bits);
          _impl_.var_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bit_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bit_count(&has_bits);
          _impl_.bit_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float low_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_low_value(&has_bits);
          _impl_.low_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float high_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_high_value(&has_bits);
          _impl_.high_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 encode_flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_encode_flags(&has_bits);
          _impl_.encode_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 field_serializer_name_sym = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_field_serializer_name_sym(&has_bits);
          _impl_.field_serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 field_serializer_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_field_serializer_version(&has_bits);
          _impl_.field_serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 send_node_sym = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_send_node_sym(&has_bits);
          _impl_.send_node_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_encoder_sym = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_var_encoder_sym(&has_bits);
          _impl_.var_encoder_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_polymorphic_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_serializer_sym = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_var_serializer_sym(&has_bits);
          _impl_.var_serializer_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializerField_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializerField_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 var_type_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_var_type_sym(), target);
  }

  // optional int32 var_name_sym = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_var_name_sym(), target);
  }

  // optional int32 bit_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_bit_count(), target);
  }

  // optional float low_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_low_value(), target);
  }

  // optional float high_value = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_high_value(), target);
  }

  // optional int32 encode_flags = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_encode_flags(), target);
  }

  // optional int32 field_serializer_name_sym = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_field_serializer_name_sym(), target);
  }

  // optional int32 field_serializer_version = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_field_serializer_version(), target);
  }

  // optional int32 send_node_sym = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_send_node_sym(), target);
  }

  // optional int32 var_encoder_sym = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_var_encoder_sym(), target);
  }

  // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_polymorphic_types_size()); i < n; i++) {
    const auto& repfield = this->_internal_polymorphic_types(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 var_serializer_sym = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_var_serializer_sym(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializerField_t)
  return target;
}

size_t ProtoFlattenedSerializerField_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializerField_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
  total_size += 1UL * this->_internal_polymorphic_types_size();
  for (const auto& msg : this->_impl_.polymorphic_types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 var_type_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_type_sym());
    }

    // optional int32 var_name_sym = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_name_sym());
    }

    // optional int32 bit_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bit_count());
    }

    // optional float low_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float high_value = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 encode_flags = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_encode_flags());
    }

    // optional int32 field_serializer_name_sym = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_field_serializer_name_sym());
    }

    // optional int32 field_serializer_version = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_field_serializer_version());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 send_node_sym = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_send_node_sym());
    }

    // optional int32 var_encoder_sym = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_encoder_sym());
    }

    // optional int32 var_serializer_sym = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_serializer_sym());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializerField_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializerField_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializerField_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializerField_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializerField_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializerField_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializerField_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.polymorphic_types_.MergeFrom(from._impl_.polymorphic_types_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.var_type_sym_ = from._impl_.var_type_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.var_name_sym_ = from._impl_.var_name_sym_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bit_count_ = from._impl_.bit_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.low_value_ = from._impl_.low_value_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.high_value_ = from._impl_.high_value_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.encode_flags_ = from._impl_.encode_flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.field_serializer_name_sym_ = from._impl_.field_serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.field_serializer_version_ = from._impl_.field_serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.send_node_sym_ = from._impl_.send_node_sym_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.var_encoder_sym_ = from._impl_.var_encoder_sym_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.var_serializer_sym_ = from._impl_.var_serializer_sym_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializerField_t::CopyFrom(const ProtoFlattenedSerializerField_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializerField_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializerField_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializerField_t::InternalSwap(ProtoFlattenedSerializerField_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.polymorphic_types_.InternalSwap(&other->_impl_.polymorphic_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t, _impl_.var_serializer_sym_)
      + sizeof(ProtoFlattenedSerializerField_t::_impl_.var_serializer_sym_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t, _impl_.var_type_sym_)>(
          reinterpret_cast<char*>(&_impl_.var_type_sym_),
          reinterpret_cast<char*>(&other->_impl_.var_type_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializerField_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[61]);
}

// ===================================================================

class ProtoFlattenedSerializer_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializer_t>()._impl_._has_bits_);
  static void set_has_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializer_t)
}
ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(const ProtoFlattenedSerializer_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializer_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_index_){from._impl_.fields_index_}
    , decltype(_impl_.serializer_name_sym_){}
    , decltype(_impl_.serializer_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.serializer_name_sym_, &from._impl_.serializer_name_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.serializer_version_) -
    reinterpret_cast<char*>(&_impl_.serializer_name_sym_)) + sizeof(_impl_.serializer_version_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializer_t)
}

inline void ProtoFlattenedSerializer_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_index_){arena}
    , decltype(_impl_.serializer_name_sym_){0}
    , decltype(_impl_.serializer_version_){0}
  };
}

ProtoFlattenedSerializer_t::~ProtoFlattenedSerializer_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializer_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializer_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_index_.~RepeatedField();
}

void ProtoFlattenedSerializer_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializer_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializer_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_index_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.serializer_name_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.serializer_version_) -
        reinterpret_cast<char*>(&_impl_.serializer_name_sym_)) + sizeof(_impl_.serializer_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializer_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 serializer_name_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_serializer_name_sym(&has_bits);
          _impl_.serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 serializer_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_serializer_version(&has_bits);
          _impl_.serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 fields_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fields_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_fields_index(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializer_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializer_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 serializer_name_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_serializer_name_sym(), target);
  }

  // optional int32 serializer_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_serializer_version(), target);
  }

  // repeated int32 fields_index = 3;
  for (int i = 0, n = this->_internal_fields_index_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_fields_index(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializer_t)
  return target;
}

size_t ProtoFlattenedSerializer_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializer_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 fields_index = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.fields_index_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_fields_index_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 serializer_name_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serializer_name_sym());
    }

    // optional int32 serializer_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serializer_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializer_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializer_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializer_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializer_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializer_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializer_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializer_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_index_.MergeFrom(from._impl_.fields_index_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.serializer_name_sym_ = from._impl_.serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.serializer_version_ = from._impl_.serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializer_t::CopyFrom(const ProtoFlattenedSerializer_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializer_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializer_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializer_t::InternalSwap(ProtoFlattenedSerializer_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.fields_index_.InternalSwap(&other->_impl_.fields_index_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializer_t, _impl_.serializer_version_)
      + sizeof(ProtoFlattenedSerializer_t::_impl_.serializer_version_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializer_t, _impl_.serializer_name_sym_)>(
          reinterpret_cast<char*>(&_impl_.serializer_name_sym_),
          reinterpret_cast<char*>(&other->_impl_.serializer_name_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializer_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[62]);
}

// ===================================================================

class CSVCMsg_FlattenedSerializer::_Internal {
 public:
};

CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FlattenedSerializer)
}
CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(const CSVCMsg_FlattenedSerializer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FlattenedSerializer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serializers_){from._impl_.serializers_}
    , decltype(_impl_.symbols_){from._impl_.symbols_}
    , decltype(_impl_.fields_){from._impl_.fields_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FlattenedSerializer)
}

inline void CSVCMsg_FlattenedSerializer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.serializers_){arena}
    , decltype(_impl_.symbols_){arena}
    , decltype(_impl_.fields_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_FlattenedSerializer::~CSVCMsg_FlattenedSerializer() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FlattenedSerializer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FlattenedSerializer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serializers_.~RepeatedPtrField();
  _impl_.symbols_.~RepeatedPtrField();
  _impl_.fields_.~RepeatedPtrField();
}

void CSVCMsg_FlattenedSerializer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FlattenedSerializer::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FlattenedSerializer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serializers_.Clear();
  _impl_.symbols_.Clear();
  _impl_.fields_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FlattenedSerializer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ProtoFlattenedSerializer_t serializers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_serializers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string symbols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_symbols();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CSVCMsg_FlattenedSerializer.symbols");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ProtoFlattenedSerializerField_t fields = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FlattenedSerializer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FlattenedSerializer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializer_t serializers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_serializers_size()); i < n; i++) {
    const auto& repfield = this->_internal_serializers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string symbols = 2;
  for (int i = 0, n = this->_internal_symbols_size(); i < n; i++) {
    const auto& s = this->_internal_symbols(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_FlattenedSerializer.symbols");
    target = stream->WriteString(2, s, target);
  }

  // repeated .ProtoFlattenedSerializerField_t fields = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FlattenedSerializer)
  return target;
}

size_t CSVCMsg_FlattenedSerializer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FlattenedSerializer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializer_t serializers = 1;
  total_size += 1UL * this->_internal_serializers_size();
  for (const auto& msg : this->_impl_.serializers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string symbols = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.symbols_.size());
  for (int i = 0, n = _impl_.symbols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.symbols_.Get(i));
  }

  // repeated .ProtoFlattenedSerializerField_t fields = 3;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FlattenedSerializer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FlattenedSerializer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FlattenedSerializer::GetClassData() const { return &_class_data_; }


void CSVCMsg_FlattenedSerializer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FlattenedSerializer*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FlattenedSerializer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FlattenedSerializer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.serializers_.MergeFrom(from._impl_.serializers_);
  _this->_impl_.symbols_.MergeFrom(from._impl_.symbols_);
  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FlattenedSerializer::CopyFrom(const CSVCMsg_FlattenedSerializer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FlattenedSerializer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FlattenedSerializer::IsInitialized() const {
  return true;
}

void CSVCMsg_FlattenedSerializer::InternalSwap(CSVCMsg_FlattenedSerializer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.serializers_.InternalSwap(&other->_impl_.serializers_);
  _impl_.symbols_.InternalSwap(&other->_impl_.symbols_);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FlattenedSerializer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[63]);
}

// ===================================================================

class CSVCMsg_StopSound::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_StopSound>()._impl_._has_bits_);
  static void set_has_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_StopSound::CSVCMsg_StopSound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_StopSound)
}
CSVCMsg_StopSound::CSVCMsg_StopSound(const CSVCMsg_StopSound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_StopSound* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.guid_ = from._impl_.guid_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_StopSound)
}

inline void CSVCMsg_StopSound::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guid_){0u}
  };
}

CSVCMsg_StopSound::~CSVCMsg_StopSound() {
  // @@protoc_insertion_point(destructor:CSVCMsg_StopSound)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_StopSound::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_StopSound::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_StopSound::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_StopSound)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.guid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_StopSound::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_guid(&has_bits);
          _impl_.guid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_StopSound::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_StopSound)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 guid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_StopSound)
  return target;
}

size_t CSVCMsg_StopSound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_StopSound)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed32 guid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_StopSound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_StopSound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_StopSound::GetClassData() const { return &_class_data_; }


void CSVCMsg_StopSound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_StopSound*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_StopSound&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_StopSound)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_guid()) {
    _this->_internal_set_guid(from._internal_guid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_StopSound::CopyFrom(const CSVCMsg_StopSound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_StopSound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_StopSound::IsInitialized() const {
  return true;
}

void CSVCMsg_StopSound::InternalSwap(CSVCMsg_StopSound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.guid_, other->_impl_.guid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_StopSound::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[64]);
}

// ===================================================================

class CBidirMsg_RebroadcastGameEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CBidirMsg_RebroadcastGameEvent>()._impl_._has_bits_);
  static void set_has_posttoserver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buftype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clientbitcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivingclients(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBidirMsg_RebroadcastGameEvent)
}
CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(const CBidirMsg_RebroadcastGameEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBidirMsg_RebroadcastGameEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posttoserver_){}
    , decltype(_impl_.buftype_){}
    , decltype(_impl_.receivingclients_){}
    , decltype(_impl_.clientbitcount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.posttoserver_, &from._impl_.posttoserver_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clientbitcount_) -
    reinterpret_cast<char*>(&_impl_.posttoserver_)) + sizeof(_impl_.clientbitcount_));
  // @@protoc_insertion_point(copy_constructor:CBidirMsg_RebroadcastGameEvent)
}

inline void CBidirMsg_RebroadcastGameEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posttoserver_){false}
    , decltype(_impl_.buftype_){0}
    , decltype(_impl_.receivingclients_){uint64_t{0u}}
    , decltype(_impl_.clientbitcount_){0u}
  };
}

CBidirMsg_RebroadcastGameEvent::~CBidirMsg_RebroadcastGameEvent() {
  // @@protoc_insertion_point(destructor:CBidirMsg_RebroadcastGameEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBidirMsg_RebroadcastGameEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CBidirMsg_RebroadcastGameEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBidirMsg_RebroadcastGameEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CBidirMsg_RebroadcastGameEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.posttoserver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clientbitcount_) -
        reinterpret_cast<char*>(&_impl_.posttoserver_)) + sizeof(_impl_.clientbitcount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBidirMsg_RebroadcastGameEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool posttoserver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_posttoserver(&has_bits);
          _impl_.posttoserver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 buftype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buftype(&has_bits);
          _impl_.buftype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clientbitcount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_clientbitcount(&has_bits);
          _impl_.clientbitcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 receivingclients = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_receivingclients(&has_bits);
          _impl_.receivingclients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBidirMsg_RebroadcastGameEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBidirMsg_RebroadcastGameEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool posttoserver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_posttoserver(), target);
  }

  // optional int32 buftype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_buftype(), target);
  }

  // optional uint32 clientbitcount = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_clientbitcount(), target);
  }

  // optional uint64 receivingclients = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_receivingclients(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBidirMsg_RebroadcastGameEvent)
  return target;
}

size_t CBidirMsg_RebroadcastGameEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBidirMsg_RebroadcastGameEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool posttoserver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 buftype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buftype());
    }

    // optional uint64 receivingclients = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_receivingclients());
    }

    // optional uint32 clientbitcount = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clientbitcount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBidirMsg_RebroadcastGameEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBidirMsg_RebroadcastGameEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBidirMsg_RebroadcastGameEvent::GetClassData() const { return &_class_data_; }


void CBidirMsg_RebroadcastGameEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBidirMsg_RebroadcastGameEvent*>(&to_msg);
  auto& from = static_cast<const CBidirMsg_RebroadcastGameEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBidirMsg_RebroadcastGameEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.posttoserver_ = from._impl_.posttoserver_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buftype_ = from._impl_.buftype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.receivingclients_ = from._impl_.receivingclients_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clientbitcount_ = from._impl_.clientbitcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBidirMsg_RebroadcastGameEvent::CopyFrom(const CBidirMsg_RebroadcastGameEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBidirMsg_RebroadcastGameEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBidirMsg_RebroadcastGameEvent::IsInitialized() const {
  return true;
}

void CBidirMsg_RebroadcastGameEvent::InternalSwap(CBidirMsg_RebroadcastGameEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBidirMsg_RebroadcastGameEvent, _impl_.clientbitcount_)
      + sizeof(CBidirMsg_RebroadcastGameEvent::_impl_.clientbitcount_)
      - PROTOBUF_FIELD_OFFSET(CBidirMsg_RebroadcastGameEvent, _impl_.posttoserver_)>(
          reinterpret_cast<char*>(&_impl_.posttoserver_),
          reinterpret_cast<char*>(&other->_impl_.posttoserver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CBidirMsg_RebroadcastGameEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[65]);
}

// ===================================================================

class CBidirMsg_RebroadcastSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CBidirMsg_RebroadcastSource>()._impl_._has_bits_);
  static void set_has_eventsource(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBidirMsg_RebroadcastSource)
}
CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(const CBidirMsg_RebroadcastSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBidirMsg_RebroadcastSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventsource_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eventsource_ = from._impl_.eventsource_;
  // @@protoc_insertion_point(copy_constructor:CBidirMsg_RebroadcastSource)
}

inline void CBidirMsg_RebroadcastSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventsource_){0}
  };
}

CBidirMsg_RebroadcastSource::~CBidirMsg_RebroadcastSource() {
  // @@protoc_insertion_point(destructor:CBidirMsg_RebroadcastSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBidirMsg_RebroadcastSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CBidirMsg_RebroadcastSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBidirMsg_RebroadcastSource::Clear() {
// @@protoc_insertion_point(message_clear_start:CBidirMsg_RebroadcastSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eventsource_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBidirMsg_RebroadcastSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eventsource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eventsource(&has_bits);
          _impl_.eventsource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBidirMsg_RebroadcastSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBidirMsg_RebroadcastSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eventsource = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eventsource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBidirMsg_RebroadcastSource)
  return target;
}

size_t CBidirMsg_RebroadcastSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBidirMsg_RebroadcastSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eventsource = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eventsource());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBidirMsg_RebroadcastSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBidirMsg_RebroadcastSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBidirMsg_RebroadcastSource::GetClassData() const { return &_class_data_; }


void CBidirMsg_RebroadcastSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBidirMsg_RebroadcastSource*>(&to_msg);
  auto& from = static_cast<const CBidirMsg_RebroadcastSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBidirMsg_RebroadcastSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eventsource()) {
    _this->_internal_set_eventsource(from._internal_eventsource());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBidirMsg_RebroadcastSource::CopyFrom(const CBidirMsg_RebroadcastSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBidirMsg_RebroadcastSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBidirMsg_RebroadcastSource::IsInitialized() const {
  return true;
}

void CBidirMsg_RebroadcastSource::InternalSwap(CBidirMsg_RebroadcastSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eventsource_, other->_impl_.eventsource_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBidirMsg_RebroadcastSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[66]);
}

// ===================================================================

class CMsgServerNetworkStats_Port::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats_Port>()._impl_._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats.Port)
}
CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(const CMsgServerNetworkStats_Port& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats_Port* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats.Port)
}

inline void CMsgServerNetworkStats_Port::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.port_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerNetworkStats_Port::~CMsgServerNetworkStats_Port() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats.Port)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats_Port::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgServerNetworkStats_Port::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats_Port::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats.Port)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats_Port::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgServerNetworkStats.Port.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats_Port::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats.Port)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 port = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_port(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgServerNetworkStats.Port.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats.Port)
  return target;
}

size_t CMsgServerNetworkStats_Port::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats.Port)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 port = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats_Port::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats_Port::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats_Port::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats_Port::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats_Port*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats_Port&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats.Port)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats_Port::CopyFrom(const CMsgServerNetworkStats_Port& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats.Port)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats_Port::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats_Port::InternalSwap(CMsgServerNetworkStats_Port* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats_Port::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[67]);
}

// ===================================================================

class CMsgServerNetworkStats_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats_Player>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ping_avg_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_packet_loss_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_loss_in(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_loss_out(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_engine_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats.Player)
}
CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(const CMsgServerNetworkStats_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_addr_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.ping_avg_ms_){}
    , decltype(_impl_.packet_loss_pct_){}
    , decltype(_impl_.is_bot_){}
    , decltype(_impl_.loss_in_){}
    , decltype(_impl_.loss_out_){}
    , decltype(_impl_.engine_latency_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.remote_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_addr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_addr()) {
    _this->_impl_.remote_addr_.Set(from._internal_remote_addr(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.engine_latency_ms_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.engine_latency_ms_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats.Player)
}

inline void CMsgServerNetworkStats_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_addr_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.ping_avg_ms_){0}
    , decltype(_impl_.packet_loss_pct_){0}
    , decltype(_impl_.is_bot_){false}
    , decltype(_impl_.loss_in_){0}
    , decltype(_impl_.loss_out_){0}
    , decltype(_impl_.engine_latency_ms_){0}
  };
  _impl_.remote_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_addr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerNetworkStats_Player::~CMsgServerNetworkStats_Player() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_addr_.Destroy();
}

void CMsgServerNetworkStats_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.remote_addr_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.engine_latency_ms_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.engine_latency_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string remote_addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_remote_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgServerNetworkStats.Player.remote_addr");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 ping_avg_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ping_avg_ms(&has_bits);
          _impl_.ping_avg_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float packet_loss_pct = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_packet_loss_pct(&has_bits);
          _impl_.packet_loss_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_bot = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_bot(&has_bits);
          _impl_.is_bot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float loss_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_loss_in(&has_bits);
          _impl_.loss_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float loss_out = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_loss_out(&has_bits);
          _impl_.loss_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 engine_latency_ms = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_engine_latency_ms(&has_bits);
          _impl_.engine_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string remote_addr = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_remote_addr().data(), static_cast<int>(this->_internal_remote_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgServerNetworkStats.Player.remote_addr");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_addr(), target);
  }

  // optional int32 ping_avg_ms = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_ping_avg_ms(), target);
  }

  // optional float packet_loss_pct = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_packet_loss_pct(), target);
  }

  // optional bool is_bot = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_bot(), target);
  }

  // optional float loss_in = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_loss_in(), target);
  }

  // optional float loss_out = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_loss_out(), target);
  }

  // optional int32 engine_latency_ms = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_engine_latency_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats.Player)
  return target;
}

size_t CMsgServerNetworkStats_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string remote_addr = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_addr());
    }

    // optional uint64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional int32 ping_avg_ms = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ping_avg_ms());
    }

    // optional float packet_loss_pct = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool is_bot = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional float loss_in = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float loss_out = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 engine_latency_ms = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_engine_latency_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats_Player::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats_Player*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_remote_addr(from._internal_remote_addr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ping_avg_ms_ = from._impl_.ping_avg_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.packet_loss_pct_ = from._impl_.packet_loss_pct_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_bot_ = from._impl_.is_bot_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.loss_in_ = from._impl_.loss_in_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.loss_out_ = from._impl_.loss_out_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.engine_latency_ms_ = from._impl_.engine_latency_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats_Player::CopyFrom(const CMsgServerNetworkStats_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats_Player::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats_Player::InternalSwap(CMsgServerNetworkStats_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_addr_, lhs_arena,
      &other->_impl_.remote_addr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats_Player, _impl_.engine_latency_ms_)
      + sizeof(CMsgServerNetworkStats_Player::_impl_.engine_latency_ms_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats_Player, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[68]);
}

// ===================================================================

class CMsgServerNetworkStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats>()._impl_._has_bits_);
  static void set_has_dedicated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_memory_used_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_memory_free_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_uptime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_spawn_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_bots(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_spectators(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_num_tv_relays(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_fps(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_avg_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_avg_engine_latency_out(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_avg_packets_out(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_avg_packets_in(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_avg_loss_out(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_avg_loss_in(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_avg_data_out(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_avg_data_in(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_total_data_in(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_total_packets_in(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_total_data_out(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_total_packets_out(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

CMsgServerNetworkStats::CMsgServerNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats)
}
CMsgServerNetworkStats::CMsgServerNetworkStats(const CMsgServerNetworkStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.dedicated_){}
    , decltype(_impl_.cpu_usage_){}
    , decltype(_impl_.memory_used_mb_){}
    , decltype(_impl_.memory_free_mb_){}
    , decltype(_impl_.uptime_){}
    , decltype(_impl_.spawn_count_){}
    , decltype(_impl_.num_clients_){}
    , decltype(_impl_.num_bots_){}
    , decltype(_impl_.num_spectators_){}
    , decltype(_impl_.num_tv_relays_){}
    , decltype(_impl_.fps_){}
    , decltype(_impl_.avg_ping_ms_){}
    , decltype(_impl_.avg_engine_latency_out_){}
    , decltype(_impl_.avg_packets_out_){}
    , decltype(_impl_.avg_packets_in_){}
    , decltype(_impl_.avg_loss_out_){}
    , decltype(_impl_.avg_loss_in_){}
    , decltype(_impl_.avg_data_out_){}
    , decltype(_impl_.total_data_in_){}
    , decltype(_impl_.total_packets_in_){}
    , decltype(_impl_.total_data_out_){}
    , decltype(_impl_.total_packets_out_){}
    , decltype(_impl_.avg_data_in_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dedicated_, &from._impl_.dedicated_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.avg_data_in_) -
    reinterpret_cast<char*>(&_impl_.dedicated_)) + sizeof(_impl_.avg_data_in_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats)
}

inline void CMsgServerNetworkStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){arena}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.dedicated_){false}
    , decltype(_impl_.cpu_usage_){0}
    , decltype(_impl_.memory_used_mb_){0}
    , decltype(_impl_.memory_free_mb_){0}
    , decltype(_impl_.uptime_){0}
    , decltype(_impl_.spawn_count_){0}
    , decltype(_impl_.num_clients_){0}
    , decltype(_impl_.num_bots_){0}
    , decltype(_impl_.num_spectators_){0}
    , decltype(_impl_.num_tv_relays_){0}
    , decltype(_impl_.fps_){0}
    , decltype(_impl_.avg_ping_ms_){0}
    , decltype(_impl_.avg_engine_latency_out_){0}
    , decltype(_impl_.avg_packets_out_){0}
    , decltype(_impl_.avg_packets_in_){0}
    , decltype(_impl_.avg_loss_out_){0}
    , decltype(_impl_.avg_loss_in_){0}
    , decltype(_impl_.avg_data_out_){0}
    , decltype(_impl_.total_data_in_){uint64_t{0u}}
    , decltype(_impl_.total_packets_in_){uint64_t{0u}}
    , decltype(_impl_.total_data_out_){uint64_t{0u}}
    , decltype(_impl_.total_packets_out_){uint64_t{0u}}
    , decltype(_impl_.avg_data_in_){0}
  };
}

CMsgServerNetworkStats::~CMsgServerNetworkStats() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedPtrField();
  _impl_.players_.~RepeatedPtrField();
}

void CMsgServerNetworkStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  _impl_.players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dedicated_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_bots_) -
        reinterpret_cast<char*>(&_impl_.dedicated_)) + sizeof(_impl_.num_bots_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.num_spectators_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.avg_loss_out_) -
        reinterpret_cast<char*>(&_impl_.num_spectators_)) + sizeof(_impl_.avg_loss_out_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&_impl_.avg_loss_in_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.avg_data_in_) -
        reinterpret_cast<char*>(&_impl_.avg_loss_in_)) + sizeof(_impl_.avg_data_in_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool dedicated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dedicated(&has_bits);
          _impl_.dedicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_usage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cpu_usage(&has_bits);
          _impl_.cpu_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 memory_used_mb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_memory_used_mb(&has_bits);
          _impl_.memory_used_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 memory_free_mb = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_memory_free_mb(&has_bits);
          _impl_.memory_free_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_uptime(&has_bits);
          _impl_.uptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 spawn_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_spawn_count(&has_bits);
          _impl_.spawn_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_clients = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_num_clients(&has_bits);
          _impl_.num_clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_bots = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_num_bots(&has_bits);
          _impl_.num_bots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_spectators = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_num_spectators(&has_bits);
          _impl_.num_spectators_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_tv_relays = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_num_tv_relays(&has_bits);
          _impl_.num_tv_relays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fps = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_fps(&has_bits);
          _impl_.fps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgServerNetworkStats.Port ports = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float avg_ping_ms = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_avg_ping_ms(&has_bits);
          _impl_.avg_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_engine_latency_out = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_avg_engine_latency_out(&has_bits);
          _impl_.avg_engine_latency_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_packets_out = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _Internal::set_has_avg_packets_out(&has_bits);
          _impl_.avg_packets_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_packets_in = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_avg_packets_in(&has_bits);
          _impl_.avg_packets_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_loss_out = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_avg_loss_out(&has_bits);
          _impl_.avg_loss_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_loss_in = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _Internal::set_has_avg_loss_in(&has_bits);
          _impl_.avg_loss_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_data_out = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _Internal::set_has_avg_data_out(&has_bits);
          _impl_.avg_data_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_data_in = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_avg_data_in(&has_bits);
          _impl_.avg_data_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_data_in = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_total_data_in(&has_bits);
          _impl_.total_data_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_packets_in = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_total_packets_in(&has_bits);
          _impl_.total_packets_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_data_out = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_total_data_out(&has_bits);
          _impl_.total_data_out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_packets_out = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_total_packets_out(&has_bits);
          _impl_.total_packets_out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgServerNetworkStats.Player players = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool dedicated = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_dedicated(), target);
  }

  // optional int32 cpu_usage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_usage(), target);
  }

  // optional int32 memory_used_mb = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_memory_used_mb(), target);
  }

  // optional int32 memory_free_mb = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_memory_free_mb(), target);
  }

  // optional int32 uptime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_uptime(), target);
  }

  // optional int32 spawn_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_spawn_count(), target);
  }

  // optional int32 num_clients = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_num_clients(), target);
  }

  // optional int32 num_bots = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_num_bots(), target);
  }

  // optional int32 num_spectators = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_num_spectators(), target);
  }

  // optional int32 num_tv_relays = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_num_tv_relays(), target);
  }

  // optional float fps = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_fps(), target);
  }

  // repeated .CMsgServerNetworkStats.Port ports = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float avg_ping_ms = 18;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_avg_ping_ms(), target);
  }

  // optional float avg_engine_latency_out = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_avg_engine_latency_out(), target);
  }

  // optional float avg_packets_out = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_avg_packets_out(), target);
  }

  // optional float avg_packets_in = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_avg_packets_in(), target);
  }

  // optional float avg_loss_out = 22;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_avg_loss_out(), target);
  }

  // optional float avg_loss_in = 23;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_avg_loss_in(), target);
  }

  // optional float avg_data_out = 24;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_avg_data_out(), target);
  }

  // optional float avg_data_in = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_avg_data_in(), target);
  }

  // optional uint64 total_data_in = 26;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_total_data_in(), target);
  }

  // optional uint64 total_packets_in = 27;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(27, this->_internal_total_packets_in(), target);
  }

  // optional uint64 total_data_out = 28;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(28, this->_internal_total_data_out(), target);
  }

  // optional uint64 total_packets_out = 29;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(29, this->_internal_total_packets_out(), target);
  }

  // repeated .CMsgServerNetworkStats.Player players = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats)
  return target;
}

size_t CMsgServerNetworkStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgServerNetworkStats.Port ports = 17;
  total_size += 2UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgServerNetworkStats.Player players = 30;
  total_size += 2UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool dedicated = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 cpu_usage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_usage());
    }

    // optional int32 memory_used_mb = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_memory_used_mb());
    }

    // optional int32 memory_free_mb = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_memory_free_mb());
    }

    // optional int32 uptime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptime());
    }

    // optional int32 spawn_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_spawn_count());
    }

    // optional int32 num_clients = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_clients());
    }

    // optional int32 num_bots = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bots());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 num_spectators = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_spectators());
    }

    // optional int32 num_tv_relays = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_tv_relays());
    }

    // optional float fps = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float avg_ping_ms = 18;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 4;
    }

    // optional float avg_engine_latency_out = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 4;
    }

    // optional float avg_packets_out = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional float avg_packets_in = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float avg_loss_out = 22;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional float avg_loss_in = 23;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float avg_data_out = 24;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional uint64 total_data_in = 26;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_data_in());
    }

    // optional uint64 total_packets_in = 27;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_packets_in());
    }

    // optional uint64 total_data_out = 28;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_data_out());
    }

    // optional uint64 total_packets_out = 29;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_packets_out());
    }

    // optional float avg_data_in = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dedicated_ = from._impl_.dedicated_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cpu_usage_ = from._impl_.cpu_usage_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.memory_used_mb_ = from._impl_.memory_used_mb_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.memory_free_mb_ = from._impl_.memory_free_mb_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.uptime_ = from._impl_.uptime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.spawn_count_ = from._impl_.spawn_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_clients_ = from._impl_.num_clients_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.num_bots_ = from._impl_.num_bots_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.num_spectators_ = from._impl_.num_spectators_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.num_tv_relays_ = from._impl_.num_tv_relays_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.fps_ = from._impl_.fps_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.avg_ping_ms_ = from._impl_.avg_ping_ms_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.avg_engine_latency_out_ = from._impl_.avg_engine_latency_out_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.avg_packets_out_ = from._impl_.avg_packets_out_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.avg_packets_in_ = from._impl_.avg_packets_in_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.avg_loss_out_ = from._impl_.avg_loss_out_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.avg_loss_in_ = from._impl_.avg_loss_in_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.avg_data_out_ = from._impl_.avg_data_out_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.total_data_in_ = from._impl_.total_data_in_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.total_packets_in_ = from._impl_.total_packets_in_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.total_data_out_ = from._impl_.total_data_out_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.total_packets_out_ = from._impl_.total_packets_out_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.avg_data_in_ = from._impl_.avg_data_in_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats::CopyFrom(const CMsgServerNetworkStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats::InternalSwap(CMsgServerNetworkStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats, _impl_.avg_data_in_)
      + sizeof(CMsgServerNetworkStats::_impl_.avg_data_in_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats, _impl_.dedicated_)>(
          reinterpret_cast<char*>(&_impl_.dedicated_),
          reinterpret_cast<char*>(&other->_impl_.dedicated_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[69]);
}

// ===================================================================

class CSVCMsg_HltvReplay::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HltvReplay>()._impl_._has_bits_);
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_primary_target(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_replay_stop_at(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replay_start_at(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_replay_slowdown_begin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_replay_slowdown_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_replay_slowdown_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HltvReplay)
}
CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(const CSVCMsg_HltvReplay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HltvReplay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.replay_stop_at_){}
    , decltype(_impl_.replay_start_at_){}
    , decltype(_impl_.replay_slowdown_begin_){}
    , decltype(_impl_.replay_slowdown_end_){}
    , decltype(_impl_.replay_slowdown_rate_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.primary_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.delay_, &from._impl_.delay_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primary_target_) -
    reinterpret_cast<char*>(&_impl_.delay_)) + sizeof(_impl_.primary_target_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HltvReplay)
}

inline void CSVCMsg_HltvReplay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_){0}
    , decltype(_impl_.replay_stop_at_){0}
    , decltype(_impl_.replay_start_at_){0}
    , decltype(_impl_.replay_slowdown_begin_){0}
    , decltype(_impl_.replay_slowdown_end_){0}
    , decltype(_impl_.replay_slowdown_rate_){0}
    , decltype(_impl_.reason_){0}
    , decltype(_impl_.primary_target_){-1}
  };
}

CSVCMsg_HltvReplay::~CSVCMsg_HltvReplay() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HltvReplay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HltvReplay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_HltvReplay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HltvReplay::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.delay_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reason_) -
        reinterpret_cast<char*>(&_impl_.delay_)) + sizeof(_impl_.reason_));
    _impl_.primary_target_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HltvReplay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 delay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_delay(&has_bits);
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_target = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_primary_target(&has_bits);
          _impl_.primary_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_stop_at = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_replay_stop_at(&has_bits);
          _impl_.replay_stop_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_start_at = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_replay_start_at(&has_bits);
          _impl_.replay_start_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_slowdown_begin = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_replay_slowdown_begin(&has_bits);
          _impl_.replay_slowdown_begin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_slowdown_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_replay_slowdown_end(&has_bits);
          _impl_.replay_slowdown_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float replay_slowdown_rate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_replay_slowdown_rate(&has_bits);
          _impl_.replay_slowdown_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reason = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HltvReplay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 delay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_delay(), target);
  }

  // optional int32 primary_target = 2 [default = -1];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_primary_target(), target);
  }

  // optional int32 replay_stop_at = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_replay_stop_at(), target);
  }

  // optional int32 replay_start_at = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_replay_start_at(), target);
  }

  // optional int32 replay_slowdown_begin = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_replay_slowdown_begin(), target);
  }

  // optional int32 replay_slowdown_end = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_replay_slowdown_end(), target);
  }

  // optional float replay_slowdown_rate = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_replay_slowdown_rate(), target);
  }

  // optional int32 reason = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HltvReplay)
  return target;
}

size_t CSVCMsg_HltvReplay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HltvReplay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 delay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delay());
    }

    // optional int32 replay_stop_at = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_stop_at());
    }

    // optional int32 replay_start_at = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_start_at());
    }

    // optional int32 replay_slowdown_begin = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_slowdown_begin());
    }

    // optional int32 replay_slowdown_end = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_slowdown_end());
    }

    // optional float replay_slowdown_rate = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 reason = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reason());
    }

    // optional int32 primary_target = 2 [default = -1];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HltvReplay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HltvReplay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HltvReplay::GetClassData() const { return &_class_data_; }


void CSVCMsg_HltvReplay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HltvReplay*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HltvReplay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HltvReplay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.delay_ = from._impl_.delay_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.replay_stop_at_ = from._impl_.replay_stop_at_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.replay_start_at_ = from._impl_.replay_start_at_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.replay_slowdown_begin_ = from._impl_.replay_slowdown_begin_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.replay_slowdown_end_ = from._impl_.replay_slowdown_end_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.replay_slowdown_rate_ = from._impl_.replay_slowdown_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.primary_target_ = from._impl_.primary_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HltvReplay::CopyFrom(const CSVCMsg_HltvReplay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HltvReplay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HltvReplay::IsInitialized() const {
  return true;
}

void CSVCMsg_HltvReplay::InternalSwap(CSVCMsg_HltvReplay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_HltvReplay, _impl_.reason_)
      + sizeof(CSVCMsg_HltvReplay::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_HltvReplay, _impl_.delay_)>(
          reinterpret_cast<char*>(&_impl_.delay_),
          reinterpret_cast<char*>(&other->_impl_.delay_));
  swap(_impl_.primary_target_, other->_impl_.primary_target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HltvReplay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[70]);
}

// ===================================================================

class CCLCMsg_HltvReplay::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_HltvReplay>()._impl_._has_bits_);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slowdown_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slowdown_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_primary_target(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_HltvReplay)
}
CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(const CCLCMsg_HltvReplay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_HltvReplay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_){}
    , decltype(_impl_.slowdown_length_){}
    , decltype(_impl_.slowdown_rate_){}
    , decltype(_impl_.event_time_){}
    , decltype(_impl_.primary_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.request_, &from._impl_.request_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primary_target_) -
    reinterpret_cast<char*>(&_impl_.request_)) + sizeof(_impl_.primary_target_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_HltvReplay)
}

inline void CCLCMsg_HltvReplay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_){0}
    , decltype(_impl_.slowdown_length_){0}
    , decltype(_impl_.slowdown_rate_){0}
    , decltype(_impl_.event_time_){0}
    , decltype(_impl_.primary_target_){-1}
  };
}

CCLCMsg_HltvReplay::~CCLCMsg_HltvReplay() {
  // @@protoc_insertion_point(destructor:CCLCMsg_HltvReplay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_HltvReplay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_HltvReplay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_HltvReplay::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.request_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.event_time_) -
        reinterpret_cast<char*>(&_impl_.request_)) + sizeof(_impl_.event_time_));
    _impl_.primary_target_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_HltvReplay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request(&has_bits);
          _impl_.request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float slowdown_length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_slowdown_length(&has_bits);
          _impl_.slowdown_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float slowdown_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_slowdown_rate(&has_bits);
          _impl_.slowdown_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_target = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_primary_target(&has_bits);
          _impl_.primary_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float event_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_event_time(&has_bits);
          _impl_.event_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_HltvReplay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_request(), target);
  }

  // optional float slowdown_length = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_slowdown_length(), target);
  }

  // optional float slowdown_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_slowdown_rate(), target);
  }

  // optional int32 primary_target = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_primary_target(), target);
  }

  // optional float event_time = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_event_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_HltvReplay)
  return target;
}

size_t CCLCMsg_HltvReplay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_HltvReplay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_request());
    }

    // optional float slowdown_length = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float slowdown_rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float event_time = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 primary_target = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_HltvReplay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_HltvReplay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_HltvReplay::GetClassData() const { return &_class_data_; }


void CCLCMsg_HltvReplay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_HltvReplay*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_HltvReplay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_HltvReplay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_ = from._impl_.request_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slowdown_length_ = from._impl_.slowdown_length_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.slowdown_rate_ = from._impl_.slowdown_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_time_ = from._impl_.event_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primary_target_ = from._impl_.primary_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_HltvReplay::CopyFrom(const CCLCMsg_HltvReplay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_HltvReplay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_HltvReplay::IsInitialized() const {
  return true;
}

void CCLCMsg_HltvReplay::InternalSwap(CCLCMsg_HltvReplay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvReplay, _impl_.event_time_)
      + sizeof(CCLCMsg_HltvReplay::_impl_.event_time_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvReplay, _impl_.request_)>(
          reinterpret_cast<char*>(&_impl_.request_),
          reinterpret_cast<char*>(&other->_impl_.request_));
  swap(_impl_.primary_target_, other->_impl_.primary_target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_HltvReplay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[71]);
}

// ===================================================================

class CSVCMsg_Broadcast_Command::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Broadcast_Command>()._impl_._has_bits_);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Broadcast_Command)
}
CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(const CSVCMsg_Broadcast_Command& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Broadcast_Command* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cmd_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cmd()) {
    _this->_impl_.cmd_.Set(from._internal_cmd(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Broadcast_Command)
}

inline void CSVCMsg_Broadcast_Command::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cmd_){}
  };
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Broadcast_Command::~CSVCMsg_Broadcast_Command() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Broadcast_Command)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Broadcast_Command::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cmd_.Destroy();
}

void CSVCMsg_Broadcast_Command::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Broadcast_Command::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Broadcast_Command)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cmd_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Broadcast_Command::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cmd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_Broadcast_Command.cmd");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Broadcast_Command::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Broadcast_Command)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string cmd = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cmd().data(), static_cast<int>(this->_internal_cmd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_Broadcast_Command.cmd");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cmd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Broadcast_Command)
  return target;
}

size_t CSVCMsg_Broadcast_Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Broadcast_Command)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string cmd = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cmd());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Broadcast_Command::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Broadcast_Command::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Broadcast_Command::GetClassData() const { return &_class_data_; }


void CSVCMsg_Broadcast_Command::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Broadcast_Command*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Broadcast_Command&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Broadcast_Command)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cmd()) {
    _this->_internal_set_cmd(from._internal_cmd());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Broadcast_Command::CopyFrom(const CSVCMsg_Broadcast_Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Broadcast_Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Broadcast_Command::IsInitialized() const {
  return true;
}

void CSVCMsg_Broadcast_Command::InternalSwap(CSVCMsg_Broadcast_Command* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cmd_, lhs_arena,
      &other->_impl_.cmd_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Broadcast_Command::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[72]);
}

// ===================================================================

class CCLCMsg_HltvFixupOperatorTick::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_HltvFixupOperatorTick>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_props_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& origin(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& eye_angles(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_eye_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_observer_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cameraman_scoreboard(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_observer_target(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::CMsgVector& view_offset(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_view_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CCLCMsg_HltvFixupOperatorTick::_Internal::origin(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle&
CCLCMsg_HltvFixupOperatorTick::_Internal::eye_angles(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.eye_angles_;
}
const ::CMsgVector&
CCLCMsg_HltvFixupOperatorTick::_Internal::view_offset(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.view_offset_;
}
void CCLCMsg_HltvFixupOperatorTick::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CCLCMsg_HltvFixupOperatorTick::clear_eye_angles() {
  if (_impl_.eye_angles_ != nullptr) _impl_.eye_angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CCLCMsg_HltvFixupOperatorTick::clear_view_offset() {
  if (_impl_.view_offset_ != nullptr) _impl_.view_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_HltvFixupOperatorTick)
}
CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(const CCLCMsg_HltvFixupOperatorTick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_HltvFixupOperatorTick* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_data_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.eye_angles_){nullptr}
    , decltype(_impl_.view_offset_){nullptr}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.observer_mode_){}
    , decltype(_impl_.cameraman_scoreboard_){}
    , decltype(_impl_.observer_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.props_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.props_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_props_data()) {
    _this->_impl_.props_data_.Set(from._internal_props_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_eye_angles()) {
    _this->_impl_.eye_angles_ = new ::CMsgQAngle(*from._impl_.eye_angles_);
  }
  if (from._internal_has_view_offset()) {
    _this->_impl_.view_offset_ = new ::CMsgVector(*from._impl_.view_offset_);
  }
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.observer_target_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.observer_target_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_HltvFixupOperatorTick)
}

inline void CCLCMsg_HltvFixupOperatorTick::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_data_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.eye_angles_){nullptr}
    , decltype(_impl_.view_offset_){nullptr}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.observer_mode_){0}
    , decltype(_impl_.cameraman_scoreboard_){false}
    , decltype(_impl_.observer_target_){0}
  };
  _impl_.props_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.props_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_HltvFixupOperatorTick::~CCLCMsg_HltvFixupOperatorTick() {
  // @@protoc_insertion_point(destructor:CCLCMsg_HltvFixupOperatorTick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_HltvFixupOperatorTick::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.props_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.eye_angles_;
  if (this != internal_default_instance()) delete _impl_.view_offset_;
}

void CCLCMsg_HltvFixupOperatorTick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_HltvFixupOperatorTick::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_HltvFixupOperatorTick)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.props_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.eye_angles_ != nullptr);
      _impl_.eye_angles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.view_offset_ != nullptr);
      _impl_.view_offset_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.observer_target_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.observer_target_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_HltvFixupOperatorTick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes props_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_props_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector origin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle eye_angles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_eye_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 observer_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_observer_mode(&has_bits);
          _impl_.observer_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cameraman_scoreboard = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cameraman_scoreboard(&has_bits);
          _impl_.cameraman_scoreboard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 observer_target = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_observer_target(&has_bits);
          _impl_.observer_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector view_offset = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_offset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_HltvFixupOperatorTick::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_HltvFixupOperatorTick)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional bytes props_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_props_data(), target);
  }

  // optional .CMsgVector origin = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle eye_angles = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::eye_angles(this),
        _Internal::eye_angles(this).GetCachedSize(), target, stream);
  }

  // optional int32 observer_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_observer_mode(), target);
  }

  // optional bool cameraman_scoreboard = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_cameraman_scoreboard(), target);
  }

  // optional int32 observer_target = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_observer_target(), target);
  }

  // optional .CMsgVector view_offset = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::view_offset(this),
        _Internal::view_offset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_HltvFixupOperatorTick)
  return target;
}

size_t CCLCMsg_HltvFixupOperatorTick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_HltvFixupOperatorTick)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes props_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_props_data());
    }

    // optional .CMsgVector origin = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle eye_angles = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.eye_angles_);
    }

    // optional .CMsgVector view_offset = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.view_offset_);
    }

    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 observer_mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_observer_mode());
    }

    // optional bool cameraman_scoreboard = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 observer_target = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_observer_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_HltvFixupOperatorTick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_HltvFixupOperatorTick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_HltvFixupOperatorTick::GetClassData() const { return &_class_data_; }


void CCLCMsg_HltvFixupOperatorTick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_HltvFixupOperatorTick*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_HltvFixupOperatorTick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_HltvFixupOperatorTick)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_props_data(from._internal_props_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_eye_angles()->::CMsgQAngle::MergeFrom(
          from._internal_eye_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_view_offset()->::CMsgVector::MergeFrom(
          from._internal_view_offset());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.observer_mode_ = from._impl_.observer_mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cameraman_scoreboard_ = from._impl_.cameraman_scoreboard_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.observer_target_ = from._impl_.observer_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_HltvFixupOperatorTick::CopyFrom(const CCLCMsg_HltvFixupOperatorTick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_HltvFixupOperatorTick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_HltvFixupOperatorTick::IsInitialized() const {
  return true;
}

void CCLCMsg_HltvFixupOperatorTick::InternalSwap(CCLCMsg_HltvFixupOperatorTick* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.props_data_, lhs_arena,
      &other->_impl_.props_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvFixupOperatorTick, _impl_.observer_target_)
      + sizeof(CCLCMsg_HltvFixupOperatorTick::_impl_.observer_target_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvFixupOperatorTick, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_HltvFixupOperatorTick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[73]);
}

// ===================================================================

class CSVCMsg_HltvFixupOperatorStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HltvFixupOperatorStatus>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_override_operator_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HltvFixupOperatorStatus)
}
CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(const CSVCMsg_HltvFixupOperatorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HltvFixupOperatorStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.override_operator_name_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.override_operator_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.override_operator_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_override_operator_name()) {
    _this->_impl_.override_operator_name_.Set(from._internal_override_operator_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HltvFixupOperatorStatus)
}

inline void CSVCMsg_HltvFixupOperatorStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.override_operator_name_){}
    , decltype(_impl_.mode_){0u}
  };
  _impl_.override_operator_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.override_operator_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_HltvFixupOperatorStatus::~CSVCMsg_HltvFixupOperatorStatus() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HltvFixupOperatorStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HltvFixupOperatorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.override_operator_name_.Destroy();
}

void CSVCMsg_HltvFixupOperatorStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HltvFixupOperatorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HltvFixupOperatorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.override_operator_name_.ClearNonDefaultToEmpty();
  }
  _impl_.mode_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HltvFixupOperatorStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string override_operator_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_override_operator_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_HltvFixupOperatorStatus.override_operator_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HltvFixupOperatorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HltvFixupOperatorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 mode = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mode(), target);
  }

  // optional string override_operator_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_override_operator_name().data(), static_cast<int>(this->_internal_override_operator_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_HltvFixupOperatorStatus.override_operator_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_override_operator_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HltvFixupOperatorStatus)
  return target;
}

size_t CSVCMsg_HltvFixupOperatorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HltvFixupOperatorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string override_operator_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_override_operator_name());
    }

    // optional uint32 mode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HltvFixupOperatorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HltvFixupOperatorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HltvFixupOperatorStatus::GetClassData() const { return &_class_data_; }


void CSVCMsg_HltvFixupOperatorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HltvFixupOperatorStatus*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HltvFixupOperatorStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HltvFixupOperatorStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_override_operator_name(from._internal_override_operator_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HltvFixupOperatorStatus::CopyFrom(const CSVCMsg_HltvFixupOperatorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HltvFixupOperatorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HltvFixupOperatorStatus::IsInitialized() const {
  return true;
}

void CSVCMsg_HltvFixupOperatorStatus::InternalSwap(CSVCMsg_HltvFixupOperatorStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.override_operator_name_, lhs_arena,
      &other->_impl_.override_operator_name_, rhs_arena
  );
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HltvFixupOperatorStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[74]);
}

// ===================================================================

class CMsgServerUserCmd::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerUserCmd>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cmd_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_server_tick_executed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgServerUserCmd::CMsgServerUserCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerUserCmd)
}
CMsgServerUserCmd::CMsgServerUserCmd(const CMsgServerUserCmd& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerUserCmd* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.cmd_number_){}
    , decltype(_impl_.server_tick_executed_){}
    , decltype(_impl_.client_tick_){}
    , decltype(_impl_.player_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cmd_number_, &from._impl_.cmd_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_slot_) -
    reinterpret_cast<char*>(&_impl_.cmd_number_)) + sizeof(_impl_.player_slot_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerUserCmd)
}

inline void CMsgServerUserCmd::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.cmd_number_){0}
    , decltype(_impl_.server_tick_executed_){0}
    , decltype(_impl_.client_tick_){0}
    , decltype(_impl_.player_slot_){-1}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerUserCmd::~CMsgServerUserCmd() {
  // @@protoc_insertion_point(destructor:CMsgServerUserCmd)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerUserCmd::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CMsgServerUserCmd::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerUserCmd::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerUserCmd)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.cmd_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_tick_) -
        reinterpret_cast<char*>(&_impl_.cmd_number_)) + sizeof(_impl_.client_tick_));
    _impl_.player_slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerUserCmd::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cmd_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cmd_number(&has_bits);
          _impl_.cmd_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_slot = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 server_tick_executed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_server_tick_executed(&has_bits);
          _impl_.server_tick_executed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client_tick = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_client_tick(&has_bits);
          _impl_.client_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerUserCmd::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerUserCmd)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // optional int32 cmd_number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cmd_number(), target);
  }

  // optional int32 player_slot = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_player_slot(), target);
  }

  // optional int32 server_tick_executed = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_server_tick_executed(), target);
  }

  // optional int32 client_tick = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_client_tick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerUserCmd)
  return target;
}

size_t CMsgServerUserCmd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerUserCmd)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 cmd_number = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cmd_number());
    }

    // optional int32 server_tick_executed = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_server_tick_executed());
    }

    // optional int32 client_tick = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_tick());
    }

    // optional int32 player_slot = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerUserCmd::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerUserCmd::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerUserCmd::GetClassData() const { return &_class_data_; }


void CMsgServerUserCmd::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerUserCmd*>(&to_msg);
  auto& from = static_cast<const CMsgServerUserCmd&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerUserCmd)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cmd_number_ = from._impl_.cmd_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.server_tick_executed_ = from._impl_.server_tick_executed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_tick_ = from._impl_.client_tick_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerUserCmd::CopyFrom(const CMsgServerUserCmd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerUserCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerUserCmd::IsInitialized() const {
  return true;
}

void CMsgServerUserCmd::InternalSwap(CMsgServerUserCmd* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerUserCmd, _impl_.client_tick_)
      + sizeof(CMsgServerUserCmd::_impl_.client_tick_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerUserCmd, _impl_.cmd_number_)>(
          reinterpret_cast<char*>(&_impl_.cmd_number_),
          reinterpret_cast<char*>(&other->_impl_.cmd_number_));
  swap(_impl_.player_slot_, other->_impl_.player_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerUserCmd::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[75]);
}

// ===================================================================

class CSVCMsg_UserCommands::_Internal {
 public:
};

CSVCMsg_UserCommands::CSVCMsg_UserCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_UserCommands)
}
CSVCMsg_UserCommands::CSVCMsg_UserCommands(const CSVCMsg_UserCommands& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_UserCommands* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){from._impl_.commands_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_UserCommands)
}

inline void CSVCMsg_UserCommands::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_UserCommands::~CSVCMsg_UserCommands() {
  // @@protoc_insertion_point(destructor:CSVCMsg_UserCommands)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_UserCommands::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
}

void CSVCMsg_UserCommands::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_UserCommands::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_UserCommands)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_UserCommands::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgServerUserCmd commands = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_UserCommands::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_UserCommands)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgServerUserCmd commands = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_UserCommands)
  return target;
}

size_t CSVCMsg_UserCommands::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_UserCommands)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgServerUserCmd commands = 1;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_UserCommands::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_UserCommands::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_UserCommands::GetClassData() const { return &_class_data_; }


void CSVCMsg_UserCommands::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_UserCommands*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_UserCommands&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_UserCommands)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_UserCommands::CopyFrom(const CSVCMsg_UserCommands& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_UserCommands)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_UserCommands::IsInitialized() const {
  return true;
}

void CSVCMsg_UserCommands::InternalSwap(CSVCMsg_UserCommands* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_UserCommands::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[76]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CCLCMsg_ClientInfo*
Arena::CreateMaybeMessage< ::CCLCMsg_ClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_Move*
Arena::CreateMaybeMessage< ::CCLCMsg_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgVoiceAudio*
Arena::CreateMaybeMessage< ::CMsgVoiceAudio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgVoiceAudio >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_VoiceData*
Arena::CreateMaybeMessage< ::CCLCMsg_VoiceData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_VoiceData >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_BaselineAck*
Arena::CreateMaybeMessage< ::CCLCMsg_BaselineAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_BaselineAck >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_ListenEvents*
Arena::CreateMaybeMessage< ::CCLCMsg_ListenEvents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ListenEvents >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RespondCvarValue*
Arena::CreateMaybeMessage< ::CCLCMsg_RespondCvarValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RespondCvarValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_FileCRCCheck*
Arena::CreateMaybeMessage< ::CCLCMsg_FileCRCCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_FileCRCCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_LoadingProgress*
Arena::CreateMaybeMessage< ::CCLCMsg_LoadingProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_LoadingProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_SplitPlayerConnect*
Arena::CreateMaybeMessage< ::CCLCMsg_SplitPlayerConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_SplitPlayerConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_SplitPlayerDisconnect*
Arena::CreateMaybeMessage< ::CCLCMsg_SplitPlayerDisconnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_SplitPlayerDisconnect >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_ServerStatus*
Arena::CreateMaybeMessage< ::CCLCMsg_ServerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ServerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RequestPause*
Arena::CreateMaybeMessage< ::CCLCMsg_RequestPause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RequestPause >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_CmdKeyValues*
Arena::CreateMaybeMessage< ::CCLCMsg_CmdKeyValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_CmdKeyValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RconServerDetails*
Arena::CreateMaybeMessage< ::CCLCMsg_RconServerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RconServerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSource2SystemSpecs*
Arena::CreateMaybeMessage< ::CMsgSource2SystemSpecs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSource2SystemSpecs >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSource2VProfLiteReportItem*
Arena::CreateMaybeMessage< ::CMsgSource2VProfLiteReportItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSource2VProfLiteReportItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSource2VProfLiteReport*
Arena::CreateMaybeMessage< ::CMsgSource2VProfLiteReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSource2VProfLiteReport >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_Diagnostic*
Arena::CreateMaybeMessage< ::CCLCMsg_Diagnostic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_Diagnostic >(arena);
}
template<> PROTOBUF_NOINLINE ::CSource2Metrics_MatchPerfSummary_Notification_Client*
Arena::CreateMaybeMessage< ::CSource2Metrics_MatchPerfSummary_Notification_Client >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSource2Metrics_MatchPerfSummary_Notification_Client >(arena);
}
template<> PROTOBUF_NOINLINE ::CSource2Metrics_MatchPerfSummary_Notification*
Arena::CreateMaybeMessage< ::CSource2Metrics_MatchPerfSummary_Notification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSource2Metrics_MatchPerfSummary_Notification >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ServerInfo*
Arena::CreateMaybeMessage< ::CSVCMsg_ServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClassInfo_class_t*
Arena::CreateMaybeMessage< ::CSVCMsg_ClassInfo_class_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClassInfo_class_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClassInfo*
Arena::CreateMaybeMessage< ::CSVCMsg_ClassInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClassInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SetPause*
Arena::CreateMaybeMessage< ::CSVCMsg_SetPause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SetPause >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_VoiceInit*
Arena::CreateMaybeMessage< ::CSVCMsg_VoiceInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_VoiceInit >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Print*
Arena::CreateMaybeMessage< ::CSVCMsg_Print >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Print >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Sounds_sounddata_t*
Arena::CreateMaybeMessage< ::CSVCMsg_Sounds_sounddata_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Sounds_sounddata_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Sounds*
Arena::CreateMaybeMessage< ::CSVCMsg_Sounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Sounds >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Prefetch*
Arena::CreateMaybeMessage< ::CSVCMsg_Prefetch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Prefetch >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SetView*
Arena::CreateMaybeMessage< ::CSVCMsg_SetView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SetView >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FixAngle*
Arena::CreateMaybeMessage< ::CSVCMsg_FixAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FixAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CrosshairAngle*
Arena::CreateMaybeMessage< ::CSVCMsg_CrosshairAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CrosshairAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_BSPDecal*
Arena::CreateMaybeMessage< ::CSVCMsg_BSPDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_BSPDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SplitScreen*
Arena::CreateMaybeMessage< ::CSVCMsg_SplitScreen >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SplitScreen >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GetCvarValue*
Arena::CreateMaybeMessage< ::CSVCMsg_GetCvarValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GetCvarValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Menu*
Arena::CreateMaybeMessage< ::CSVCMsg_Menu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Menu >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_UserMessage*
Arena::CreateMaybeMessage< ::CSVCMsg_UserMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_UserMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SendTable_sendprop_t*
Arena::CreateMaybeMessage< ::CSVCMsg_SendTable_sendprop_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SendTable_sendprop_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SendTable*
Arena::CreateMaybeMessage< ::CSVCMsg_SendTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SendTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList_key_t*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList_key_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList_key_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList_descriptor_t*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList_descriptor_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList_descriptor_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities_alternate_baseline_t*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities_alternate_baseline_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities_alternate_baseline_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities_non_transmitted_entities_t*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities_non_transmitted_entities_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities_non_transmitted_entities_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_TempEntities*
Arena::CreateMaybeMessage< ::CSVCMsg_TempEntities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_TempEntities >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CreateStringTable*
Arena::CreateMaybeMessage< ::CSVCMsg_CreateStringTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CreateStringTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_UpdateStringTable*
Arena::CreateMaybeMessage< ::CSVCMsg_UpdateStringTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_UpdateStringTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_VoiceData*
Arena::CreateMaybeMessage< ::CSVCMsg_VoiceData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_VoiceData >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketReliable*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketReliable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketReliable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FullFrameSplit*
Arena::CreateMaybeMessage< ::CSVCMsg_FullFrameSplit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FullFrameSplit >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HLTVStatus*
Arena::CreateMaybeMessage< ::CSVCMsg_HLTVStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HLTVStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ServerSteamID*
Arena::CreateMaybeMessage< ::CSVCMsg_ServerSteamID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ServerSteamID >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CmdKeyValues*
Arena::CreateMaybeMessage< ::CSVCMsg_CmdKeyValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CmdKeyValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_RconServerDetails*
Arena::CreateMaybeMessage< ::CSVCMsg_RconServerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_RconServerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgIPCAddress*
Arena::CreateMaybeMessage< ::CMsgIPCAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgIPCAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerPeer*
Arena::CreateMaybeMessage< ::CMsgServerPeer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerPeer >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PeerList*
Arena::CreateMaybeMessage< ::CSVCMsg_PeerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PeerList >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClearAllStringTables*
Arena::CreateMaybeMessage< ::CSVCMsg_ClearAllStringTables >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClearAllStringTables >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializerField_t_polymorphic_field_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializerField_t_polymorphic_field_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializerField_t_polymorphic_field_t >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializerField_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializerField_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializerField_t >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializer_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializer_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializer_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FlattenedSerializer*
Arena::CreateMaybeMessage< ::CSVCMsg_FlattenedSerializer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FlattenedSerializer >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_StopSound*
Arena::CreateMaybeMessage< ::CSVCMsg_StopSound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_StopSound >(arena);
}
template<> PROTOBUF_NOINLINE ::CBidirMsg_RebroadcastGameEvent*
Arena::CreateMaybeMessage< ::CBidirMsg_RebroadcastGameEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBidirMsg_RebroadcastGameEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CBidirMsg_RebroadcastSource*
Arena::CreateMaybeMessage< ::CBidirMsg_RebroadcastSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBidirMsg_RebroadcastSource >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats_Port*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats_Port >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats_Port >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats_Player*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HltvReplay*
Arena::CreateMaybeMessage< ::CSVCMsg_HltvReplay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HltvReplay >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_HltvReplay*
Arena::CreateMaybeMessage< ::CCLCMsg_HltvReplay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_HltvReplay >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Broadcast_Command*
Arena::CreateMaybeMessage< ::CSVCMsg_Broadcast_Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Broadcast_Command >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_HltvFixupOperatorTick*
Arena::CreateMaybeMessage< ::CCLCMsg_HltvFixupOperatorTick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_HltvFixupOperatorTick >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HltvFixupOperatorStatus*
Arena::CreateMaybeMessage< ::CSVCMsg_HltvFixupOperatorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HltvFixupOperatorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerUserCmd*
Arena::CreateMaybeMessage< ::CMsgServerUserCmd >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerUserCmd >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_UserCommands*
Arena::CreateMaybeMessage< ::CSVCMsg_UserCommands >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_UserCommands >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
