// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_gamenetworkingui.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "steamnetworkingsockets_messages.pb.h"
#include "steamdatagram_messages_sdr.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenetworkingui_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fgamenetworkingui_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fgamenetworkingui_2eproto;
class CGameNetworkingUI_AppSummary;
struct CGameNetworkingUI_AppSummaryDefaultTypeInternal;
extern CGameNetworkingUI_AppSummaryDefaultTypeInternal _CGameNetworkingUI_AppSummary_default_instance_;
class CGameNetworkingUI_ConnectionState;
struct CGameNetworkingUI_ConnectionStateDefaultTypeInternal;
extern CGameNetworkingUI_ConnectionStateDefaultTypeInternal _CGameNetworkingUI_ConnectionState_default_instance_;
class CGameNetworkingUI_ConnectionSummary;
struct CGameNetworkingUI_ConnectionSummaryDefaultTypeInternal;
extern CGameNetworkingUI_ConnectionSummaryDefaultTypeInternal _CGameNetworkingUI_ConnectionSummary_default_instance_;
class CGameNetworkingUI_GlobalState;
struct CGameNetworkingUI_GlobalStateDefaultTypeInternal;
extern CGameNetworkingUI_GlobalStateDefaultTypeInternal _CGameNetworkingUI_GlobalState_default_instance_;
class CGameNetworkingUI_Message;
struct CGameNetworkingUI_MessageDefaultTypeInternal;
extern CGameNetworkingUI_MessageDefaultTypeInternal _CGameNetworkingUI_Message_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CGameNetworkingUI_AppSummary* Arena::CreateMaybeMessage<::CGameNetworkingUI_AppSummary>(Arena*);
template<> ::CGameNetworkingUI_ConnectionState* Arena::CreateMaybeMessage<::CGameNetworkingUI_ConnectionState>(Arena*);
template<> ::CGameNetworkingUI_ConnectionSummary* Arena::CreateMaybeMessage<::CGameNetworkingUI_ConnectionSummary>(Arena*);
template<> ::CGameNetworkingUI_GlobalState* Arena::CreateMaybeMessage<::CGameNetworkingUI_GlobalState>(Arena*);
template<> ::CGameNetworkingUI_Message* Arena::CreateMaybeMessage<::CGameNetworkingUI_Message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CGameNetworkingUI_GlobalState :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_GlobalState) */ {
 public:
  inline CGameNetworkingUI_GlobalState() : CGameNetworkingUI_GlobalState(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_GlobalState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGameNetworkingUI_GlobalState(const CGameNetworkingUI_GlobalState& from);
  CGameNetworkingUI_GlobalState(CGameNetworkingUI_GlobalState&& from) noexcept
    : CGameNetworkingUI_GlobalState() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_GlobalState& operator=(const CGameNetworkingUI_GlobalState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_GlobalState& operator=(CGameNetworkingUI_GlobalState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_GlobalState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_GlobalState* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_GlobalState*>(
               &_CGameNetworkingUI_GlobalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CGameNetworkingUI_GlobalState& a, CGameNetworkingUI_GlobalState& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_GlobalState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_GlobalState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_GlobalState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_GlobalState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CGameNetworkingUI_GlobalState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CGameNetworkingUI_GlobalState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGameNetworkingUI_GlobalState";
  }
  protected:
  explicit CGameNetworkingUI_GlobalState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_GlobalState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};
// -------------------------------------------------------------------

class CGameNetworkingUI_ConnectionState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_ConnectionState) */ {
 public:
  inline CGameNetworkingUI_ConnectionState() : CGameNetworkingUI_ConnectionState(nullptr) {}
  ~CGameNetworkingUI_ConnectionState() override;
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_ConnectionState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGameNetworkingUI_ConnectionState(const CGameNetworkingUI_ConnectionState& from);
  CGameNetworkingUI_ConnectionState(CGameNetworkingUI_ConnectionState&& from) noexcept
    : CGameNetworkingUI_ConnectionState() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_ConnectionState& operator=(const CGameNetworkingUI_ConnectionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_ConnectionState& operator=(CGameNetworkingUI_ConnectionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_ConnectionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_ConnectionState* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_ConnectionState*>(
               &_CGameNetworkingUI_ConnectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CGameNetworkingUI_ConnectionState& a, CGameNetworkingUI_ConnectionState& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_ConnectionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_ConnectionState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_ConnectionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_ConnectionState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_ConnectionState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_ConnectionState& from) {
    CGameNetworkingUI_ConnectionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_ConnectionState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGameNetworkingUI_ConnectionState";
  }
  protected:
  explicit CGameNetworkingUI_ConnectionState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionKeyFieldNumber = 1,
    kIdentityLocalFieldNumber = 4,
    kIdentityRemoteFieldNumber = 5,
    kCloseMessageFieldNumber = 15,
    kStatusLocTokenFieldNumber = 16,
    kSdrpopidLocalFieldNumber = 21,
    kSdrpopidRemoteFieldNumber = 22,
    kAddressRemoteFieldNumber = 23,
    kP2PRoutingFieldNumber = 24,
    kE2EQualityLocalFieldNumber = 30,
    kE2EQualityRemoteFieldNumber = 31,
    kFrontQualityLocalFieldNumber = 40,
    kFrontQualityRemoteFieldNumber = 41,
    kAppidFieldNumber = 2,
    kConnectionIdLocalFieldNumber = 3,
    kConnectionStateFieldNumber = 10,
    kStartTimeFieldNumber = 12,
    kCloseTimeFieldNumber = 13,
    kCloseReasonFieldNumber = 14,
    kTransportKindFieldNumber = 20,
    kPingInteriorFieldNumber = 25,
    kPingRemoteFrontFieldNumber = 26,
    kPingDefaultInternetRouteFieldNumber = 27,
    kE2EQualityRemoteInstantaneousTimeFieldNumber = 32,
    kE2EQualityRemoteLifetimeTimeFieldNumber = 33,
    kFrontQualityRemoteInstantaneousTimeFieldNumber = 42,
    kFrontQualityRemoteLifetimeTimeFieldNumber = 43,
  };
  // optional string connection_key = 1;
  bool has_connection_key() const;
  private:
  bool _internal_has_connection_key() const;
  public:
  void clear_connection_key();
  const std::string& connection_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_key();
  PROTOBUF_NODISCARD std::string* release_connection_key();
  void set_allocated_connection_key(std::string* connection_key);
  private:
  const std::string& _internal_connection_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_key(const std::string& value);
  std::string* _internal_mutable_connection_key();
  public:

  // optional string identity_local = 4;
  bool has_identity_local() const;
  private:
  bool _internal_has_identity_local() const;
  public:
  void clear_identity_local();
  const std::string& identity_local() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_local(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_local();
  PROTOBUF_NODISCARD std::string* release_identity_local();
  void set_allocated_identity_local(std::string* identity_local);
  private:
  const std::string& _internal_identity_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_local(const std::string& value);
  std::string* _internal_mutable_identity_local();
  public:

  // optional string identity_remote = 5;
  bool has_identity_remote() const;
  private:
  bool _internal_has_identity_remote() const;
  public:
  void clear_identity_remote();
  const std::string& identity_remote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_remote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_remote();
  PROTOBUF_NODISCARD std::string* release_identity_remote();
  void set_allocated_identity_remote(std::string* identity_remote);
  private:
  const std::string& _internal_identity_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_remote(const std::string& value);
  std::string* _internal_mutable_identity_remote();
  public:

  // optional string close_message = 15;
  bool has_close_message() const;
  private:
  bool _internal_has_close_message() const;
  public:
  void clear_close_message();
  const std::string& close_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_close_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_close_message();
  PROTOBUF_NODISCARD std::string* release_close_message();
  void set_allocated_close_message(std::string* close_message);
  private:
  const std::string& _internal_close_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_close_message(const std::string& value);
  std::string* _internal_mutable_close_message();
  public:

  // optional string status_loc_token = 16;
  bool has_status_loc_token() const;
  private:
  bool _internal_has_status_loc_token() const;
  public:
  void clear_status_loc_token();
  const std::string& status_loc_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_loc_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_loc_token();
  PROTOBUF_NODISCARD std::string* release_status_loc_token();
  void set_allocated_status_loc_token(std::string* status_loc_token);
  private:
  const std::string& _internal_status_loc_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_loc_token(const std::string& value);
  std::string* _internal_mutable_status_loc_token();
  public:

  // optional string sdrpopid_local = 21;
  bool has_sdrpopid_local() const;
  private:
  bool _internal_has_sdrpopid_local() const;
  public:
  void clear_sdrpopid_local();
  const std::string& sdrpopid_local() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdrpopid_local(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdrpopid_local();
  PROTOBUF_NODISCARD std::string* release_sdrpopid_local();
  void set_allocated_sdrpopid_local(std::string* sdrpopid_local);
  private:
  const std::string& _internal_sdrpopid_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpopid_local(const std::string& value);
  std::string* _internal_mutable_sdrpopid_local();
  public:

  // optional string sdrpopid_remote = 22;
  bool has_sdrpopid_remote() const;
  private:
  bool _internal_has_sdrpopid_remote() const;
  public:
  void clear_sdrpopid_remote();
  const std::string& sdrpopid_remote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdrpopid_remote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdrpopid_remote();
  PROTOBUF_NODISCARD std::string* release_sdrpopid_remote();
  void set_allocated_sdrpopid_remote(std::string* sdrpopid_remote);
  private:
  const std::string& _internal_sdrpopid_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpopid_remote(const std::string& value);
  std::string* _internal_mutable_sdrpopid_remote();
  public:

  // optional string address_remote = 23;
  bool has_address_remote() const;
  private:
  bool _internal_has_address_remote() const;
  public:
  void clear_address_remote();
  const std::string& address_remote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address_remote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address_remote();
  PROTOBUF_NODISCARD std::string* release_address_remote();
  void set_allocated_address_remote(std::string* address_remote);
  private:
  const std::string& _internal_address_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address_remote(const std::string& value);
  std::string* _internal_mutable_address_remote();
  public:

  // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24;
  bool has_p2p_routing() const;
  private:
  bool _internal_has_p2p_routing() const;
  public:
  void clear_p2p_routing();
  const ::CMsgSteamDatagramP2PRoutingSummary& p2p_routing() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramP2PRoutingSummary* release_p2p_routing();
  ::CMsgSteamDatagramP2PRoutingSummary* mutable_p2p_routing();
  void set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* p2p_routing);
  private:
  const ::CMsgSteamDatagramP2PRoutingSummary& _internal_p2p_routing() const;
  ::CMsgSteamDatagramP2PRoutingSummary* _internal_mutable_p2p_routing();
  public:
  void unsafe_arena_set_allocated_p2p_routing(
      ::CMsgSteamDatagramP2PRoutingSummary* p2p_routing);
  ::CMsgSteamDatagramP2PRoutingSummary* unsafe_arena_release_p2p_routing();

  // optional .CMsgSteamDatagramConnectionQuality e2e_quality_local = 30;
  bool has_e2e_quality_local() const;
  private:
  bool _internal_has_e2e_quality_local() const;
  public:
  void clear_e2e_quality_local();
  const ::CMsgSteamDatagramConnectionQuality& e2e_quality_local() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_e2e_quality_local();
  ::CMsgSteamDatagramConnectionQuality* mutable_e2e_quality_local();
  void set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* e2e_quality_local);
  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_e2e_quality_local() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_e2e_quality_local();
  public:
  void unsafe_arena_set_allocated_e2e_quality_local(
      ::CMsgSteamDatagramConnectionQuality* e2e_quality_local);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_e2e_quality_local();

  // optional .CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31;
  bool has_e2e_quality_remote() const;
  private:
  bool _internal_has_e2e_quality_remote() const;
  public:
  void clear_e2e_quality_remote();
  const ::CMsgSteamDatagramConnectionQuality& e2e_quality_remote() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_e2e_quality_remote();
  ::CMsgSteamDatagramConnectionQuality* mutable_e2e_quality_remote();
  void set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* e2e_quality_remote);
  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_e2e_quality_remote() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_e2e_quality_remote();
  public:
  void unsafe_arena_set_allocated_e2e_quality_remote(
      ::CMsgSteamDatagramConnectionQuality* e2e_quality_remote);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_e2e_quality_remote();

  // optional .CMsgSteamDatagramConnectionQuality front_quality_local = 40;
  bool has_front_quality_local() const;
  private:
  bool _internal_has_front_quality_local() const;
  public:
  void clear_front_quality_local();
  const ::CMsgSteamDatagramConnectionQuality& front_quality_local() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_front_quality_local();
  ::CMsgSteamDatagramConnectionQuality* mutable_front_quality_local();
  void set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* front_quality_local);
  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_front_quality_local() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_front_quality_local();
  public:
  void unsafe_arena_set_allocated_front_quality_local(
      ::CMsgSteamDatagramConnectionQuality* front_quality_local);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_front_quality_local();

  // optional .CMsgSteamDatagramConnectionQuality front_quality_remote = 41;
  bool has_front_quality_remote() const;
  private:
  bool _internal_has_front_quality_remote() const;
  public:
  void clear_front_quality_remote();
  const ::CMsgSteamDatagramConnectionQuality& front_quality_remote() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_front_quality_remote();
  ::CMsgSteamDatagramConnectionQuality* mutable_front_quality_remote();
  void set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* front_quality_remote);
  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_front_quality_remote() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_front_quality_remote();
  public:
  void unsafe_arena_set_allocated_front_quality_remote(
      ::CMsgSteamDatagramConnectionQuality* front_quality_remote);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_front_quality_remote();

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional fixed32 connection_id_local = 3;
  bool has_connection_id_local() const;
  private:
  bool _internal_has_connection_id_local() const;
  public:
  void clear_connection_id_local();
  uint32_t connection_id_local() const;
  void set_connection_id_local(uint32_t value);
  private:
  uint32_t _internal_connection_id_local() const;
  void _internal_set_connection_id_local(uint32_t value);
  public:

  // optional uint32 connection_state = 10;
  bool has_connection_state() const;
  private:
  bool _internal_has_connection_state() const;
  public:
  void clear_connection_state();
  uint32_t connection_state() const;
  void set_connection_state(uint32_t value);
  private:
  uint32_t _internal_connection_state() const;
  void _internal_set_connection_state(uint32_t value);
  public:

  // optional uint32 start_time = 12;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint32_t start_time() const;
  void set_start_time(uint32_t value);
  private:
  uint32_t _internal_start_time() const;
  void _internal_set_start_time(uint32_t value);
  public:

  // optional uint32 close_time = 13;
  bool has_close_time() const;
  private:
  bool _internal_has_close_time() const;
  public:
  void clear_close_time();
  uint32_t close_time() const;
  void set_close_time(uint32_t value);
  private:
  uint32_t _internal_close_time() const;
  void _internal_set_close_time(uint32_t value);
  public:

  // optional uint32 close_reason = 14;
  bool has_close_reason() const;
  private:
  bool _internal_has_close_reason() const;
  public:
  void clear_close_reason();
  uint32_t close_reason() const;
  void set_close_reason(uint32_t value);
  private:
  uint32_t _internal_close_reason() const;
  void _internal_set_close_reason(uint32_t value);
  public:

  // optional uint32 transport_kind = 20;
  bool has_transport_kind() const;
  private:
  bool _internal_has_transport_kind() const;
  public:
  void clear_transport_kind();
  uint32_t transport_kind() const;
  void set_transport_kind(uint32_t value);
  private:
  uint32_t _internal_transport_kind() const;
  void _internal_set_transport_kind(uint32_t value);
  public:

  // optional uint32 ping_interior = 25;
  bool has_ping_interior() const;
  private:
  bool _internal_has_ping_interior() const;
  public:
  void clear_ping_interior();
  uint32_t ping_interior() const;
  void set_ping_interior(uint32_t value);
  private:
  uint32_t _internal_ping_interior() const;
  void _internal_set_ping_interior(uint32_t value);
  public:

  // optional uint32 ping_remote_front = 26;
  bool has_ping_remote_front() const;
  private:
  bool _internal_has_ping_remote_front() const;
  public:
  void clear_ping_remote_front();
  uint32_t ping_remote_front() const;
  void set_ping_remote_front(uint32_t value);
  private:
  uint32_t _internal_ping_remote_front() const;
  void _internal_set_ping_remote_front(uint32_t value);
  public:

  // optional uint32 ping_default_internet_route = 27;
  bool has_ping_default_internet_route() const;
  private:
  bool _internal_has_ping_default_internet_route() const;
  public:
  void clear_ping_default_internet_route();
  uint32_t ping_default_internet_route() const;
  void set_ping_default_internet_route(uint32_t value);
  private:
  uint32_t _internal_ping_default_internet_route() const;
  void _internal_set_ping_default_internet_route(uint32_t value);
  public:

  // optional uint64 e2e_quality_remote_instantaneous_time = 32;
  bool has_e2e_quality_remote_instantaneous_time() const;
  private:
  bool _internal_has_e2e_quality_remote_instantaneous_time() const;
  public:
  void clear_e2e_quality_remote_instantaneous_time();
  uint64_t e2e_quality_remote_instantaneous_time() const;
  void set_e2e_quality_remote_instantaneous_time(uint64_t value);
  private:
  uint64_t _internal_e2e_quality_remote_instantaneous_time() const;
  void _internal_set_e2e_quality_remote_instantaneous_time(uint64_t value);
  public:

  // optional uint64 e2e_quality_remote_lifetime_time = 33;
  bool has_e2e_quality_remote_lifetime_time() const;
  private:
  bool _internal_has_e2e_quality_remote_lifetime_time() const;
  public:
  void clear_e2e_quality_remote_lifetime_time();
  uint64_t e2e_quality_remote_lifetime_time() const;
  void set_e2e_quality_remote_lifetime_time(uint64_t value);
  private:
  uint64_t _internal_e2e_quality_remote_lifetime_time() const;
  void _internal_set_e2e_quality_remote_lifetime_time(uint64_t value);
  public:

  // optional uint64 front_quality_remote_instantaneous_time = 42;
  bool has_front_quality_remote_instantaneous_time() const;
  private:
  bool _internal_has_front_quality_remote_instantaneous_time() const;
  public:
  void clear_front_quality_remote_instantaneous_time();
  uint64_t front_quality_remote_instantaneous_time() const;
  void set_front_quality_remote_instantaneous_time(uint64_t value);
  private:
  uint64_t _internal_front_quality_remote_instantaneous_time() const;
  void _internal_set_front_quality_remote_instantaneous_time(uint64_t value);
  public:

  // optional uint64 front_quality_remote_lifetime_time = 43;
  bool has_front_quality_remote_lifetime_time() const;
  private:
  bool _internal_has_front_quality_remote_lifetime_time() const;
  public:
  void clear_front_quality_remote_lifetime_time();
  uint64_t front_quality_remote_lifetime_time() const;
  void set_front_quality_remote_lifetime_time(uint64_t value);
  private:
  uint64_t _internal_front_quality_remote_lifetime_time() const;
  void _internal_set_front_quality_remote_lifetime_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_ConnectionState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_local_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_remote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr close_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_loc_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdrpopid_local_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdrpopid_remote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_remote_;
    ::CMsgSteamDatagramP2PRoutingSummary* p2p_routing_;
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_local_;
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_remote_;
    ::CMsgSteamDatagramConnectionQuality* front_quality_local_;
    ::CMsgSteamDatagramConnectionQuality* front_quality_remote_;
    uint32_t appid_;
    uint32_t connection_id_local_;
    uint32_t connection_state_;
    uint32_t start_time_;
    uint32_t close_time_;
    uint32_t close_reason_;
    uint32_t transport_kind_;
    uint32_t ping_interior_;
    uint32_t ping_remote_front_;
    uint32_t ping_default_internet_route_;
    uint64_t e2e_quality_remote_instantaneous_time_;
    uint64_t e2e_quality_remote_lifetime_time_;
    uint64_t front_quality_remote_instantaneous_time_;
    uint64_t front_quality_remote_lifetime_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};
// -------------------------------------------------------------------

class CGameNetworkingUI_Message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_Message) */ {
 public:
  inline CGameNetworkingUI_Message() : CGameNetworkingUI_Message(nullptr) {}
  ~CGameNetworkingUI_Message() override;
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGameNetworkingUI_Message(const CGameNetworkingUI_Message& from);
  CGameNetworkingUI_Message(CGameNetworkingUI_Message&& from) noexcept
    : CGameNetworkingUI_Message() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_Message& operator=(const CGameNetworkingUI_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_Message& operator=(CGameNetworkingUI_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_Message* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_Message*>(
               &_CGameNetworkingUI_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CGameNetworkingUI_Message& a, CGameNetworkingUI_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_Message& from) {
    CGameNetworkingUI_Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGameNetworkingUI_Message";
  }
  protected:
  explicit CGameNetworkingUI_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionStateFieldNumber = 1,
  };
  // repeated .CGameNetworkingUI_ConnectionState connection_state = 1;
  int connection_state_size() const;
  private:
  int _internal_connection_state_size() const;
  public:
  void clear_connection_state();
  ::CGameNetworkingUI_ConnectionState* mutable_connection_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >*
      mutable_connection_state();
  private:
  const ::CGameNetworkingUI_ConnectionState& _internal_connection_state(int index) const;
  ::CGameNetworkingUI_ConnectionState* _internal_add_connection_state();
  public:
  const ::CGameNetworkingUI_ConnectionState& connection_state(int index) const;
  ::CGameNetworkingUI_ConnectionState* add_connection_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >&
      connection_state() const;

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState > connection_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};
// -------------------------------------------------------------------

class CGameNetworkingUI_ConnectionSummary :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_ConnectionSummary) */ {
 public:
  inline CGameNetworkingUI_ConnectionSummary() : CGameNetworkingUI_ConnectionSummary(nullptr) {}
  ~CGameNetworkingUI_ConnectionSummary() override;
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_ConnectionSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGameNetworkingUI_ConnectionSummary(const CGameNetworkingUI_ConnectionSummary& from);
  CGameNetworkingUI_ConnectionSummary(CGameNetworkingUI_ConnectionSummary&& from) noexcept
    : CGameNetworkingUI_ConnectionSummary() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_ConnectionSummary& operator=(const CGameNetworkingUI_ConnectionSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_ConnectionSummary& operator=(CGameNetworkingUI_ConnectionSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_ConnectionSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_ConnectionSummary* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_ConnectionSummary*>(
               &_CGameNetworkingUI_ConnectionSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CGameNetworkingUI_ConnectionSummary& a, CGameNetworkingUI_ConnectionSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_ConnectionSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_ConnectionSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_ConnectionSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_ConnectionSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_ConnectionSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_ConnectionSummary& from) {
    CGameNetworkingUI_ConnectionSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_ConnectionSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGameNetworkingUI_ConnectionSummary";
  }
  protected:
  explicit CGameNetworkingUI_ConnectionSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdrpopLocalFieldNumber = 2,
    kSdrpopRemoteFieldNumber = 3,
    kTransportKindFieldNumber = 1,
    kPingMsFieldNumber = 4,
    kPacketLossFieldNumber = 5,
    kPingDefaultInternetRouteFieldNumber = 6,
    kIpWasSharedFieldNumber = 7,
    kConnectionStateFieldNumber = 8,
  };
  // optional string sdrpop_local = 2;
  bool has_sdrpop_local() const;
  private:
  bool _internal_has_sdrpop_local() const;
  public:
  void clear_sdrpop_local();
  const std::string& sdrpop_local() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdrpop_local(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdrpop_local();
  PROTOBUF_NODISCARD std::string* release_sdrpop_local();
  void set_allocated_sdrpop_local(std::string* sdrpop_local);
  private:
  const std::string& _internal_sdrpop_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpop_local(const std::string& value);
  std::string* _internal_mutable_sdrpop_local();
  public:

  // optional string sdrpop_remote = 3;
  bool has_sdrpop_remote() const;
  private:
  bool _internal_has_sdrpop_remote() const;
  public:
  void clear_sdrpop_remote();
  const std::string& sdrpop_remote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdrpop_remote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdrpop_remote();
  PROTOBUF_NODISCARD std::string* release_sdrpop_remote();
  void set_allocated_sdrpop_remote(std::string* sdrpop_remote);
  private:
  const std::string& _internal_sdrpop_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpop_remote(const std::string& value);
  std::string* _internal_mutable_sdrpop_remote();
  public:

  // optional uint32 transport_kind = 1;
  bool has_transport_kind() const;
  private:
  bool _internal_has_transport_kind() const;
  public:
  void clear_transport_kind();
  uint32_t transport_kind() const;
  void set_transport_kind(uint32_t value);
  private:
  uint32_t _internal_transport_kind() const;
  void _internal_set_transport_kind(uint32_t value);
  public:

  // optional uint32 ping_ms = 4;
  bool has_ping_ms() const;
  private:
  bool _internal_has_ping_ms() const;
  public:
  void clear_ping_ms();
  uint32_t ping_ms() const;
  void set_ping_ms(uint32_t value);
  private:
  uint32_t _internal_ping_ms() const;
  void _internal_set_ping_ms(uint32_t value);
  public:

  // optional float packet_loss = 5;
  bool has_packet_loss() const;
  private:
  bool _internal_has_packet_loss() const;
  public:
  void clear_packet_loss();
  float packet_loss() const;
  void set_packet_loss(float value);
  private:
  float _internal_packet_loss() const;
  void _internal_set_packet_loss(float value);
  public:

  // optional uint32 ping_default_internet_route = 6;
  bool has_ping_default_internet_route() const;
  private:
  bool _internal_has_ping_default_internet_route() const;
  public:
  void clear_ping_default_internet_route();
  uint32_t ping_default_internet_route() const;
  void set_ping_default_internet_route(uint32_t value);
  private:
  uint32_t _internal_ping_default_internet_route() const;
  void _internal_set_ping_default_internet_route(uint32_t value);
  public:

  // optional bool ip_was_shared = 7;
  bool has_ip_was_shared() const;
  private:
  bool _internal_has_ip_was_shared() const;
  public:
  void clear_ip_was_shared();
  bool ip_was_shared() const;
  void set_ip_was_shared(bool value);
  private:
  bool _internal_ip_was_shared() const;
  void _internal_set_ip_was_shared(bool value);
  public:

  // optional uint32 connection_state = 8;
  bool has_connection_state() const;
  private:
  bool _internal_has_connection_state() const;
  public:
  void clear_connection_state();
  uint32_t connection_state() const;
  void set_connection_state(uint32_t value);
  private:
  uint32_t _internal_connection_state() const;
  void _internal_set_connection_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_ConnectionSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdrpop_local_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdrpop_remote_;
    uint32_t transport_kind_;
    uint32_t ping_ms_;
    float packet_loss_;
    uint32_t ping_default_internet_route_;
    bool ip_was_shared_;
    uint32_t connection_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};
// -------------------------------------------------------------------

class CGameNetworkingUI_AppSummary :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_AppSummary) */ {
 public:
  inline CGameNetworkingUI_AppSummary() : CGameNetworkingUI_AppSummary(nullptr) {}
  ~CGameNetworkingUI_AppSummary() override;
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_AppSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGameNetworkingUI_AppSummary(const CGameNetworkingUI_AppSummary& from);
  CGameNetworkingUI_AppSummary(CGameNetworkingUI_AppSummary&& from) noexcept
    : CGameNetworkingUI_AppSummary() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_AppSummary& operator=(const CGameNetworkingUI_AppSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_AppSummary& operator=(CGameNetworkingUI_AppSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_AppSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_AppSummary* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_AppSummary*>(
               &_CGameNetworkingUI_AppSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CGameNetworkingUI_AppSummary& a, CGameNetworkingUI_AppSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_AppSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_AppSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_AppSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_AppSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_AppSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_AppSummary& from) {
    CGameNetworkingUI_AppSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_AppSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGameNetworkingUI_AppSummary";
  }
  protected:
  explicit CGameNetworkingUI_AppSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMainCxnFieldNumber = 30,
    kAppidFieldNumber = 1,
    kIpWasSharedWithFriendFieldNumber = 10,
    kIpWasSharedWithNonfriendFieldNumber = 11,
    kActiveConnectionsFieldNumber = 20,
  };
  // optional .CGameNetworkingUI_ConnectionSummary main_cxn = 30;
  bool has_main_cxn() const;
  private:
  bool _internal_has_main_cxn() const;
  public:
  void clear_main_cxn();
  const ::CGameNetworkingUI_ConnectionSummary& main_cxn() const;
  PROTOBUF_NODISCARD ::CGameNetworkingUI_ConnectionSummary* release_main_cxn();
  ::CGameNetworkingUI_ConnectionSummary* mutable_main_cxn();
  void set_allocated_main_cxn(::CGameNetworkingUI_ConnectionSummary* main_cxn);
  private:
  const ::CGameNetworkingUI_ConnectionSummary& _internal_main_cxn() const;
  ::CGameNetworkingUI_ConnectionSummary* _internal_mutable_main_cxn();
  public:
  void unsafe_arena_set_allocated_main_cxn(
      ::CGameNetworkingUI_ConnectionSummary* main_cxn);
  ::CGameNetworkingUI_ConnectionSummary* unsafe_arena_release_main_cxn();

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional bool ip_was_shared_with_friend = 10;
  bool has_ip_was_shared_with_friend() const;
  private:
  bool _internal_has_ip_was_shared_with_friend() const;
  public:
  void clear_ip_was_shared_with_friend();
  bool ip_was_shared_with_friend() const;
  void set_ip_was_shared_with_friend(bool value);
  private:
  bool _internal_ip_was_shared_with_friend() const;
  void _internal_set_ip_was_shared_with_friend(bool value);
  public:

  // optional bool ip_was_shared_with_nonfriend = 11;
  bool has_ip_was_shared_with_nonfriend() const;
  private:
  bool _internal_has_ip_was_shared_with_nonfriend() const;
  public:
  void clear_ip_was_shared_with_nonfriend();
  bool ip_was_shared_with_nonfriend() const;
  void set_ip_was_shared_with_nonfriend(bool value);
  private:
  bool _internal_ip_was_shared_with_nonfriend() const;
  void _internal_set_ip_was_shared_with_nonfriend(bool value);
  public:

  // optional uint32 active_connections = 20;
  bool has_active_connections() const;
  private:
  bool _internal_has_active_connections() const;
  public:
  void clear_active_connections();
  uint32_t active_connections() const;
  void set_active_connections(uint32_t value);
  private:
  uint32_t _internal_active_connections() const;
  void _internal_set_active_connections(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_AppSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CGameNetworkingUI_ConnectionSummary* main_cxn_;
    uint32_t appid_;
    bool ip_was_shared_with_friend_;
    bool ip_was_shared_with_nonfriend_;
    uint32_t active_connections_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CGameNetworkingUI_GlobalState

// -------------------------------------------------------------------

// CGameNetworkingUI_ConnectionState

// optional string connection_key = 1;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_connection_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_connection_key() const {
  return _internal_has_connection_key();
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_key() {
  _impl_.connection_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::connection_key() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_key)
  return _internal_connection_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_connection_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.connection_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_key)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_connection_key() {
  std::string* _s = _internal_mutable_connection_key();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.connection_key)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_connection_key() const {
  return _impl_.connection_key_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.connection_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_connection_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.connection_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_connection_key() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.connection_key)
  if (!_internal_has_connection_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.connection_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_key_.IsDefault()) {
    _impl_.connection_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_connection_key(std::string* connection_key) {
  if (connection_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.connection_key_.SetAllocated(connection_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_key_.IsDefault()) {
    _impl_.connection_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.connection_key)
}

// optional uint32 appid = 2;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_appid() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_appid() const {
  return _internal_has_appid();
}
inline void CGameNetworkingUI_ConnectionState::clear_appid() {
  _impl_.appid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::appid() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.appid)
  return _internal_appid();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_appid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.appid_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.appid)
}

// optional fixed32 connection_id_local = 3;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_connection_id_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_connection_id_local() const {
  return _internal_has_connection_id_local();
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_id_local() {
  _impl_.connection_id_local_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_connection_id_local() const {
  return _impl_.connection_id_local_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::connection_id_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_id_local)
  return _internal_connection_id_local();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_id_local(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.connection_id_local_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_connection_id_local(uint32_t value) {
  _internal_set_connection_id_local(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_id_local)
}

// optional string identity_local = 4;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_identity_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_identity_local() const {
  return _internal_has_identity_local();
}
inline void CGameNetworkingUI_ConnectionState::clear_identity_local() {
  _impl_.identity_local_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::identity_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.identity_local)
  return _internal_identity_local();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_identity_local(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.identity_local_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.identity_local)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_identity_local() {
  std::string* _s = _internal_mutable_identity_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.identity_local)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_identity_local() const {
  return _impl_.identity_local_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_identity_local(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.identity_local_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_identity_local() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.identity_local_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_identity_local() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.identity_local)
  if (!_internal_has_identity_local()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.identity_local_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_local_.IsDefault()) {
    _impl_.identity_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_identity_local(std::string* identity_local) {
  if (identity_local != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.identity_local_.SetAllocated(identity_local, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_local_.IsDefault()) {
    _impl_.identity_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.identity_local)
}

// optional string identity_remote = 5;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_identity_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_identity_remote() const {
  return _internal_has_identity_remote();
}
inline void CGameNetworkingUI_ConnectionState::clear_identity_remote() {
  _impl_.identity_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::identity_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.identity_remote)
  return _internal_identity_remote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_identity_remote(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.identity_remote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.identity_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_identity_remote() {
  std::string* _s = _internal_mutable_identity_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.identity_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_identity_remote() const {
  return _impl_.identity_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_identity_remote(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.identity_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_identity_remote() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.identity_remote_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_identity_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.identity_remote)
  if (!_internal_has_identity_remote()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.identity_remote_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_remote_.IsDefault()) {
    _impl_.identity_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_identity_remote(std::string* identity_remote) {
  if (identity_remote != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.identity_remote_.SetAllocated(identity_remote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_remote_.IsDefault()) {
    _impl_.identity_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.identity_remote)
}

// optional uint32 connection_state = 10;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_connection_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_connection_state() const {
  return _internal_has_connection_state();
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_state() {
  _impl_.connection_state_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_connection_state() const {
  return _impl_.connection_state_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::connection_state() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_state)
  return _internal_connection_state();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_state(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.connection_state_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_connection_state(uint32_t value) {
  _internal_set_connection_state(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_state)
}

// optional uint32 start_time = 12;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_start_time() const {
  return _internal_has_start_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_start_time() {
  _impl_.start_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::start_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.start_time)
  return _internal_start_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_start_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.start_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_start_time(uint32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.start_time)
}

// optional uint32 close_time = 13;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_close_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_close_time() const {
  return _internal_has_close_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_close_time() {
  _impl_.close_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_close_time() const {
  return _impl_.close_time_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::close_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_time)
  return _internal_close_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.close_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_close_time(uint32_t value) {
  _internal_set_close_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_time)
}

// optional uint32 close_reason = 14;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_close_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_close_reason() const {
  return _internal_has_close_reason();
}
inline void CGameNetworkingUI_ConnectionState::clear_close_reason() {
  _impl_.close_reason_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_close_reason() const {
  return _impl_.close_reason_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::close_reason() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_reason)
  return _internal_close_reason();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_reason(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.close_reason_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_close_reason(uint32_t value) {
  _internal_set_close_reason(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_reason)
}

// optional string close_message = 15;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_close_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_close_message() const {
  return _internal_has_close_message();
}
inline void CGameNetworkingUI_ConnectionState::clear_close_message() {
  _impl_.close_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::close_message() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_message)
  return _internal_close_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_close_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.close_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_message)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_close_message() {
  std::string* _s = _internal_mutable_close_message();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.close_message)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_close_message() const {
  return _impl_.close_message_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.close_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_close_message() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.close_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_close_message() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.close_message)
  if (!_internal_has_close_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.close_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.close_message_.IsDefault()) {
    _impl_.close_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_close_message(std::string* close_message) {
  if (close_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.close_message_.SetAllocated(close_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.close_message_.IsDefault()) {
    _impl_.close_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.close_message)
}

// optional string status_loc_token = 16;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_status_loc_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_status_loc_token() const {
  return _internal_has_status_loc_token();
}
inline void CGameNetworkingUI_ConnectionState::clear_status_loc_token() {
  _impl_.status_loc_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::status_loc_token() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.status_loc_token)
  return _internal_status_loc_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_status_loc_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.status_loc_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.status_loc_token)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_status_loc_token() {
  std::string* _s = _internal_mutable_status_loc_token();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.status_loc_token)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_status_loc_token() const {
  return _impl_.status_loc_token_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_status_loc_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_loc_token_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_status_loc_token() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.status_loc_token_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_status_loc_token() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.status_loc_token)
  if (!_internal_has_status_loc_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.status_loc_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_loc_token_.IsDefault()) {
    _impl_.status_loc_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_status_loc_token(std::string* status_loc_token) {
  if (status_loc_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.status_loc_token_.SetAllocated(status_loc_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_loc_token_.IsDefault()) {
    _impl_.status_loc_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.status_loc_token)
}

// optional uint32 transport_kind = 20;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_transport_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_transport_kind() const {
  return _internal_has_transport_kind();
}
inline void CGameNetworkingUI_ConnectionState::clear_transport_kind() {
  _impl_.transport_kind_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_transport_kind() const {
  return _impl_.transport_kind_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::transport_kind() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.transport_kind)
  return _internal_transport_kind();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_transport_kind(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.transport_kind_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_transport_kind(uint32_t value) {
  _internal_set_transport_kind(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.transport_kind)
}

// optional string sdrpopid_local = 21;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_sdrpopid_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_sdrpopid_local() const {
  return _internal_has_sdrpopid_local();
}
inline void CGameNetworkingUI_ConnectionState::clear_sdrpopid_local() {
  _impl_.sdrpopid_local_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::sdrpopid_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  return _internal_sdrpopid_local();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_sdrpopid_local(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.sdrpopid_local_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.sdrpopid_local)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_sdrpopid_local() {
  std::string* _s = _internal_mutable_sdrpopid_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_sdrpopid_local() const {
  return _impl_.sdrpopid_local_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_sdrpopid_local(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sdrpopid_local_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_sdrpopid_local() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sdrpopid_local_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_sdrpopid_local() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  if (!_internal_has_sdrpopid_local()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.sdrpopid_local_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpopid_local_.IsDefault()) {
    _impl_.sdrpopid_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_sdrpopid_local(std::string* sdrpopid_local) {
  if (sdrpopid_local != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sdrpopid_local_.SetAllocated(sdrpopid_local, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpopid_local_.IsDefault()) {
    _impl_.sdrpopid_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.sdrpopid_local)
}

// optional string sdrpopid_remote = 22;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_sdrpopid_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_sdrpopid_remote() const {
  return _internal_has_sdrpopid_remote();
}
inline void CGameNetworkingUI_ConnectionState::clear_sdrpopid_remote() {
  _impl_.sdrpopid_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::sdrpopid_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  return _internal_sdrpopid_remote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_sdrpopid_remote(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.sdrpopid_remote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_sdrpopid_remote() {
  std::string* _s = _internal_mutable_sdrpopid_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_sdrpopid_remote() const {
  return _impl_.sdrpopid_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_sdrpopid_remote(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sdrpopid_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_sdrpopid_remote() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.sdrpopid_remote_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_sdrpopid_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  if (!_internal_has_sdrpopid_remote()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.sdrpopid_remote_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpopid_remote_.IsDefault()) {
    _impl_.sdrpopid_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_sdrpopid_remote(std::string* sdrpopid_remote) {
  if (sdrpopid_remote != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.sdrpopid_remote_.SetAllocated(sdrpopid_remote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpopid_remote_.IsDefault()) {
    _impl_.sdrpopid_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
}

// optional string address_remote = 23;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_address_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_address_remote() const {
  return _internal_has_address_remote();
}
inline void CGameNetworkingUI_ConnectionState::clear_address_remote() {
  _impl_.address_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::address_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.address_remote)
  return _internal_address_remote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionState::set_address_remote(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.address_remote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.address_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_address_remote() {
  std::string* _s = _internal_mutable_address_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.address_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_address_remote() const {
  return _impl_.address_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_address_remote(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.address_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_address_remote() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.address_remote_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_address_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.address_remote)
  if (!_internal_has_address_remote()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.address_remote_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_remote_.IsDefault()) {
    _impl_.address_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_address_remote(std::string* address_remote) {
  if (address_remote != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.address_remote_.SetAllocated(address_remote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_remote_.IsDefault()) {
    _impl_.address_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.address_remote)
}

// optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_p2p_routing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.p2p_routing_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_p2p_routing() const {
  return _internal_has_p2p_routing();
}
inline const ::CMsgSteamDatagramP2PRoutingSummary& CGameNetworkingUI_ConnectionState::_internal_p2p_routing() const {
  const ::CMsgSteamDatagramP2PRoutingSummary* p = _impl_.p2p_routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramP2PRoutingSummary&>(
      ::_CMsgSteamDatagramP2PRoutingSummary_default_instance_);
}
inline const ::CMsgSteamDatagramP2PRoutingSummary& CGameNetworkingUI_ConnectionState::p2p_routing() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.p2p_routing)
  return _internal_p2p_routing();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_p2p_routing(
    ::CMsgSteamDatagramP2PRoutingSummary* p2p_routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p2p_routing_);
  }
  _impl_.p2p_routing_ = p2p_routing;
  if (p2p_routing) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.p2p_routing)
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::release_p2p_routing() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgSteamDatagramP2PRoutingSummary* temp = _impl_.p2p_routing_;
  _impl_.p2p_routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::unsafe_arena_release_p2p_routing() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.p2p_routing)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgSteamDatagramP2PRoutingSummary* temp = _impl_.p2p_routing_;
  _impl_.p2p_routing_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::_internal_mutable_p2p_routing() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.p2p_routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramP2PRoutingSummary>(GetArenaForAllocation());
    _impl_.p2p_routing_ = p;
  }
  return _impl_.p2p_routing_;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::mutable_p2p_routing() {
  ::CMsgSteamDatagramP2PRoutingSummary* _msg = _internal_mutable_p2p_routing();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.p2p_routing)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* p2p_routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p2p_routing_);
  }
  if (p2p_routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p2p_routing));
    if (message_arena != submessage_arena) {
      p2p_routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p2p_routing, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.p2p_routing_ = p2p_routing;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.p2p_routing)
}

// optional uint32 ping_interior = 25;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_ping_interior() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_ping_interior() const {
  return _internal_has_ping_interior();
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_interior() {
  _impl_.ping_interior_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_interior() const {
  return _impl_.ping_interior_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::ping_interior() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_interior)
  return _internal_ping_interior();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_interior(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.ping_interior_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_ping_interior(uint32_t value) {
  _internal_set_ping_interior(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_interior)
}

// optional uint32 ping_remote_front = 26;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_ping_remote_front() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_ping_remote_front() const {
  return _internal_has_ping_remote_front();
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_remote_front() {
  _impl_.ping_remote_front_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_remote_front() const {
  return _impl_.ping_remote_front_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::ping_remote_front() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_remote_front)
  return _internal_ping_remote_front();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_remote_front(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.ping_remote_front_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_ping_remote_front(uint32_t value) {
  _internal_set_ping_remote_front(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_remote_front)
}

// optional uint32 ping_default_internet_route = 27;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_ping_default_internet_route() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_ping_default_internet_route() const {
  return _internal_has_ping_default_internet_route();
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_default_internet_route() {
  _impl_.ping_default_internet_route_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_default_internet_route() const {
  return _impl_.ping_default_internet_route_;
}
inline uint32_t CGameNetworkingUI_ConnectionState::ping_default_internet_route() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
  return _internal_ping_default_internet_route();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_default_internet_route(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.ping_default_internet_route_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_ping_default_internet_route(uint32_t value) {
  _internal_set_ping_default_internet_route(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
}

// optional .CMsgSteamDatagramConnectionQuality e2e_quality_local = 30;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_e2e_quality_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e2e_quality_local_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_local() const {
  return _internal_has_e2e_quality_local();
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_e2e_quality_local() const {
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.e2e_quality_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(
      ::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::e2e_quality_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_local)
  return _internal_e2e_quality_local();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_e2e_quality_local(
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2e_quality_local_);
  }
  _impl_.e2e_quality_local_ = e2e_quality_local;
  if (e2e_quality_local) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_local)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_e2e_quality_local() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_local_;
  _impl_.e2e_quality_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_e2e_quality_local() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.e2e_quality_local)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_local_;
  _impl_.e2e_quality_local_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_e2e_quality_local() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.e2e_quality_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.e2e_quality_local_ = p;
  }
  return _impl_.e2e_quality_local_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_e2e_quality_local() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_e2e_quality_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.e2e_quality_local)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* e2e_quality_local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2e_quality_local_);
  }
  if (e2e_quality_local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(e2e_quality_local));
    if (message_arena != submessage_arena) {
      e2e_quality_local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, e2e_quality_local, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.e2e_quality_local_ = e2e_quality_local;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_local)
}

// optional .CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_e2e_quality_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e2e_quality_remote_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote() const {
  return _internal_has_e2e_quality_remote();
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote() const {
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.e2e_quality_remote_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(
      ::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::e2e_quality_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
  return _internal_e2e_quality_remote();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_e2e_quality_remote(
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_remote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2e_quality_remote_);
  }
  _impl_.e2e_quality_remote_ = e2e_quality_remote;
  if (e2e_quality_remote) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_e2e_quality_remote() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_remote_;
  _impl_.e2e_quality_remote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_e2e_quality_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_remote_;
  _impl_.e2e_quality_remote_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_e2e_quality_remote() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.e2e_quality_remote_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.e2e_quality_remote_ = p;
  }
  return _impl_.e2e_quality_remote_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_e2e_quality_remote() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_e2e_quality_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* e2e_quality_remote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2e_quality_remote_);
  }
  if (e2e_quality_remote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(e2e_quality_remote));
    if (message_arena != submessage_arena) {
      e2e_quality_remote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, e2e_quality_remote, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.e2e_quality_remote_ = e2e_quality_remote;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
}

// optional uint64 e2e_quality_remote_instantaneous_time = 32;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_e2e_quality_remote_instantaneous_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote_instantaneous_time() const {
  return _internal_has_e2e_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_e2e_quality_remote_instantaneous_time() {
  _impl_.e2e_quality_remote_instantaneous_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint64_t CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote_instantaneous_time() const {
  return _impl_.e2e_quality_remote_instantaneous_time_;
}
inline uint64_t CGameNetworkingUI_ConnectionState::e2e_quality_remote_instantaneous_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
  return _internal_e2e_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_e2e_quality_remote_instantaneous_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.e2e_quality_remote_instantaneous_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_e2e_quality_remote_instantaneous_time(uint64_t value) {
  _internal_set_e2e_quality_remote_instantaneous_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
}

// optional uint64 e2e_quality_remote_lifetime_time = 33;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_e2e_quality_remote_lifetime_time() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote_lifetime_time() const {
  return _internal_has_e2e_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_e2e_quality_remote_lifetime_time() {
  _impl_.e2e_quality_remote_lifetime_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint64_t CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote_lifetime_time() const {
  return _impl_.e2e_quality_remote_lifetime_time_;
}
inline uint64_t CGameNetworkingUI_ConnectionState::e2e_quality_remote_lifetime_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
  return _internal_e2e_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_e2e_quality_remote_lifetime_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.e2e_quality_remote_lifetime_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_e2e_quality_remote_lifetime_time(uint64_t value) {
  _internal_set_e2e_quality_remote_lifetime_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
}

// optional .CMsgSteamDatagramConnectionQuality front_quality_local = 40;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_front_quality_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front_quality_local_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_local() const {
  return _internal_has_front_quality_local();
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_front_quality_local() const {
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.front_quality_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(
      ::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::front_quality_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_local)
  return _internal_front_quality_local();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_front_quality_local(
    ::CMsgSteamDatagramConnectionQuality* front_quality_local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front_quality_local_);
  }
  _impl_.front_quality_local_ = front_quality_local;
  if (front_quality_local) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_local)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_front_quality_local() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_local_;
  _impl_.front_quality_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_front_quality_local() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.front_quality_local)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_local_;
  _impl_.front_quality_local_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_front_quality_local() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.front_quality_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.front_quality_local_ = p;
  }
  return _impl_.front_quality_local_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_front_quality_local() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_front_quality_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.front_quality_local)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* front_quality_local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front_quality_local_);
  }
  if (front_quality_local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_quality_local));
    if (message_arena != submessage_arena) {
      front_quality_local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_quality_local, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.front_quality_local_ = front_quality_local;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_local)
}

// optional .CMsgSteamDatagramConnectionQuality front_quality_remote = 41;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_front_quality_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front_quality_remote_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote() const {
  return _internal_has_front_quality_remote();
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_front_quality_remote() const {
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.front_quality_remote_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(
      ::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::front_quality_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote)
  return _internal_front_quality_remote();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_front_quality_remote(
    ::CMsgSteamDatagramConnectionQuality* front_quality_remote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front_quality_remote_);
  }
  _impl_.front_quality_remote_ = front_quality_remote;
  if (front_quality_remote) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_remote)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_front_quality_remote() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_remote_;
  _impl_.front_quality_remote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_front_quality_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.front_quality_remote)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_remote_;
  _impl_.front_quality_remote_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_front_quality_remote() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.front_quality_remote_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.front_quality_remote_ = p;
  }
  return _impl_.front_quality_remote_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_front_quality_remote() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_front_quality_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.front_quality_remote)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* front_quality_remote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front_quality_remote_);
  }
  if (front_quality_remote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_quality_remote));
    if (message_arena != submessage_arena) {
      front_quality_remote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_quality_remote, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.front_quality_remote_ = front_quality_remote;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_remote)
}

// optional uint64 front_quality_remote_instantaneous_time = 42;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_front_quality_remote_instantaneous_time() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote_instantaneous_time() const {
  return _internal_has_front_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_front_quality_remote_instantaneous_time() {
  _impl_.front_quality_remote_instantaneous_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint64_t CGameNetworkingUI_ConnectionState::_internal_front_quality_remote_instantaneous_time() const {
  return _impl_.front_quality_remote_instantaneous_time_;
}
inline uint64_t CGameNetworkingUI_ConnectionState::front_quality_remote_instantaneous_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
  return _internal_front_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_front_quality_remote_instantaneous_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.front_quality_remote_instantaneous_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_front_quality_remote_instantaneous_time(uint64_t value) {
  _internal_set_front_quality_remote_instantaneous_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
}

// optional uint64 front_quality_remote_lifetime_time = 43;
inline bool CGameNetworkingUI_ConnectionState::_internal_has_front_quality_remote_lifetime_time() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote_lifetime_time() const {
  return _internal_has_front_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::clear_front_quality_remote_lifetime_time() {
  _impl_.front_quality_remote_lifetime_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline uint64_t CGameNetworkingUI_ConnectionState::_internal_front_quality_remote_lifetime_time() const {
  return _impl_.front_quality_remote_lifetime_time_;
}
inline uint64_t CGameNetworkingUI_ConnectionState::front_quality_remote_lifetime_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
  return _internal_front_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_front_quality_remote_lifetime_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.front_quality_remote_lifetime_time_ = value;
}
inline void CGameNetworkingUI_ConnectionState::set_front_quality_remote_lifetime_time(uint64_t value) {
  _internal_set_front_quality_remote_lifetime_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
}

// -------------------------------------------------------------------

// CGameNetworkingUI_Message

// repeated .CGameNetworkingUI_ConnectionState connection_state = 1;
inline int CGameNetworkingUI_Message::_internal_connection_state_size() const {
  return _impl_.connection_state_.size();
}
inline int CGameNetworkingUI_Message::connection_state_size() const {
  return _internal_connection_state_size();
}
inline void CGameNetworkingUI_Message::clear_connection_state() {
  _impl_.connection_state_.Clear();
}
inline ::CGameNetworkingUI_ConnectionState* CGameNetworkingUI_Message::mutable_connection_state(int index) {
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_Message.connection_state)
  return _impl_.connection_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >*
CGameNetworkingUI_Message::mutable_connection_state() {
  // @@protoc_insertion_point(field_mutable_list:CGameNetworkingUI_Message.connection_state)
  return &_impl_.connection_state_;
}
inline const ::CGameNetworkingUI_ConnectionState& CGameNetworkingUI_Message::_internal_connection_state(int index) const {
  return _impl_.connection_state_.Get(index);
}
inline const ::CGameNetworkingUI_ConnectionState& CGameNetworkingUI_Message::connection_state(int index) const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_Message.connection_state)
  return _internal_connection_state(index);
}
inline ::CGameNetworkingUI_ConnectionState* CGameNetworkingUI_Message::_internal_add_connection_state() {
  return _impl_.connection_state_.Add();
}
inline ::CGameNetworkingUI_ConnectionState* CGameNetworkingUI_Message::add_connection_state() {
  ::CGameNetworkingUI_ConnectionState* _add = _internal_add_connection_state();
  // @@protoc_insertion_point(field_add:CGameNetworkingUI_Message.connection_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >&
CGameNetworkingUI_Message::connection_state() const {
  // @@protoc_insertion_point(field_list:CGameNetworkingUI_Message.connection_state)
  return _impl_.connection_state_;
}

// -------------------------------------------------------------------

// CGameNetworkingUI_ConnectionSummary

// optional uint32 transport_kind = 1;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_transport_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_transport_kind() const {
  return _internal_has_transport_kind();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_transport_kind() {
  _impl_.transport_kind_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::_internal_transport_kind() const {
  return _impl_.transport_kind_;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::transport_kind() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.transport_kind)
  return _internal_transport_kind();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_transport_kind(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transport_kind_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_transport_kind(uint32_t value) {
  _internal_set_transport_kind(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.transport_kind)
}

// optional uint32 connection_state = 8;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_connection_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_connection_state() const {
  return _internal_has_connection_state();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_connection_state() {
  _impl_.connection_state_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::_internal_connection_state() const {
  return _impl_.connection_state_;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::connection_state() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.connection_state)
  return _internal_connection_state();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_connection_state(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.connection_state_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_connection_state(uint32_t value) {
  _internal_set_connection_state(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.connection_state)
}

// optional string sdrpop_local = 2;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_sdrpop_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_sdrpop_local() const {
  return _internal_has_sdrpop_local();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_sdrpop_local() {
  _impl_.sdrpop_local_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CGameNetworkingUI_ConnectionSummary::sdrpop_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
  return _internal_sdrpop_local();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionSummary::set_sdrpop_local(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sdrpop_local_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
}
inline std::string* CGameNetworkingUI_ConnectionSummary::mutable_sdrpop_local() {
  std::string* _s = _internal_mutable_sdrpop_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionSummary::_internal_sdrpop_local() const {
  return _impl_.sdrpop_local_.Get();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_sdrpop_local(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sdrpop_local_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionSummary::_internal_mutable_sdrpop_local() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sdrpop_local_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionSummary::release_sdrpop_local() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
  if (!_internal_has_sdrpop_local()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sdrpop_local_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpop_local_.IsDefault()) {
    _impl_.sdrpop_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionSummary::set_allocated_sdrpop_local(std::string* sdrpop_local) {
  if (sdrpop_local != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sdrpop_local_.SetAllocated(sdrpop_local, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpop_local_.IsDefault()) {
    _impl_.sdrpop_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
}

// optional string sdrpop_remote = 3;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_sdrpop_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_sdrpop_remote() const {
  return _internal_has_sdrpop_remote();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_sdrpop_remote() {
  _impl_.sdrpop_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CGameNetworkingUI_ConnectionSummary::sdrpop_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
  return _internal_sdrpop_remote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGameNetworkingUI_ConnectionSummary::set_sdrpop_remote(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sdrpop_remote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
}
inline std::string* CGameNetworkingUI_ConnectionSummary::mutable_sdrpop_remote() {
  std::string* _s = _internal_mutable_sdrpop_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionSummary::_internal_sdrpop_remote() const {
  return _impl_.sdrpop_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_sdrpop_remote(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sdrpop_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionSummary::_internal_mutable_sdrpop_remote() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sdrpop_remote_.Mutable(GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionSummary::release_sdrpop_remote() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
  if (!_internal_has_sdrpop_remote()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sdrpop_remote_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpop_remote_.IsDefault()) {
    _impl_.sdrpop_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGameNetworkingUI_ConnectionSummary::set_allocated_sdrpop_remote(std::string* sdrpop_remote) {
  if (sdrpop_remote != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sdrpop_remote_.SetAllocated(sdrpop_remote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdrpop_remote_.IsDefault()) {
    _impl_.sdrpop_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
}

// optional uint32 ping_ms = 4;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_ping_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_ping_ms() const {
  return _internal_has_ping_ms();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_ping_ms() {
  _impl_.ping_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::_internal_ping_ms() const {
  return _impl_.ping_ms_;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::ping_ms() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.ping_ms)
  return _internal_ping_ms();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_ping_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ping_ms_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_ping_ms(uint32_t value) {
  _internal_set_ping_ms(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.ping_ms)
}

// optional float packet_loss = 5;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_packet_loss() const {
  return _internal_has_packet_loss();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_packet_loss() {
  _impl_.packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CGameNetworkingUI_ConnectionSummary::_internal_packet_loss() const {
  return _impl_.packet_loss_;
}
inline float CGameNetworkingUI_ConnectionSummary::packet_loss() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.packet_loss)
  return _internal_packet_loss();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_packet_loss(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.packet_loss_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_packet_loss(float value) {
  _internal_set_packet_loss(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.packet_loss)
}

// optional uint32 ping_default_internet_route = 6;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_ping_default_internet_route() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_ping_default_internet_route() const {
  return _internal_has_ping_default_internet_route();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_ping_default_internet_route() {
  _impl_.ping_default_internet_route_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::_internal_ping_default_internet_route() const {
  return _impl_.ping_default_internet_route_;
}
inline uint32_t CGameNetworkingUI_ConnectionSummary::ping_default_internet_route() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.ping_default_internet_route)
  return _internal_ping_default_internet_route();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_ping_default_internet_route(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ping_default_internet_route_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_ping_default_internet_route(uint32_t value) {
  _internal_set_ping_default_internet_route(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.ping_default_internet_route)
}

// optional bool ip_was_shared = 7;
inline bool CGameNetworkingUI_ConnectionSummary::_internal_has_ip_was_shared() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CGameNetworkingUI_ConnectionSummary::has_ip_was_shared() const {
  return _internal_has_ip_was_shared();
}
inline void CGameNetworkingUI_ConnectionSummary::clear_ip_was_shared() {
  _impl_.ip_was_shared_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CGameNetworkingUI_ConnectionSummary::_internal_ip_was_shared() const {
  return _impl_.ip_was_shared_;
}
inline bool CGameNetworkingUI_ConnectionSummary::ip_was_shared() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionSummary.ip_was_shared)
  return _internal_ip_was_shared();
}
inline void CGameNetworkingUI_ConnectionSummary::_internal_set_ip_was_shared(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ip_was_shared_ = value;
}
inline void CGameNetworkingUI_ConnectionSummary::set_ip_was_shared(bool value) {
  _internal_set_ip_was_shared(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionSummary.ip_was_shared)
}

// -------------------------------------------------------------------

// CGameNetworkingUI_AppSummary

// optional uint32 appid = 1;
inline bool CGameNetworkingUI_AppSummary::_internal_has_appid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CGameNetworkingUI_AppSummary::has_appid() const {
  return _internal_has_appid();
}
inline void CGameNetworkingUI_AppSummary::clear_appid() {
  _impl_.appid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CGameNetworkingUI_AppSummary::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t CGameNetworkingUI_AppSummary::appid() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_AppSummary.appid)
  return _internal_appid();
}
inline void CGameNetworkingUI_AppSummary::_internal_set_appid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.appid_ = value;
}
inline void CGameNetworkingUI_AppSummary::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_AppSummary.appid)
}

// optional bool ip_was_shared_with_friend = 10;
inline bool CGameNetworkingUI_AppSummary::_internal_has_ip_was_shared_with_friend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CGameNetworkingUI_AppSummary::has_ip_was_shared_with_friend() const {
  return _internal_has_ip_was_shared_with_friend();
}
inline void CGameNetworkingUI_AppSummary::clear_ip_was_shared_with_friend() {
  _impl_.ip_was_shared_with_friend_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CGameNetworkingUI_AppSummary::_internal_ip_was_shared_with_friend() const {
  return _impl_.ip_was_shared_with_friend_;
}
inline bool CGameNetworkingUI_AppSummary::ip_was_shared_with_friend() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_AppSummary.ip_was_shared_with_friend)
  return _internal_ip_was_shared_with_friend();
}
inline void CGameNetworkingUI_AppSummary::_internal_set_ip_was_shared_with_friend(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ip_was_shared_with_friend_ = value;
}
inline void CGameNetworkingUI_AppSummary::set_ip_was_shared_with_friend(bool value) {
  _internal_set_ip_was_shared_with_friend(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_AppSummary.ip_was_shared_with_friend)
}

// optional bool ip_was_shared_with_nonfriend = 11;
inline bool CGameNetworkingUI_AppSummary::_internal_has_ip_was_shared_with_nonfriend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CGameNetworkingUI_AppSummary::has_ip_was_shared_with_nonfriend() const {
  return _internal_has_ip_was_shared_with_nonfriend();
}
inline void CGameNetworkingUI_AppSummary::clear_ip_was_shared_with_nonfriend() {
  _impl_.ip_was_shared_with_nonfriend_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CGameNetworkingUI_AppSummary::_internal_ip_was_shared_with_nonfriend() const {
  return _impl_.ip_was_shared_with_nonfriend_;
}
inline bool CGameNetworkingUI_AppSummary::ip_was_shared_with_nonfriend() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_AppSummary.ip_was_shared_with_nonfriend)
  return _internal_ip_was_shared_with_nonfriend();
}
inline void CGameNetworkingUI_AppSummary::_internal_set_ip_was_shared_with_nonfriend(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ip_was_shared_with_nonfriend_ = value;
}
inline void CGameNetworkingUI_AppSummary::set_ip_was_shared_with_nonfriend(bool value) {
  _internal_set_ip_was_shared_with_nonfriend(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_AppSummary.ip_was_shared_with_nonfriend)
}

// optional uint32 active_connections = 20;
inline bool CGameNetworkingUI_AppSummary::_internal_has_active_connections() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CGameNetworkingUI_AppSummary::has_active_connections() const {
  return _internal_has_active_connections();
}
inline void CGameNetworkingUI_AppSummary::clear_active_connections() {
  _impl_.active_connections_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CGameNetworkingUI_AppSummary::_internal_active_connections() const {
  return _impl_.active_connections_;
}
inline uint32_t CGameNetworkingUI_AppSummary::active_connections() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_AppSummary.active_connections)
  return _internal_active_connections();
}
inline void CGameNetworkingUI_AppSummary::_internal_set_active_connections(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.active_connections_ = value;
}
inline void CGameNetworkingUI_AppSummary::set_active_connections(uint32_t value) {
  _internal_set_active_connections(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_AppSummary.active_connections)
}

// optional .CGameNetworkingUI_ConnectionSummary main_cxn = 30;
inline bool CGameNetworkingUI_AppSummary::_internal_has_main_cxn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_cxn_ != nullptr);
  return value;
}
inline bool CGameNetworkingUI_AppSummary::has_main_cxn() const {
  return _internal_has_main_cxn();
}
inline void CGameNetworkingUI_AppSummary::clear_main_cxn() {
  if (_impl_.main_cxn_ != nullptr) _impl_.main_cxn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CGameNetworkingUI_ConnectionSummary& CGameNetworkingUI_AppSummary::_internal_main_cxn() const {
  const ::CGameNetworkingUI_ConnectionSummary* p = _impl_.main_cxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::CGameNetworkingUI_ConnectionSummary&>(
      ::_CGameNetworkingUI_ConnectionSummary_default_instance_);
}
inline const ::CGameNetworkingUI_ConnectionSummary& CGameNetworkingUI_AppSummary::main_cxn() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_AppSummary.main_cxn)
  return _internal_main_cxn();
}
inline void CGameNetworkingUI_AppSummary::unsafe_arena_set_allocated_main_cxn(
    ::CGameNetworkingUI_ConnectionSummary* main_cxn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.main_cxn_);
  }
  _impl_.main_cxn_ = main_cxn;
  if (main_cxn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_AppSummary.main_cxn)
}
inline ::CGameNetworkingUI_ConnectionSummary* CGameNetworkingUI_AppSummary::release_main_cxn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CGameNetworkingUI_ConnectionSummary* temp = _impl_.main_cxn_;
  _impl_.main_cxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CGameNetworkingUI_ConnectionSummary* CGameNetworkingUI_AppSummary::unsafe_arena_release_main_cxn() {
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_AppSummary.main_cxn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CGameNetworkingUI_ConnectionSummary* temp = _impl_.main_cxn_;
  _impl_.main_cxn_ = nullptr;
  return temp;
}
inline ::CGameNetworkingUI_ConnectionSummary* CGameNetworkingUI_AppSummary::_internal_mutable_main_cxn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.main_cxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::CGameNetworkingUI_ConnectionSummary>(GetArenaForAllocation());
    _impl_.main_cxn_ = p;
  }
  return _impl_.main_cxn_;
}
inline ::CGameNetworkingUI_ConnectionSummary* CGameNetworkingUI_AppSummary::mutable_main_cxn() {
  ::CGameNetworkingUI_ConnectionSummary* _msg = _internal_mutable_main_cxn();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_AppSummary.main_cxn)
  return _msg;
}
inline void CGameNetworkingUI_AppSummary::set_allocated_main_cxn(::CGameNetworkingUI_ConnectionSummary* main_cxn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.main_cxn_;
  }
  if (main_cxn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(main_cxn);
    if (message_arena != submessage_arena) {
      main_cxn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_cxn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.main_cxn_ = main_cxn;
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_AppSummary.main_cxn)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto
