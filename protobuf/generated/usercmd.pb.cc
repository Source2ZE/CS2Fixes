// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usercmd.proto

#include "usercmd.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CInButtonStatePB::CInButtonStatePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buttonstate1_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate2_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate3_)*/uint64_t{0u}} {}
struct CInButtonStatePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CInButtonStatePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CInButtonStatePBDefaultTypeInternal() {}
  union {
    CInButtonStatePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CInButtonStatePBDefaultTypeInternal _CInButtonStatePB_default_instance_;
PROTOBUF_CONSTEXPR CSubtickMoveStep::CSubtickMoveStep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.button_)*/uint64_t{0u}
  , /*decltype(_impl_.pressed_)*/false
  , /*decltype(_impl_.when_)*/0
  , /*decltype(_impl_.analog_forward_delta_)*/0
  , /*decltype(_impl_.analog_left_delta_)*/0} {}
struct CSubtickMoveStepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSubtickMoveStepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSubtickMoveStepDefaultTypeInternal() {}
  union {
    CSubtickMoveStep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSubtickMoveStepDefaultTypeInternal _CSubtickMoveStep_default_instance_;
PROTOBUF_CONSTEXPR CBaseUserCmdPB::CBaseUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subtick_moves_)*/{}
  , /*decltype(_impl_.move_crc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buttons_pb_)*/nullptr
  , /*decltype(_impl_.viewangles_)*/nullptr
  , /*decltype(_impl_.legacy_command_number_)*/0
  , /*decltype(_impl_.client_tick_)*/0
  , /*decltype(_impl_.forwardmove_)*/0
  , /*decltype(_impl_.leftmove_)*/0
  , /*decltype(_impl_.upmove_)*/0
  , /*decltype(_impl_.impulse_)*/0
  , /*decltype(_impl_.weaponselect_)*/0
  , /*decltype(_impl_.random_seed_)*/0
  , /*decltype(_impl_.mousedx_)*/0
  , /*decltype(_impl_.mousedy_)*/0
  , /*decltype(_impl_.consumed_server_angle_changes_)*/0u
  , /*decltype(_impl_.cmd_flags_)*/0
  , /*decltype(_impl_.pawn_entity_handle_)*/16777215u} {}
struct CBaseUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBaseUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBaseUserCmdPBDefaultTypeInternal() {}
  union {
    CBaseUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBaseUserCmdPBDefaultTypeInternal _CBaseUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CUserCmdBasePB::CUserCmdBasePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct CUserCmdBasePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUserCmdBasePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUserCmdBasePBDefaultTypeInternal() {}
  union {
    CUserCmdBasePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUserCmdBasePBDefaultTypeInternal _CUserCmdBasePB_default_instance_;
static ::_pb::Metadata file_level_metadata_usercmd_2eproto[4];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_usercmd_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_usercmd_2eproto = nullptr;

const uint32_t TableStruct_usercmd_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate1_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate2_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.button_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.pressed_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.when_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.analog_forward_delta_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.analog_left_delta_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.legacy_command_number_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.client_tick_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.buttons_pb_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.viewangles_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.forwardmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.leftmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.upmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.impulse_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.weaponselect_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedx_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedy_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.pawn_entity_handle_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.subtick_moves_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.move_crc_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.consumed_server_angle_changes_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.cmd_flags_),
  3,
  4,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  15,
  ~0u,
  0,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUserCmdBasePB, _impl_.base_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::CInButtonStatePB)},
  { 12, 23, -1, sizeof(::CSubtickMoveStep)},
  { 28, 51, -1, sizeof(::CBaseUserCmdPB)},
  { 68, 75, -1, sizeof(::CUserCmdBasePB)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CInButtonStatePB_default_instance_._instance,
  &::_CSubtickMoveStep_default_instance_._instance,
  &::_CBaseUserCmdPB_default_instance_._instance,
  &::_CUserCmdBasePB_default_instance_._instance,
};

const char descriptor_table_protodef_usercmd_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rusercmd.proto\032\026networkbasetypes.proto\""
  "T\n\020CInButtonStatePB\022\024\n\014buttonstate1\030\001 \001("
  "\004\022\024\n\014buttonstate2\030\002 \001(\004\022\024\n\014buttonstate3\030"
  "\003 \001(\004\"z\n\020CSubtickMoveStep\022\016\n\006button\030\001 \001("
  "\004\022\017\n\007pressed\030\002 \001(\010\022\014\n\004when\030\003 \001(\002\022\034\n\024anal"
  "og_forward_delta\030\004 \001(\002\022\031\n\021analog_left_de"
  "lta\030\005 \001(\002\"\275\003\n\016CBaseUserCmdPB\022\035\n\025legacy_c"
  "ommand_number\030\001 \001(\005\022\023\n\013client_tick\030\002 \001(\005"
  "\022%\n\nbuttons_pb\030\003 \001(\0132\021.CInButtonStatePB\022"
  "\037\n\nviewangles\030\004 \001(\0132\013.CMsgQAngle\022\023\n\013forw"
  "ardmove\030\005 \001(\002\022\020\n\010leftmove\030\006 \001(\002\022\016\n\006upmov"
  "e\030\007 \001(\002\022\017\n\007impulse\030\010 \001(\005\022\024\n\014weaponselect"
  "\030\t \001(\005\022\023\n\013random_seed\030\n \001(\005\022\017\n\007mousedx\030\013"
  " \001(\005\022\017\n\007mousedy\030\014 \001(\005\022$\n\022pawn_entity_han"
  "dle\030\016 \001(\r:\01016777215\022(\n\rsubtick_moves\030\022 \003"
  "(\0132\021.CSubtickMoveStep\022\020\n\010move_crc\030\023 \001(\014\022"
  "%\n\035consumed_server_angle_changes\030\024 \001(\r\022\021"
  "\n\tcmd_flags\030\025 \001(\005\"/\n\016CUserCmdBasePB\022\035\n\004b"
  "ase\030\001 \001(\0132\017.CBaseUserCmdPB"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_usercmd_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_usercmd_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_usercmd_2eproto = {
    false, false, 746, descriptor_table_protodef_usercmd_2eproto,
    "usercmd.proto",
    &descriptor_table_usercmd_2eproto_once, descriptor_table_usercmd_2eproto_deps, 1, 4,
    schemas, file_default_instances, TableStruct_usercmd_2eproto::offsets,
    file_level_metadata_usercmd_2eproto, file_level_enum_descriptors_usercmd_2eproto,
    file_level_service_descriptors_usercmd_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_usercmd_2eproto_getter() {
  return &descriptor_table_usercmd_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_usercmd_2eproto(&descriptor_table_usercmd_2eproto);

// ===================================================================

class CInButtonStatePB::_Internal {
 public:
  using HasBits = decltype(std::declval<CInButtonStatePB>()._impl_._has_bits_);
  static void set_has_buttonstate1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buttonstate2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_buttonstate3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CInButtonStatePB::CInButtonStatePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CInButtonStatePB)
}
CInButtonStatePB::CInButtonStatePB(const CInButtonStatePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CInButtonStatePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){}
    , decltype(_impl_.buttonstate2_){}
    , decltype(_impl_.buttonstate3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.buttonstate1_, &from._impl_.buttonstate1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.buttonstate3_) -
    reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  // @@protoc_insertion_point(copy_constructor:CInButtonStatePB)
}

inline void CInButtonStatePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){uint64_t{0u}}
    , decltype(_impl_.buttonstate2_){uint64_t{0u}}
    , decltype(_impl_.buttonstate3_){uint64_t{0u}}
  };
}

CInButtonStatePB::~CInButtonStatePB() {
  // @@protoc_insertion_point(destructor:CInButtonStatePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CInButtonStatePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInButtonStatePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CInButtonStatePB::Clear() {
// @@protoc_insertion_point(message_clear_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.buttonstate1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buttonstate3_) -
        reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInButtonStatePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 buttonstate1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buttonstate1(&has_bits);
          _impl_.buttonstate1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buttonstate2(&has_bits);
          _impl_.buttonstate2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buttonstate3(&has_bits);
          _impl_.buttonstate3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInButtonStatePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 buttonstate1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_buttonstate1(), target);
  }

  // optional uint64 buttonstate2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_buttonstate2(), target);
  }

  // optional uint64 buttonstate3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_buttonstate3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInButtonStatePB)
  return target;
}

size_t CInButtonStatePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInButtonStatePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 buttonstate1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate1());
    }

    // optional uint64 buttonstate2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate2());
    }

    // optional uint64 buttonstate3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate3());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInButtonStatePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CInButtonStatePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInButtonStatePB::GetClassData() const { return &_class_data_; }


void CInButtonStatePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CInButtonStatePB*>(&to_msg);
  auto& from = static_cast<const CInButtonStatePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CInButtonStatePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.buttonstate1_ = from._impl_.buttonstate1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buttonstate2_ = from._impl_.buttonstate2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.buttonstate3_ = from._impl_.buttonstate3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInButtonStatePB::CopyFrom(const CInButtonStatePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInButtonStatePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInButtonStatePB::IsInitialized() const {
  return true;
}

void CInButtonStatePB::InternalSwap(CInButtonStatePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate3_)
      + sizeof(CInButtonStatePB::_impl_.buttonstate3_)
      - PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate1_)>(
          reinterpret_cast<char*>(&_impl_.buttonstate1_),
          reinterpret_cast<char*>(&other->_impl_.buttonstate1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInButtonStatePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[0]);
}

// ===================================================================

class CSubtickMoveStep::_Internal {
 public:
  using HasBits = decltype(std::declval<CSubtickMoveStep>()._impl_._has_bits_);
  static void set_has_button(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pressed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_when(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_analog_forward_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_analog_left_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CSubtickMoveStep::CSubtickMoveStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSubtickMoveStep)
}
CSubtickMoveStep::CSubtickMoveStep(const CSubtickMoveStep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSubtickMoveStep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){}
    , decltype(_impl_.pressed_){}
    , decltype(_impl_.when_){}
    , decltype(_impl_.analog_forward_delta_){}
    , decltype(_impl_.analog_left_delta_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.button_, &from._impl_.button_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.analog_left_delta_) -
    reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.analog_left_delta_));
  // @@protoc_insertion_point(copy_constructor:CSubtickMoveStep)
}

inline void CSubtickMoveStep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){uint64_t{0u}}
    , decltype(_impl_.pressed_){false}
    , decltype(_impl_.when_){0}
    , decltype(_impl_.analog_forward_delta_){0}
    , decltype(_impl_.analog_left_delta_){0}
  };
}

CSubtickMoveStep::~CSubtickMoveStep() {
  // @@protoc_insertion_point(destructor:CSubtickMoveStep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSubtickMoveStep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSubtickMoveStep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSubtickMoveStep::Clear() {
// @@protoc_insertion_point(message_clear_start:CSubtickMoveStep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.button_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.analog_left_delta_) -
        reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.analog_left_delta_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSubtickMoveStep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 button = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_button(&has_bits);
          _impl_.button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pressed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pressed(&has_bits);
          _impl_.pressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float when = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_when(&has_bits);
          _impl_.when_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float analog_forward_delta = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_analog_forward_delta(&has_bits);
          _impl_.analog_forward_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float analog_left_delta = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_analog_left_delta(&has_bits);
          _impl_.analog_left_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSubtickMoveStep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSubtickMoveStep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 button = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_button(), target);
  }

  // optional bool pressed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_pressed(), target);
  }

  // optional float when = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_when(), target);
  }

  // optional float analog_forward_delta = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_analog_forward_delta(), target);
  }

  // optional float analog_left_delta = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_analog_left_delta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSubtickMoveStep)
  return target;
}

size_t CSubtickMoveStep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSubtickMoveStep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 button = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_button());
    }

    // optional bool pressed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional float when = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float analog_forward_delta = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float analog_left_delta = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSubtickMoveStep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSubtickMoveStep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSubtickMoveStep::GetClassData() const { return &_class_data_; }


void CSubtickMoveStep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSubtickMoveStep*>(&to_msg);
  auto& from = static_cast<const CSubtickMoveStep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSubtickMoveStep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.button_ = from._impl_.button_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pressed_ = from._impl_.pressed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.when_ = from._impl_.when_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.analog_forward_delta_ = from._impl_.analog_forward_delta_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.analog_left_delta_ = from._impl_.analog_left_delta_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSubtickMoveStep::CopyFrom(const CSubtickMoveStep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSubtickMoveStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSubtickMoveStep::IsInitialized() const {
  return true;
}

void CSubtickMoveStep::InternalSwap(CSubtickMoveStep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSubtickMoveStep, _impl_.analog_left_delta_)
      + sizeof(CSubtickMoveStep::_impl_.analog_left_delta_)
      - PROTOBUF_FIELD_OFFSET(CSubtickMoveStep, _impl_.button_)>(
          reinterpret_cast<char*>(&_impl_.button_),
          reinterpret_cast<char*>(&other->_impl_.button_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSubtickMoveStep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[1]);
}

// ===================================================================

class CBaseUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CBaseUserCmdPB>()._impl_._has_bits_);
  static void set_has_legacy_command_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CInButtonStatePB& buttons_pb(const CBaseUserCmdPB* msg);
  static void set_has_buttons_pb(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& viewangles(const CBaseUserCmdPB* msg);
  static void set_has_viewangles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forwardmove(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leftmove(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_upmove(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_impulse(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_weaponselect(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mousedx(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_mousedy(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_pawn_entity_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_move_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumed_server_angle_changes(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cmd_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::CInButtonStatePB&
CBaseUserCmdPB::_Internal::buttons_pb(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.buttons_pb_;
}
const ::CMsgQAngle&
CBaseUserCmdPB::_Internal::viewangles(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.viewangles_;
}
void CBaseUserCmdPB::clear_viewangles() {
  if (_impl_.viewangles_ != nullptr) _impl_.viewangles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CBaseUserCmdPB::CBaseUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBaseUserCmdPB)
}
CBaseUserCmdPB::CBaseUserCmdPB(const CBaseUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBaseUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtick_moves_){from._impl_.subtick_moves_}
    , decltype(_impl_.move_crc_){}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.legacy_command_number_){}
    , decltype(_impl_.client_tick_){}
    , decltype(_impl_.forwardmove_){}
    , decltype(_impl_.leftmove_){}
    , decltype(_impl_.upmove_){}
    , decltype(_impl_.impulse_){}
    , decltype(_impl_.weaponselect_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.mousedx_){}
    , decltype(_impl_.mousedy_){}
    , decltype(_impl_.consumed_server_angle_changes_){}
    , decltype(_impl_.cmd_flags_){}
    , decltype(_impl_.pawn_entity_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.move_crc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.move_crc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_move_crc()) {
    _this->_impl_.move_crc_.Set(from._internal_move_crc(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_buttons_pb()) {
    _this->_impl_.buttons_pb_ = new ::CInButtonStatePB(*from._impl_.buttons_pb_);
  }
  if (from._internal_has_viewangles()) {
    _this->_impl_.viewangles_ = new ::CMsgQAngle(*from._impl_.viewangles_);
  }
  ::memcpy(&_impl_.legacy_command_number_, &from._impl_.legacy_command_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pawn_entity_handle_) -
    reinterpret_cast<char*>(&_impl_.legacy_command_number_)) + sizeof(_impl_.pawn_entity_handle_));
  // @@protoc_insertion_point(copy_constructor:CBaseUserCmdPB)
}

inline void CBaseUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtick_moves_){arena}
    , decltype(_impl_.move_crc_){}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.legacy_command_number_){0}
    , decltype(_impl_.client_tick_){0}
    , decltype(_impl_.forwardmove_){0}
    , decltype(_impl_.leftmove_){0}
    , decltype(_impl_.upmove_){0}
    , decltype(_impl_.impulse_){0}
    , decltype(_impl_.weaponselect_){0}
    , decltype(_impl_.random_seed_){0}
    , decltype(_impl_.mousedx_){0}
    , decltype(_impl_.mousedy_){0}
    , decltype(_impl_.consumed_server_angle_changes_){0u}
    , decltype(_impl_.cmd_flags_){0}
    , decltype(_impl_.pawn_entity_handle_){16777215u}
  };
  _impl_.move_crc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.move_crc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CBaseUserCmdPB::~CBaseUserCmdPB() {
  // @@protoc_insertion_point(destructor:CBaseUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBaseUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subtick_moves_.~RepeatedPtrField();
  _impl_.move_crc_.Destroy();
  if (this != internal_default_instance()) delete _impl_.buttons_pb_;
  if (this != internal_default_instance()) delete _impl_.viewangles_;
}

void CBaseUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBaseUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subtick_moves_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.move_crc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.buttons_pb_ != nullptr);
      _impl_.buttons_pb_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.viewangles_ != nullptr);
      _impl_.viewangles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.legacy_command_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upmove_) -
        reinterpret_cast<char*>(&_impl_.legacy_command_number_)) + sizeof(_impl_.upmove_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.impulse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cmd_flags_) -
        reinterpret_cast<char*>(&_impl_.impulse_)) + sizeof(_impl_.cmd_flags_));
    _impl_.pawn_entity_handle_ = 16777215u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBaseUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 legacy_command_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_legacy_command_number(&has_bits);
          _impl_.legacy_command_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client_tick = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_tick(&has_bits);
          _impl_.client_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CInButtonStatePB buttons_pb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_buttons_pb(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle viewangles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewangles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float forwardmove = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_forwardmove(&has_bits);
          _impl_.forwardmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float leftmove = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_leftmove(&has_bits);
          _impl_.leftmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float upmove = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_upmove(&has_bits);
          _impl_.upmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 impulse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_impulse(&has_bits);
          _impl_.impulse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 weaponselect = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_weaponselect(&has_bits);
          _impl_.weaponselect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedx = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_mousedx(&has_bits);
          _impl_.mousedx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedy = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mousedy(&has_bits);
          _impl_.mousedy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pawn_entity_handle = 14 [default = 16777215];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_pawn_entity_handle(&has_bits);
          _impl_.pawn_entity_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSubtickMoveStep subtick_moves = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_subtick_moves(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes move_crc = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_move_crc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 consumed_server_angle_changes = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_consumed_server_angle_changes(&has_bits);
          _impl_.consumed_server_angle_changes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cmd_flags = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_cmd_flags(&has_bits);
          _impl_.cmd_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBaseUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 legacy_command_number = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_legacy_command_number(), target);
  }

  // optional int32 client_tick = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_client_tick(), target);
  }

  // optional .CInButtonStatePB buttons_pb = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::buttons_pb(this),
        _Internal::buttons_pb(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle viewangles = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::viewangles(this),
        _Internal::viewangles(this).GetCachedSize(), target, stream);
  }

  // optional float forwardmove = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_forwardmove(), target);
  }

  // optional float leftmove = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_leftmove(), target);
  }

  // optional float upmove = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_upmove(), target);
  }

  // optional int32 impulse = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_impulse(), target);
  }

  // optional int32 weaponselect = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_weaponselect(), target);
  }

  // optional int32 random_seed = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_random_seed(), target);
  }

  // optional int32 mousedx = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_mousedx(), target);
  }

  // optional int32 mousedy = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_mousedy(), target);
  }

  // optional uint32 pawn_entity_handle = 14 [default = 16777215];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_pawn_entity_handle(), target);
  }

  // repeated .CSubtickMoveStep subtick_moves = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subtick_moves_size()); i < n; i++) {
    const auto& repfield = this->_internal_subtick_moves(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes move_crc = 19;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_move_crc(), target);
  }

  // optional uint32 consumed_server_angle_changes = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_consumed_server_angle_changes(), target);
  }

  // optional int32 cmd_flags = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_cmd_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBaseUserCmdPB)
  return target;
}

size_t CBaseUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBaseUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSubtickMoveStep subtick_moves = 18;
  total_size += 2UL * this->_internal_subtick_moves_size();
  for (const auto& msg : this->_impl_.subtick_moves_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes move_crc = 19;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_move_crc());
    }

    // optional .CInButtonStatePB buttons_pb = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.buttons_pb_);
    }

    // optional .CMsgQAngle viewangles = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewangles_);
    }

    // optional int32 legacy_command_number = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_legacy_command_number());
    }

    // optional int32 client_tick = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_tick());
    }

    // optional float forwardmove = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float leftmove = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float upmove = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 impulse = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_impulse());
    }

    // optional int32 weaponselect = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weaponselect());
    }

    // optional int32 random_seed = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_random_seed());
    }

    // optional int32 mousedx = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedx());
    }

    // optional int32 mousedy = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedy());
    }

    // optional uint32 consumed_server_angle_changes = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_consumed_server_angle_changes());
    }

    // optional int32 cmd_flags = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_cmd_flags());
    }

    // optional uint32 pawn_entity_handle = 14 [default = 16777215];
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pawn_entity_handle());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBaseUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBaseUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBaseUserCmdPB::GetClassData() const { return &_class_data_; }


void CBaseUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBaseUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CBaseUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBaseUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subtick_moves_.MergeFrom(from._impl_.subtick_moves_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_move_crc(from._internal_move_crc());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_buttons_pb()->::CInButtonStatePB::MergeFrom(
          from._internal_buttons_pb());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_viewangles()->::CMsgQAngle::MergeFrom(
          from._internal_viewangles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.legacy_command_number_ = from._impl_.legacy_command_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_tick_ = from._impl_.client_tick_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.forwardmove_ = from._impl_.forwardmove_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.leftmove_ = from._impl_.leftmove_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.upmove_ = from._impl_.upmove_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.impulse_ = from._impl_.impulse_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.weaponselect_ = from._impl_.weaponselect_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.mousedx_ = from._impl_.mousedx_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.mousedy_ = from._impl_.mousedy_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.consumed_server_angle_changes_ = from._impl_.consumed_server_angle_changes_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.cmd_flags_ = from._impl_.cmd_flags_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.pawn_entity_handle_ = from._impl_.pawn_entity_handle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBaseUserCmdPB::CopyFrom(const CBaseUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBaseUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBaseUserCmdPB::IsInitialized() const {
  return true;
}

void CBaseUserCmdPB::InternalSwap(CBaseUserCmdPB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subtick_moves_.InternalSwap(&other->_impl_.subtick_moves_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.move_crc_, lhs_arena,
      &other->_impl_.move_crc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.cmd_flags_)
      + sizeof(CBaseUserCmdPB::_impl_.cmd_flags_)
      - PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.buttons_pb_)>(
          reinterpret_cast<char*>(&_impl_.buttons_pb_),
          reinterpret_cast<char*>(&other->_impl_.buttons_pb_));
  swap(_impl_.pawn_entity_handle_, other->_impl_.pawn_entity_handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBaseUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[2]);
}

// ===================================================================

class CUserCmdBasePB::_Internal {
 public:
  using HasBits = decltype(std::declval<CUserCmdBasePB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CUserCmdBasePB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CBaseUserCmdPB&
CUserCmdBasePB::_Internal::base(const CUserCmdBasePB* msg) {
  return *msg->_impl_.base_;
}
CUserCmdBasePB::CUserCmdBasePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUserCmdBasePB)
}
CUserCmdBasePB::CUserCmdBasePB(const CUserCmdBasePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUserCmdBasePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:CUserCmdBasePB)
}

inline void CUserCmdBasePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
  };
}

CUserCmdBasePB::~CUserCmdBasePB() {
  // @@protoc_insertion_point(destructor:CUserCmdBasePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUserCmdBasePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CUserCmdBasePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUserCmdBasePB::Clear() {
// @@protoc_insertion_point(message_clear_start:CUserCmdBasePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUserCmdBasePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUserCmdBasePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUserCmdBasePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUserCmdBasePB)
  return target;
}

size_t CUserCmdBasePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUserCmdBasePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CBaseUserCmdPB base = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUserCmdBasePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUserCmdBasePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUserCmdBasePB::GetClassData() const { return &_class_data_; }


void CUserCmdBasePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUserCmdBasePB*>(&to_msg);
  auto& from = static_cast<const CUserCmdBasePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUserCmdBasePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUserCmdBasePB::CopyFrom(const CUserCmdBasePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUserCmdBasePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUserCmdBasePB::IsInitialized() const {
  return true;
}

void CUserCmdBasePB::InternalSwap(CUserCmdBasePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CUserCmdBasePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usercmd_2eproto_getter, &descriptor_table_usercmd_2eproto_once,
      file_level_metadata_usercmd_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CInButtonStatePB*
Arena::CreateMaybeMessage< ::CInButtonStatePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInButtonStatePB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSubtickMoveStep*
Arena::CreateMaybeMessage< ::CSubtickMoveStep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSubtickMoveStep >(arena);
}
template<> PROTOBUF_NOINLINE ::CBaseUserCmdPB*
Arena::CreateMaybeMessage< ::CBaseUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBaseUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CUserCmdBasePB*
Arena::CreateMaybeMessage< ::CUserCmdBasePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUserCmdBasePB >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
