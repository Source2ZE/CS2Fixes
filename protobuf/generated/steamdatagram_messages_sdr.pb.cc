// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steamdatagram_messages_sdr.proto

#include "steamdatagram_messages_sdr.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgSteamNetworkingIPAddress::CMsgSteamNetworkingIPAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.v6_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.v4_)*/0u} {}
struct CMsgSteamNetworkingIPAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamNetworkingIPAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamNetworkingIPAddressDefaultTypeInternal() {}
  union {
    CMsgSteamNetworkingIPAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamNetworkingIPAddressDefaultTypeInternal _CMsgSteamNetworkingIPAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramSignedMessageGeneric::CMsgSteamDatagramSignedMessageGeneric(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signed_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dummy_pad_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cert_)*/nullptr} {}
struct CMsgSteamDatagramSignedMessageGenericDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramSignedMessageGenericDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramSignedMessageGenericDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramSignedMessageGeneric _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramSignedMessageGenericDefaultTypeInternal _CMsgSteamDatagramSignedMessageGeneric_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReply_RouteException::CMsgSteamDatagramRouterPingReply_RouteException(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_center_id_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.penalty_)*/0u} {}
struct CMsgSteamDatagramRouterPingReply_RouteExceptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReply_RouteExceptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramRouterPingReply_RouteExceptionDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramRouterPingReply_RouteException _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramRouterPingReply_RouteExceptionDefaultTypeInternal _CMsgSteamDatagramRouterPingReply_RouteException_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReply_AltAddress::CMsgSteamDatagramRouterPingReply_AltAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipv4_)*/0u
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_.penalty_)*/0u
  , /*decltype(_impl_.protocol_)*/0} {}
struct CMsgSteamDatagramRouterPingReply_AltAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReply_AltAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramRouterPingReply_AltAddressDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramRouterPingReply_AltAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramRouterPingReply_AltAddressDefaultTypeInternal _CMsgSteamDatagramRouterPingReply_AltAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReply::CMsgSteamDatagramRouterPingReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latency_datacenter_ids_)*/{}
  , /*decltype(_impl_.latency_ping_ms_)*/{}
  , /*decltype(_impl_._latency_ping_ms_cached_byte_size_)*/{0}
  , /*decltype(_impl_.route_exceptions_)*/{}
  , /*decltype(_impl_.alt_addresses_)*/{}
  , /*decltype(_impl_.latency_datacenter_ids_p2p_)*/{}
  , /*decltype(_impl_.latency_ping_ms_p2p_)*/{}
  , /*decltype(_impl_._latency_ping_ms_p2p_cached_byte_size_)*/{0}
  , /*decltype(_impl_.dummy_pad_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_timestamp_)*/0u
  , /*decltype(_impl_.your_public_ip_)*/0u
  , /*decltype(_impl_.challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.server_time_)*/0u
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.client_cookie_)*/0u
  , /*decltype(_impl_.scoring_penalty_relay_cluster_)*/0u
  , /*decltype(_impl_.your_public_port_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.recv_tos_)*/0u
  , /*decltype(_impl_.echo_sent_tos_)*/0u
  , /*decltype(_impl_.sent_tos_)*/0u
  , /*decltype(_impl_.echo_request_reply_tos_)*/0u
  , /*decltype(_impl_.dummy_varint_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramRouterPingReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramRouterPingReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramRouterPingReplyDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramRouterPingReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramRouterPingReplyDefaultTypeInternal _CMsgSteamDatagramRouterPingReply_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingRequestBody::CMsgSteamDatagramGameserverPingRequestBody(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.my_ips_)*/{}
  , /*decltype(_impl_.echo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.your_public_ip_)*/nullptr
  , /*decltype(_impl_.relay_popid_)*/0u
  , /*decltype(_impl_.your_public_port_)*/0u
  , /*decltype(_impl_.relay_unix_time_)*/uint64_t{0u}
  , /*decltype(_impl_.routing_secret_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramGameserverPingRequestBodyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingRequestBodyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramGameserverPingRequestBodyDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramGameserverPingRequestBody _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramGameserverPingRequestBodyDefaultTypeInternal _CMsgSteamDatagramGameserverPingRequestBody_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingRequestEnvelope::CMsgSteamDatagramGameserverPingRequestEnvelope(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signed_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dummy_pad_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cert_)*/nullptr
  , /*decltype(_impl_.legacy_your_public_ip_)*/0u
  , /*decltype(_impl_.legacy_relay_unix_time_)*/0u
  , /*decltype(_impl_.legacy_challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.legacy_router_timestamp_)*/0u
  , /*decltype(_impl_.legacy_your_public_port_)*/0u} {}
struct CMsgSteamDatagramGameserverPingRequestEnvelopeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingRequestEnvelopeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramGameserverPingRequestEnvelopeDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramGameserverPingRequestEnvelope _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramGameserverPingRequestEnvelopeDefaultTypeInternal _CMsgSteamDatagramGameserverPingRequestEnvelope_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingReplyData::CMsgSteamDatagramGameserverPingReplyData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.echo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.build_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.routing_blob_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.legacy_challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.echo_relay_unix_time_)*/0u
  , /*decltype(_impl_.legacy_router_timestamp_)*/0u
  , /*decltype(_impl_.data_center_id_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.protocol_version_)*/0u
  , /*decltype(_impl_.my_unix_time_)*/0u
  , /*decltype(_impl_.network_config_version_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramGameserverPingReplyDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverPingReplyDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramGameserverPingReplyDataDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramGameserverPingReplyData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramGameserverPingReplyDataDefaultTypeInternal _CMsgSteamDatagramGameserverPingReplyData_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramNoSessionRelayToClient::CMsgSteamDatagramNoSessionRelayToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.your_public_ip_)*/0u
  , /*decltype(_impl_.server_time_)*/0u
  , /*decltype(_impl_.challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.your_public_port_)*/0u
  , /*decltype(_impl_.connection_id_)*/0u} {}
struct CMsgSteamDatagramNoSessionRelayToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramNoSessionRelayToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramNoSessionRelayToClientDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramNoSessionRelayToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramNoSessionRelayToClientDefaultTypeInternal _CMsgSteamDatagramNoSessionRelayToClient_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramNoSessionRelayToPeer::CMsgSteamDatagramNoSessionRelayToPeer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.legacy_relay_session_id_)*/0u
  , /*decltype(_impl_.from_relay_session_id_)*/0u
  , /*decltype(_impl_.kludge_pad_)*/uint64_t{0u}
  , /*decltype(_impl_.from_connection_id_)*/0u} {}
struct CMsgSteamDatagramNoSessionRelayToPeerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramNoSessionRelayToPeerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramNoSessionRelayToPeerDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramNoSessionRelayToPeer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramNoSessionRelayToPeerDefaultTypeInternal _CMsgSteamDatagramNoSessionRelayToPeer_default_instance_;
PROTOBUF_CONSTEXPR CMsgTOSTreatment::CMsgTOSTreatment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.l4s_detect_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.up_ecn1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.down_dscp45_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgTOSTreatmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTOSTreatmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTOSTreatmentDefaultTypeInternal() {}
  union {
    CMsgTOSTreatment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTOSTreatmentDefaultTypeInternal _CMsgTOSTreatment_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleRequest::CMsgSteamDatagramClientPingSampleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.connection_id_)*/0u} {}
struct CMsgSteamDatagramClientPingSampleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientPingSampleRequestDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientPingSampleRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientPingSampleRequestDefaultTypeInternal _CMsgSteamDatagramClientPingSampleRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.front_ping_ms_)*/0u
  , /*decltype(_impl_.penalty_)*/0u} {}
struct CMsgSteamDatagramClientPingSampleReply_POP_AltAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_POP_AltAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientPingSampleReply_POP_AltAddressDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientPingSampleReply_POP_AltAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientPingSampleReply_POP_AltAddressDefaultTypeInternal _CMsgSteamDatagramClientPingSampleReply_POP_AltAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_POP::CMsgSteamDatagramClientPingSampleReply_POP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alt_addresses_)*/{}
  , /*decltype(_impl_.pop_id_)*/0u
  , /*decltype(_impl_.default_front_ping_ms_)*/0u
  , /*decltype(_impl_.default_e2e_ping_ms_)*/0u
  , /*decltype(_impl_.cluster_penalty_)*/0u
  , /*decltype(_impl_.default_e2e_score_)*/0u
  , /*decltype(_impl_.p2p_via_peer_relay_pop_id_)*/0u
  , /*decltype(_impl_.best_dc_ping_ms_)*/0u
  , /*decltype(_impl_.best_dc_score_)*/0u
  , /*decltype(_impl_.best_dc_via_relay_pop_id_)*/0u
  , /*decltype(_impl_.default_dc_ping_ms_)*/0u
  , /*decltype(_impl_.default_dc_score_)*/0u
  , /*decltype(_impl_.default_dc_via_relay_pop_id_)*/0u
  , /*decltype(_impl_.test_dc_ping_ms_)*/0u
  , /*decltype(_impl_.test_dc_score_)*/0u
  , /*decltype(_impl_.test_dc_via_relay_pop_id_)*/0u} {}
struct CMsgSteamDatagramClientPingSampleReply_POPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_POPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientPingSampleReply_POPDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientPingSampleReply_POP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientPingSampleReply_POPDefaultTypeInternal _CMsgSteamDatagramClientPingSampleReply_POP_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_center_id_)*/0u
  , /*decltype(_impl_.best_dc_via_relay_pop_id_)*/0u
  , /*decltype(_impl_.best_dc_ping_ms_)*/0u} {}
struct CMsgSteamDatagramClientPingSampleReply_LegacyDataCenterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply_LegacyDataCenterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientPingSampleReply_LegacyDataCenterDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientPingSampleReply_LegacyDataCenterDefaultTypeInternal _CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReply::CMsgSteamDatagramClientPingSampleReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pops_)*/{}
  , /*decltype(_impl_.legacy_data_centers_)*/{}
  , /*decltype(_impl_.tos_)*/nullptr
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.relay_override_active_)*/false} {}
struct CMsgSteamDatagramClientPingSampleReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientPingSampleReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientPingSampleReplyDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientPingSampleReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientPingSampleReplyDefaultTypeInternal _CMsgSteamDatagramClientPingSampleReply_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.score_)*/0u
  , /*decltype(_impl_.front_ping_)*/0u
  , /*decltype(_impl_.back_ping_)*/0u
  , /*decltype(_impl_.seconds_until_down_)*/0u} {}
struct CMsgSteamDatagramClientSwitchedPrimary_RouterQualityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientSwitchedPrimary_RouterQualityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientSwitchedPrimary_RouterQualityDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientSwitchedPrimary_RouterQuality _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientSwitchedPrimary_RouterQualityDefaultTypeInternal _CMsgSteamDatagramClientSwitchedPrimary_RouterQuality_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramClientSwitchedPrimary::CMsgSteamDatagramClientSwitchedPrimary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.from_dropped_reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_quality_now_)*/nullptr
  , /*decltype(_impl_.to_quality_now_)*/nullptr
  , /*decltype(_impl_.from_quality_then_)*/nullptr
  , /*decltype(_impl_.to_quality_then_)*/nullptr
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.from_ip_)*/0u
  , /*decltype(_impl_.from_port_)*/0u
  , /*decltype(_impl_.from_router_cluster_)*/0u
  , /*decltype(_impl_.from_active_time_)*/0u
  , /*decltype(_impl_.from_active_packets_recv_)*/0u
  , /*decltype(_impl_.gap_ms_)*/0u} {}
struct CMsgSteamDatagramClientSwitchedPrimaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramClientSwitchedPrimaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramClientSwitchedPrimaryDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramClientSwitchedPrimary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramClientSwitchedPrimaryDefaultTypeInternal _CMsgSteamDatagramClientSwitchedPrimary_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectRequest::CMsgSteamDatagramConnectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.crypt_)*/nullptr
  , /*decltype(_impl_.cert_)*/nullptr
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.gameserver_relay_session_id_)*/0u
  , /*decltype(_impl_.legacy_client_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.my_timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.ping_est_ms_)*/0u
  , /*decltype(_impl_.virtual_port_)*/0u
  , /*decltype(_impl_.routing_secret_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramConnectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectRequestDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectRequestDefaultTypeInternal _CMsgSteamDatagramConnectRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectOK::CMsgSteamDatagramConnectOK(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.crypt_)*/nullptr
  , /*decltype(_impl_.cert_)*/nullptr
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.gameserver_relay_session_id_)*/0u
  , /*decltype(_impl_.your_timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.delay_time_usec_)*/0u
  , /*decltype(_impl_.server_connection_id_)*/0u} {}
struct CMsgSteamDatagramConnectOKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectOKDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectOKDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectOK _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectOKDefaultTypeInternal _CMsgSteamDatagramConnectOK_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamNetworkingP2PSDRRoutingSummary::CMsgSteamNetworkingP2PSDRRoutingSummary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.initial_ping_)*/0u
  , /*decltype(_impl_.initial_ping_front_local_)*/0u
  , /*decltype(_impl_.initial_ping_front_remote_)*/0u
  , /*decltype(_impl_.initial_score_)*/0u
  , /*decltype(_impl_.initial_pop_local_)*/0u
  , /*decltype(_impl_.initial_pop_remote_)*/0u
  , /*decltype(_impl_.negotiation_ms_)*/0u
  , /*decltype(_impl_.selected_seconds_)*/0u
  , /*decltype(_impl_.best_ping_)*/0u
  , /*decltype(_impl_.best_ping_front_local_)*/0u
  , /*decltype(_impl_.best_ping_front_remote_)*/0u
  , /*decltype(_impl_.best_score_)*/0u
  , /*decltype(_impl_.best_pop_local_)*/0u
  , /*decltype(_impl_.best_pop_remote_)*/0u
  , /*decltype(_impl_.best_time_)*/0u} {}
struct CMsgSteamNetworkingP2PSDRRoutingSummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamNetworkingP2PSDRRoutingSummaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamNetworkingP2PSDRRoutingSummaryDefaultTypeInternal() {}
  union {
    CMsgSteamNetworkingP2PSDRRoutingSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamNetworkingP2PSDRRoutingSummaryDefaultTypeInternal _CMsgSteamNetworkingP2PSDRRoutingSummary_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutingSummary::CMsgSteamDatagramP2PRoutingSummary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ice_)*/nullptr
  , /*decltype(_impl_.sdr_)*/nullptr} {}
struct CMsgSteamDatagramP2PRoutingSummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutingSummaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PRoutingSummaryDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PRoutingSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PRoutingSummaryDefaultTypeInternal _CMsgSteamDatagramP2PRoutingSummary_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionClosed::CMsgSteamDatagramConnectionClosed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.debug_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.forward_target_relay_routing_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.legacy_from_identity_binary_)*/nullptr
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.p2p_routing_summary_)*/nullptr
  , /*decltype(_impl_.legacy_from_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.legacy_gameserver_relay_session_id_)*/0u
  , /*decltype(_impl_.relay_mode_)*/0
  , /*decltype(_impl_.reason_code_)*/0u
  , /*decltype(_impl_.to_connection_id_)*/0u
  , /*decltype(_impl_.from_connection_id_)*/0u
  , /*decltype(_impl_.to_relay_session_id_)*/0u
  , /*decltype(_impl_.from_relay_session_id_)*/0u
  , /*decltype(_impl_.forward_target_revision_)*/0u
  , /*decltype(_impl_.routing_secret_)*/uint64_t{0u}
  , /*decltype(_impl_.not_primary_session_)*/false
  , /*decltype(_impl_.not_primary_transport_)*/false
  , /*decltype(_impl_.relay_override_active_)*/false} {}
struct CMsgSteamDatagramConnectionClosedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionClosedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionClosedDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionClosed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionClosedDefaultTypeInternal _CMsgSteamDatagramConnectionClosed_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramNoConnection::CMsgSteamDatagramNoConnection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.from_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.p2p_routing_summary_)*/nullptr
  , /*decltype(_impl_.legacy_from_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.legacy_gameserver_relay_session_id_)*/0u
  , /*decltype(_impl_.to_connection_id_)*/0u
  , /*decltype(_impl_.from_connection_id_)*/0u
  , /*decltype(_impl_.to_relay_session_id_)*/0u
  , /*decltype(_impl_.routing_secret_)*/uint64_t{0u}
  , /*decltype(_impl_.from_relay_session_id_)*/0u
  , /*decltype(_impl_.end_to_end_)*/false
  , /*decltype(_impl_.not_primary_session_)*/false
  , /*decltype(_impl_.not_primary_transport_)*/false
  , /*decltype(_impl_.relay_override_active_)*/false
  , /*decltype(_impl_.dummy_pad_)*/0u} {}
struct CMsgSteamDatagramNoConnectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramNoConnectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramNoConnectionDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramNoConnection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramNoConnectionDefaultTypeInternal _CMsgSteamDatagramNoConnection_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverSessionRequest::CMsgSteamDatagramGameserverSessionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ticket_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.platform_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.build_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_gameserver_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_client_cert_)*/nullptr
  , /*decltype(_impl_.challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.challenge_time_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.network_config_version_)*/uint64_t{0u}
  , /*decltype(_impl_.protocol_version_)*/0u
  , /*decltype(_impl_.server_connection_id_)*/0u} {}
struct CMsgSteamDatagramGameserverSessionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverSessionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramGameserverSessionRequestDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramGameserverSessionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramGameserverSessionRequestDefaultTypeInternal _CMsgSteamDatagramGameserverSessionRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverSessionEstablished::CMsgSteamDatagramGameserverSessionEstablished(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gameserver_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dummy_legacy_identity_binary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.legacy_gameserver_steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.seq_num_r2c_)*/0u} {}
struct CMsgSteamDatagramGameserverSessionEstablishedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramGameserverSessionEstablishedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramGameserverSessionEstablishedDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramGameserverSessionEstablished _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramGameserverSessionEstablishedDefaultTypeInternal _CMsgSteamDatagramGameserverSessionEstablished_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsClientToRouter::CMsgSteamDatagramConnectionStatsClientToRouter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.seq_num_c2r_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u} {}
struct CMsgSteamDatagramConnectionStatsClientToRouterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsClientToRouterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsClientToRouterDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsClientToRouter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsClientToRouterDefaultTypeInternal _CMsgSteamDatagramConnectionStatsClientToRouter_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsRouterToClient::CMsgSteamDatagramConnectionStatsRouterToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.seq_num_r2c_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u
  , /*decltype(_impl_.migrate_request_ip_)*/0u
  , /*decltype(_impl_.migrate_request_port_)*/0u
  , /*decltype(_impl_.scoring_penalty_relay_cluster_)*/0u
  , /*decltype(_impl_.flags_)*/0u} {}
struct CMsgSteamDatagramConnectionStatsRouterToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsRouterToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsRouterToClientDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsRouterToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsRouterToClientDefaultTypeInternal _CMsgSteamDatagramConnectionStatsRouterToClient_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsRouterToServer::CMsgSteamDatagramConnectionStatsRouterToServer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.client_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.seq_num_r2s_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u
  , /*decltype(_impl_.legacy_client_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.relay_session_id_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.server_connection_id_)*/0u
  , /*decltype(_impl_.routing_secret_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramConnectionStatsRouterToServerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsRouterToServerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsRouterToServerDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsRouterToServer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsRouterToServerDefaultTypeInternal _CMsgSteamDatagramConnectionStatsRouterToServer_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsServerToRouter::CMsgSteamDatagramConnectionStatsServerToRouter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.seq_num_s2r_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u
  , /*decltype(_impl_.relay_session_id_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.server_connection_id_)*/0u} {}
struct CMsgSteamDatagramConnectionStatsServerToRouterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsServerToRouterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsServerToRouterDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsServerToRouter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsServerToRouterDefaultTypeInternal _CMsgSteamDatagramConnectionStatsServerToRouter_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.peer_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgSteamDatagramP2PSessionRequestBody_EncryptedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequestBody_EncryptedDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PSessionRequestBody_EncryptedDataDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PSessionRequestBody_EncryptedData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PSessionRequestBody_EncryptedDataDefaultTypeInternal _CMsgSteamDatagramP2PSessionRequestBody_EncryptedData_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequestBody::CMsgSteamDatagramP2PSessionRequestBody(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.peer_identity_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.platform_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.build_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encrypted_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encryption_my_ephemeral_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.challenge_)*/uint64_t{0u}
  , /*decltype(_impl_.challenge_time_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.legacy_peer_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.peer_connection_id_)*/0u
  , /*decltype(_impl_.protocol_version_)*/0u
  , /*decltype(_impl_.network_config_version_)*/uint64_t{0u}
  , /*decltype(_impl_.encryption_your_public_key_lead_byte_)*/0u} {}
struct CMsgSteamDatagramP2PSessionRequestBodyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequestBodyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PSessionRequestBodyDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PSessionRequestBody _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PSessionRequestBodyDefaultTypeInternal _CMsgSteamDatagramP2PSessionRequestBody_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequest::CMsgSteamDatagramP2PSessionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cert_)*/nullptr} {}
struct CMsgSteamDatagramP2PSessionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PSessionRequestDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PSessionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PSessionRequestDefaultTypeInternal _CMsgSteamDatagramP2PSessionRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionEstablished::CMsgSteamDatagramP2PSessionEstablished(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.relay_routing_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.seq_num_r2c_)*/0u} {}
struct CMsgSteamDatagramP2PSessionEstablishedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PSessionEstablishedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PSessionEstablishedDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PSessionEstablished _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PSessionEstablishedDefaultTypeInternal _CMsgSteamDatagramP2PSessionEstablished_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsP2PClientToRouter::CMsgSteamDatagramConnectionStatsP2PClientToRouter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.forward_target_relay_routing_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.routes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.p2p_routing_summary_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.forward_target_revision_)*/0u
  , /*decltype(_impl_.ack_peer_routes_revision_)*/0u
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.seq_num_c2r_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u} {}
struct CMsgSteamDatagramConnectionStatsP2PClientToRouterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsP2PClientToRouterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsP2PClientToRouterDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsP2PClientToRouter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsP2PClientToRouterDefaultTypeInternal _CMsgSteamDatagramConnectionStatsP2PClientToRouter_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsP2PRouterToClient::CMsgSteamDatagramConnectionStatsP2PRouterToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ack_relay_)*/{}
  , /*decltype(_impl_.legacy_ack_e2e_)*/{}
  , /*decltype(_impl_.routes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_relay_)*/nullptr
  , /*decltype(_impl_.quality_e2e_)*/nullptr
  , /*decltype(_impl_.seconds_until_shutdown_)*/0u
  , /*decltype(_impl_.migrate_request_ip_)*/0u
  , /*decltype(_impl_.migrate_request_port_)*/0u
  , /*decltype(_impl_.scoring_penalty_relay_cluster_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.ack_forward_target_revision_)*/0u
  , /*decltype(_impl_.ack_peer_routes_revision_)*/0u
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.seq_num_r2c_)*/0u
  , /*decltype(_impl_.seq_num_e2e_)*/0u} {}
struct CMsgSteamDatagramConnectionStatsP2PRouterToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramConnectionStatsP2PRouterToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramConnectionStatsP2PRouterToClientDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramConnectionStatsP2PRouterToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramConnectionStatsP2PRouterToClientDefaultTypeInternal _CMsgSteamDatagramConnectionStatsP2PRouterToClient_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PBadRouteRouterToClient::CMsgSteamDatagramP2PBadRouteRouterToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.failed_relay_routing_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_id_)*/0u
  , /*decltype(_impl_.ack_forward_target_revision_)*/0u
  , /*decltype(_impl_.kludge_pad_)*/uint64_t{0u}} {}
struct CMsgSteamDatagramP2PBadRouteRouterToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PBadRouteRouterToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PBadRouteRouterToClientDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PBadRouteRouterToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PBadRouteRouterToClientDefaultTypeInternal _CMsgSteamDatagramP2PBadRouteRouterToClient_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutes_RelayCluster::CMsgSteamDatagramP2PRoutes_RelayCluster(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.session_relay_routing_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pop_id_)*/0u
  , /*decltype(_impl_.ping_ms_)*/0u
  , /*decltype(_impl_.score_penalty_)*/0u} {}
struct CMsgSteamDatagramP2PRoutes_RelayClusterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutes_RelayClusterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PRoutes_RelayClusterDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PRoutes_RelayCluster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PRoutes_RelayClusterDefaultTypeInternal _CMsgSteamDatagramP2PRoutes_RelayCluster_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutes_Route::CMsgSteamDatagramP2PRoutes_Route(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.my_pop_id_)*/0u
  , /*decltype(_impl_.your_pop_id_)*/0u
  , /*decltype(_impl_.legacy_score_)*/0u
  , /*decltype(_impl_.interior_score_)*/0u} {}
struct CMsgSteamDatagramP2PRoutes_RouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutes_RouteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PRoutes_RouteDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PRoutes_Route _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PRoutes_RouteDefaultTypeInternal _CMsgSteamDatagramP2PRoutes_Route_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutes::CMsgSteamDatagramP2PRoutes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.relay_clusters_)*/{}
  , /*decltype(_impl_.routes_)*/{}
  , /*decltype(_impl_.revision_)*/0u} {}
struct CMsgSteamDatagramP2PRoutesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramP2PRoutesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramP2PRoutesDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramP2PRoutes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramP2PRoutesDefaultTypeInternal _CMsgSteamDatagramP2PRoutes_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramSetSecondaryAddressRequest::CMsgSteamDatagramSetSecondaryAddressRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kludge_pad_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_main_ip_)*/0u
  , /*decltype(_impl_.client_main_port_)*/0u
  , /*decltype(_impl_.client_connection_id_)*/0u
  , /*decltype(_impl_.request_send_duplication_)*/false} {}
struct CMsgSteamDatagramSetSecondaryAddressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramSetSecondaryAddressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramSetSecondaryAddressRequestDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramSetSecondaryAddressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramSetSecondaryAddressRequestDefaultTypeInternal _CMsgSteamDatagramSetSecondaryAddressRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamDatagramSetSecondaryAddressResult::CMsgSteamDatagramSetSecondaryAddressResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.success_)*/false} {}
struct CMsgSteamDatagramSetSecondaryAddressResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamDatagramSetSecondaryAddressResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamDatagramSetSecondaryAddressResultDefaultTypeInternal() {}
  union {
    CMsgSteamDatagramSetSecondaryAddressResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamDatagramSetSecondaryAddressResultDefaultTypeInternal _CMsgSteamDatagramSetSecondaryAddressResult_default_instance_;
static ::_pb::Metadata file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[42];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[10];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_steamdatagram_5fmessages_5fsdr_2eproto = nullptr;

const uint32_t TableStruct_steamdatagram_5fmessages_5fsdr_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingIPAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingIPAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingIPAddress, _impl_.v4_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingIPAddress, _impl_.v6_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _impl_.cert_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _impl_.signed_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSignedMessageGeneric, _impl_.dummy_pad_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_RouteException, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_RouteException, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_RouteException, _impl_.data_center_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_RouteException, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_RouteException, _impl_.penalty_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.ipv4_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.penalty_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.id_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.client_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.latency_datacenter_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.latency_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.latency_datacenter_ids_p2p_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.latency_ping_ms_p2p_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.your_public_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.your_public_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.server_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.seconds_until_shutdown_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.client_cookie_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.recv_tos_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.echo_sent_tos_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.sent_tos_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.echo_request_reply_tos_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.scoring_penalty_relay_cluster_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.route_exceptions_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.alt_addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.dummy_pad_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramRouterPingReply, _impl_.dummy_varint_),
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  8,
  4,
  3,
  5,
  6,
  10,
  11,
  12,
  13,
  7,
  9,
  ~0u,
  ~0u,
  0,
  14,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.relay_popid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.your_public_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.your_public_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.relay_unix_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.routing_secret_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.my_ips_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestBody, _impl_.echo_),
  2,
  1,
  3,
  4,
  5,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.cert_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.signed_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_your_public_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_your_public_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_relay_unix_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_router_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.dummy_pad_),
  3,
  0,
  1,
  4,
  8,
  5,
  6,
  7,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.echo_relay_unix_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.echo_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.legacy_challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.legacy_router_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.data_center_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.protocol_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.build_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.network_config_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.my_unix_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverPingReplyData, _impl_.routing_blob_),
  4,
  0,
  3,
  5,
  6,
  7,
  8,
  1,
  10,
  9,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.your_public_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.your_public_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.server_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToClient, _impl_.seconds_until_shutdown_),
  5,
  0,
  4,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _impl_.legacy_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _impl_.from_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _impl_.from_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoSessionRelayToPeer, _impl_.kludge_pad_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTOSTreatment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTOSTreatment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTOSTreatment, _impl_.l4s_detect_),
  PROTOBUF_FIELD_OFFSET(::CMsgTOSTreatment, _impl_.up_ecn1_),
  PROTOBUF_FIELD_OFFSET(::CMsgTOSTreatment, _impl_.down_dscp45_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleRequest, _impl_.connection_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_.front_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_.penalty_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_front_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.cluster_penalty_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.alt_addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_e2e_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_e2e_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.p2p_via_peer_relay_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.best_dc_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.best_dc_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.best_dc_via_relay_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_dc_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_dc_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.default_dc_via_relay_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.test_dc_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.test_dc_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_POP, _impl_.test_dc_via_relay_pop_id_),
  0,
  1,
  3,
  ~0u,
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_.data_center_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_.best_dc_via_relay_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_.best_dc_ping_ms_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_.relay_override_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_.tos_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_.pops_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientPingSampleReply, _impl_.legacy_data_centers_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.front_ping_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.back_ping_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.seconds_until_down_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_router_cluster_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_active_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_active_packets_recv_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_dropped_reason_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.gap_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_quality_now_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.to_quality_now_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_quality_then_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramClientSwitchedPrimary, _impl_.to_quality_then_),
  5,
  6,
  7,
  8,
  9,
  10,
  0,
  11,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.my_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.ping_est_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.virtual_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.gameserver_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.crypt_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.cert_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.routing_secret_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectRequest, _impl_.legacy_client_steam_id_),
  2,
  5,
  6,
  7,
  3,
  0,
  1,
  8,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.server_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.your_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.delay_time_usec_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.gameserver_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.crypt_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectOK, _impl_.cert_),
  2,
  6,
  4,
  5,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_ping_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_ping_front_local_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_ping_front_remote_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_pop_local_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_pop_remote_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_ping_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_ping_front_local_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_ping_front_remote_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_pop_local_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_pop_remote_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.negotiation_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.selected_seconds_),
  0,
  1,
  2,
  3,
  4,
  5,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutingSummary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutingSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutingSummary, _impl_.ice_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutingSummary, _impl_.sdr_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.to_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.from_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.from_identity_string_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.legacy_from_identity_binary_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.legacy_from_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.legacy_gameserver_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.to_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.from_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.forward_target_relay_routing_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.forward_target_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.relay_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.debug_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.reason_code_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.routing_secret_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.not_primary_session_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.not_primary_transport_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.relay_override_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionClosed, _impl_.p2p_routing_summary_),
  11,
  12,
  2,
  3,
  7,
  8,
  13,
  14,
  1,
  15,
  9,
  0,
  10,
  16,
  17,
  18,
  19,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.to_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.from_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.legacy_gameserver_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.to_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.from_relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.from_identity_string_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.legacy_from_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.end_to_end_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.not_primary_session_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.not_primary_transport_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.relay_override_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.p2p_routing_summary_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.routing_secret_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramNoConnection, _impl_.dummy_pad_),
  6,
  7,
  5,
  8,
  10,
  0,
  4,
  11,
  12,
  13,
  14,
  1,
  2,
  3,
  9,
  15,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.ticket_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.challenge_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.server_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.network_config_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.protocol_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.platform_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.build_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.dev_gameserver_identity_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionRequest, _impl_.dev_client_cert_),
  0,
  6,
  5,
  7,
  10,
  8,
  9,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.gameserver_identity_string_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.seconds_until_shutdown_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.seq_num_r2c_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.dummy_legacy_identity_binary_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramGameserverSessionEstablished, _impl_.legacy_gameserver_steamid_),
  2,
  0,
  3,
  5,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.seq_num_c2r_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.seq_num_e2e_),
  0,
  1,
  ~0u,
  ~0u,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.seconds_until_shutdown_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.migrate_request_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.migrate_request_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.scoring_penalty_relay_cluster_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.seq_num_r2c_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.seq_num_e2e_),
  0,
  1,
  2,
  6,
  7,
  8,
  ~0u,
  ~0u,
  9,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.seq_num_r2s_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.seq_num_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.client_identity_string_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.legacy_client_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.server_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.routing_secret_),
  1,
  2,
  ~0u,
  ~0u,
  8,
  3,
  4,
  0,
  5,
  6,
  7,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.seq_num_s2r_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.seq_num_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.relay_session_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.server_connection_id_),
  0,
  1,
  ~0u,
  ~0u,
  6,
  2,
  3,
  4,
  5,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData, _impl_.peer_identity_string_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.challenge_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.legacy_peer_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.peer_identity_string_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.peer_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.encrypted_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.encryption_your_public_key_lead_byte_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.encryption_my_ephemeral_public_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.protocol_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.network_config_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.platform_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequestBody, _impl_.build_),
  6,
  5,
  7,
  8,
  0,
  9,
  3,
  12,
  4,
  10,
  11,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequest, _impl_.cert_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequest, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionRequest, _impl_.signature_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _impl_.seconds_until_shutdown_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _impl_.relay_routing_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PSessionEstablished, _impl_.seq_num_r2c_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.p2p_routing_summary_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.forward_target_relay_routing_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.forward_target_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.routes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.ack_peer_routes_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.seq_num_c2r_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.seq_num_e2e_),
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  0,
  6,
  1,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.quality_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.quality_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.seconds_until_shutdown_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.migrate_request_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.migrate_request_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.scoring_penalty_relay_cluster_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.ack_relay_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.legacy_ack_e2e_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.ack_forward_target_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.routes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.ack_peer_routes_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.seq_num_r2c_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.seq_num_e2e_),
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  ~0u,
  7,
  8,
  0,
  9,
  10,
  11,
  12,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.failed_relay_routing_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.ack_forward_target_revision_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.kludge_pad_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.score_penalty_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.session_relay_routing_token_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _impl_.my_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _impl_.your_pop_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _impl_.legacy_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes_Route, _impl_.interior_score_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes, _impl_.relay_clusters_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes, _impl_.routes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramP2PRoutes, _impl_.revision_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.client_main_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.client_main_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.client_connection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.client_identity_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.request_send_duplication_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.kludge_pad_),
  2,
  3,
  4,
  0,
  5,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressResult, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamDatagramSetSecondaryAddressResult, _impl_.message_),
  1,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CMsgSteamNetworkingIPAddress)},
  { 10, 20, -1, sizeof(::CMsgSteamDatagramSignedMessageGeneric)},
  { 24, 33, -1, sizeof(::CMsgSteamDatagramRouterPingReply_RouteException)},
  { 36, 47, -1, sizeof(::CMsgSteamDatagramRouterPingReply_AltAddress)},
  { 52, 79, -1, sizeof(::CMsgSteamDatagramRouterPingReply)},
  { 100, 113, -1, sizeof(::CMsgSteamDatagramGameserverPingRequestBody)},
  { 120, 135, -1, sizeof(::CMsgSteamDatagramGameserverPingRequestEnvelope)},
  { 144, 161, -1, sizeof(::CMsgSteamDatagramGameserverPingReplyData)},
  { 172, 184, -1, sizeof(::CMsgSteamDatagramNoSessionRelayToClient)},
  { 190, 200, -1, sizeof(::CMsgSteamDatagramNoSessionRelayToPeer)},
  { 204, 213, -1, sizeof(::CMsgTOSTreatment)},
  { 216, 223, -1, sizeof(::CMsgSteamDatagramClientPingSampleRequest)},
  { 224, 233, -1, sizeof(::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress)},
  { 236, 258, -1, sizeof(::CMsgSteamDatagramClientPingSampleReply_POP)},
  { 274, 283, -1, sizeof(::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter)},
  { 286, 297, -1, sizeof(::CMsgSteamDatagramClientPingSampleReply)},
  { 302, 312, -1, sizeof(::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality)},
  { 316, 334, -1, sizeof(::CMsgSteamDatagramClientSwitchedPrimary)},
  { 346, 361, -1, sizeof(::CMsgSteamDatagramConnectRequest)},
  { 370, 383, -1, sizeof(::CMsgSteamDatagramConnectOK)},
  { 390, 411, -1, sizeof(::CMsgSteamNetworkingP2PSDRRoutingSummary)},
  { 426, 434, -1, sizeof(::CMsgSteamDatagramP2PRoutingSummary)},
  { 436, 462, -1, sizeof(::CMsgSteamDatagramConnectionClosed)},
  { 482, 504, -1, sizeof(::CMsgSteamDatagramNoConnection)},
  { 520, 537, -1, sizeof(::CMsgSteamDatagramGameserverSessionRequest)},
  { 548, 560, -1, sizeof(::CMsgSteamDatagramGameserverSessionEstablished)},
  { 566, 580, -1, sizeof(::CMsgSteamDatagramConnectionStatsClientToRouter)},
  { 588, 606, -1, sizeof(::CMsgSteamDatagramConnectionStatsRouterToClient)},
  { 618, 637, -1, sizeof(::CMsgSteamDatagramConnectionStatsRouterToServer)},
  { 650, 666, -1, sizeof(::CMsgSteamDatagramConnectionStatsServerToRouter)},
  { 676, 683, -1, sizeof(::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData)},
  { 684, 703, -1, sizeof(::CMsgSteamDatagramP2PSessionRequestBody)},
  { 716, 725, -1, sizeof(::CMsgSteamDatagramP2PSessionRequest)},
  { 728, 738, -1, sizeof(::CMsgSteamDatagramP2PSessionEstablished)},
  { 742, 761, -1, sizeof(::CMsgSteamDatagramConnectionStatsP2PClientToRouter)},
  { 774, 795, -1, sizeof(::CMsgSteamDatagramConnectionStatsP2PRouterToClient)},
  { 810, 820, -1, sizeof(::CMsgSteamDatagramP2PBadRouteRouterToClient)},
  { 824, 834, -1, sizeof(::CMsgSteamDatagramP2PRoutes_RelayCluster)},
  { 838, 848, -1, sizeof(::CMsgSteamDatagramP2PRoutes_Route)},
  { 852, 861, -1, sizeof(::CMsgSteamDatagramP2PRoutes)},
  { 864, 876, -1, sizeof(::CMsgSteamDatagramSetSecondaryAddressRequest)},
  { 882, 890, -1, sizeof(::CMsgSteamDatagramSetSecondaryAddressResult)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgSteamNetworkingIPAddress_default_instance_._instance,
  &::_CMsgSteamDatagramSignedMessageGeneric_default_instance_._instance,
  &::_CMsgSteamDatagramRouterPingReply_RouteException_default_instance_._instance,
  &::_CMsgSteamDatagramRouterPingReply_AltAddress_default_instance_._instance,
  &::_CMsgSteamDatagramRouterPingReply_default_instance_._instance,
  &::_CMsgSteamDatagramGameserverPingRequestBody_default_instance_._instance,
  &::_CMsgSteamDatagramGameserverPingRequestEnvelope_default_instance_._instance,
  &::_CMsgSteamDatagramGameserverPingReplyData_default_instance_._instance,
  &::_CMsgSteamDatagramNoSessionRelayToClient_default_instance_._instance,
  &::_CMsgSteamDatagramNoSessionRelayToPeer_default_instance_._instance,
  &::_CMsgTOSTreatment_default_instance_._instance,
  &::_CMsgSteamDatagramClientPingSampleRequest_default_instance_._instance,
  &::_CMsgSteamDatagramClientPingSampleReply_POP_AltAddress_default_instance_._instance,
  &::_CMsgSteamDatagramClientPingSampleReply_POP_default_instance_._instance,
  &::_CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter_default_instance_._instance,
  &::_CMsgSteamDatagramClientPingSampleReply_default_instance_._instance,
  &::_CMsgSteamDatagramClientSwitchedPrimary_RouterQuality_default_instance_._instance,
  &::_CMsgSteamDatagramClientSwitchedPrimary_default_instance_._instance,
  &::_CMsgSteamDatagramConnectRequest_default_instance_._instance,
  &::_CMsgSteamDatagramConnectOK_default_instance_._instance,
  &::_CMsgSteamNetworkingP2PSDRRoutingSummary_default_instance_._instance,
  &::_CMsgSteamDatagramP2PRoutingSummary_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionClosed_default_instance_._instance,
  &::_CMsgSteamDatagramNoConnection_default_instance_._instance,
  &::_CMsgSteamDatagramGameserverSessionRequest_default_instance_._instance,
  &::_CMsgSteamDatagramGameserverSessionEstablished_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsClientToRouter_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsRouterToClient_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsRouterToServer_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsServerToRouter_default_instance_._instance,
  &::_CMsgSteamDatagramP2PSessionRequestBody_EncryptedData_default_instance_._instance,
  &::_CMsgSteamDatagramP2PSessionRequestBody_default_instance_._instance,
  &::_CMsgSteamDatagramP2PSessionRequest_default_instance_._instance,
  &::_CMsgSteamDatagramP2PSessionEstablished_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsP2PClientToRouter_default_instance_._instance,
  &::_CMsgSteamDatagramConnectionStatsP2PRouterToClient_default_instance_._instance,
  &::_CMsgSteamDatagramP2PBadRouteRouterToClient_default_instance_._instance,
  &::_CMsgSteamDatagramP2PRoutes_RelayCluster_default_instance_._instance,
  &::_CMsgSteamDatagramP2PRoutes_Route_default_instance_._instance,
  &::_CMsgSteamDatagramP2PRoutes_default_instance_._instance,
  &::_CMsgSteamDatagramSetSecondaryAddressRequest_default_instance_._instance,
  &::_CMsgSteamDatagramSetSecondaryAddressResult_default_instance_._instance,
};

const char descriptor_table_protodef_steamdatagram_5fmessages_5fsdr_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n steamdatagram_messages_sdr.proto\032+stea"
  "mnetworkingsockets_messages_certs.proto\032"
  "%steamnetworkingsockets_messages.proto\"6"
  "\n\034CMsgSteamNetworkingIPAddress\022\n\n\002v4\030\001 \001"
  "(\007\022\n\n\002v6\030\002 \001(\014\"\226\001\n%CMsgSteamDatagramSign"
  "edMessageGeneric\0221\n\004cert\030\001 \001(\0132#.CMsgSte"
  "amDatagramCertificateSigned\022\023\n\013signed_da"
  "ta\030\002 \001(\014\022\021\n\tsignature\030\003 \001(\014\022\022\n\tdummy_pad"
  "\030\377\007 \001(\014\"\375\007\n CMsgSteamDatagramRouterPingR"
  "eply\022\030\n\020client_timestamp\030\001 \001(\007\022\"\n\026latenc"
  "y_datacenter_ids\030\002 \003(\007B\002\020\001\022\033\n\017latency_pi"
  "ng_ms\030\003 \003(\rB\002\020\001\022&\n\032latency_datacenter_id"
  "s_p2p\030\016 \003(\007B\002\020\001\022\037\n\023latency_ping_ms_p2p\030\017"
  " \003(\rB\002\020\001\022\026\n\016your_public_ip\030\004 \001(\007\022\030\n\020your"
  "_public_port\030\013 \001(\007\022\023\n\013server_time\030\005 \001(\007\022"
  "\021\n\tchallenge\030\006 \001(\006\022\036\n\026seconds_until_shut"
  "down\030\007 \001(\r\022\025\n\rclient_cookie\030\010 \001(\007\022\020\n\010rec"
  "v_tos\030\020 \001(\r\022\025\n\recho_sent_tos\030\021 \001(\r\022\020\n\010se"
  "nt_tos\030\022 \001(\r\022\036\n\026echo_request_reply_tos\030\023"
  " \001(\r\022%\n\035scoring_penalty_relay_cluster\030\t "
  "\001(\r\022\r\n\005flags\030\014 \001(\r\022J\n\020route_exceptions\030\n"
  " \003(\01320.CMsgSteamDatagramRouterPingReply."
  "RouteException\022C\n\ralt_addresses\030\r \003(\0132,."
  "CMsgSteamDatagramRouterPingReply.AltAddr"
  "ess\022\021\n\tdummy_pad\030c \001(\014\022\024\n\014dummy_varint\030d"
  " \001(\004\032H\n\016RouteException\022\026\n\016data_center_id"
  "\030\001 \001(\007\022\r\n\005flags\030\002 \001(\r\022\017\n\007penalty\030\003 \001(\r\032\300"
  "\001\n\nAltAddress\022\014\n\004ipv4\030\001 \001(\007\022\014\n\004port\030\002 \001("
  "\r\022\017\n\007penalty\030\003 \001(\r\022X\n\010protocol\030\004 \001(\01625.C"
  "MsgSteamDatagramRouterPingReply.AltAddre"
  "ss.Protocol:\017DefaultProtocol\022\n\n\002id\030\005 \001(\t"
  "\"\037\n\010Protocol\022\023\n\017DefaultProtocol\020\000\"L\n\005Fla"
  "gs\022 \n\034FLAG_MAYBE_MORE_DATA_CENTERS\020\001\022!\n\035"
  "FLAG_MAYBE_MORE_ALT_ADDRESSES\020\002\"\200\002\n*CMsg"
  "SteamDatagramGameserverPingRequestBody\022\023"
  "\n\013relay_popid\030\001 \001(\007\0225\n\016your_public_ip\030\002 "
  "\001(\0132\035.CMsgSteamNetworkingIPAddress\022\030\n\020yo"
  "ur_public_port\030\003 \001(\r\022\027\n\017relay_unix_time\030"
  "\004 \001(\004\022\026\n\016routing_secret\030\005 \001(\006\022-\n\006my_ips\030"
  "\006 \003(\0132\035.CMsgSteamNetworkingIPAddress\022\014\n\004"
  "echo\030\010 \001(\014\"\272\002\n.CMsgSteamDatagramGameserv"
  "erPingRequestEnvelope\0221\n\004cert\030\006 \001(\0132#.CM"
  "sgSteamDatagramCertificateSigned\022\023\n\013sign"
  "ed_data\030\007 \001(\014\022\021\n\tsignature\030\010 \001(\014\022\035\n\025lega"
  "cy_your_public_ip\030\001 \001(\007\022\037\n\027legacy_your_p"
  "ublic_port\030\005 \001(\007\022\036\n\026legacy_relay_unix_ti"
  "me\030\002 \001(\007\022\030\n\020legacy_challenge\030\003 \001(\006\022\037\n\027le"
  "gacy_router_timestamp\030\004 \001(\007\022\022\n\tdummy_pad"
  "\030\377\007 \001(\014\"\255\002\n(CMsgSteamDatagramGameserverP"
  "ingReplyData\022\034\n\024echo_relay_unix_time\030\002 \001"
  "(\007\022\014\n\004echo\030\010 \001(\014\022\030\n\020legacy_challenge\030\003 \001"
  "(\006\022\037\n\027legacy_router_timestamp\030\004 \001(\007\022\026\n\016d"
  "ata_center_id\030\005 \001(\007\022\r\n\005appid\030\006 \001(\r\022\030\n\020pr"
  "otocol_version\030\007 \001(\r\022\r\n\005build\030\t \001(\t\022\036\n\026n"
  "etwork_config_version\030\n \001(\004\022\024\n\014my_unix_t"
  "ime\030\013 \001(\007\022\024\n\014routing_blob\030\014 \001(\014\"\272\001\n\'CMsg"
  "SteamDatagramNoSessionRelayToClient\022\025\n\rc"
  "onnection_id\030\007 \001(\007\022\026\n\016your_public_ip\030\002 \001"
  "(\007\022\030\n\020your_public_port\030\006 \001(\007\022\023\n\013server_t"
  "ime\030\003 \001(\007\022\021\n\tchallenge\030\004 \001(\006\022\036\n\026seconds_"
  "until_shutdown\030\005 \001(\r\"\227\001\n%CMsgSteamDatagr"
  "amNoSessionRelayToPeer\022\037\n\027legacy_relay_s"
  "ession_id\030\001 \001(\r\022\035\n\025from_relay_session_id"
  "\030\002 \001(\007\022\032\n\022from_connection_id\030\007 \001(\007\022\022\n\nkl"
  "udge_pad\030c \001(\006\"L\n\020CMsgTOSTreatment\022\022\n\nl4"
  "s_detect\030\001 \001(\t\022\017\n\007up_ecn1\030\002 \001(\t\022\023\n\013down_"
  "dscp45\030\003 \001(\t\"A\n(CMsgSteamDatagramClientP"
  "ingSampleRequest\022\025\n\rconnection_id\030\001 \001(\007\""
  "\262\007\n&CMsgSteamDatagramClientPingSampleRep"
  "ly\022\025\n\rconnection_id\030\001 \001(\007\022\035\n\025relay_overr"
  "ide_active\030\005 \001(\010\022\036\n\003tos\030\006 \001(\0132\021.CMsgTOST"
  "reatment\0229\n\004pops\030\002 \003(\0132+.CMsgSteamDatagr"
  "amClientPingSampleReply.POP\022U\n\023legacy_da"
  "ta_centers\030\003 \003(\01328.CMsgSteamDatagramClie"
  "ntPingSampleReply.LegacyDataCenter\032\270\004\n\003P"
  "OP\022\016\n\006pop_id\030\001 \001(\007\022\035\n\025default_front_ping"
  "_ms\030\002 \001(\r\022\027\n\017cluster_penalty\030\004 \001(\r\022M\n\ral"
  "t_addresses\030\007 \003(\01326.CMsgSteamDatagramCli"
  "entPingSampleReply.POP.AltAddress\022\033\n\023def"
  "ault_e2e_ping_ms\030\003 \001(\r\022\031\n\021default_e2e_sc"
  "ore\030\005 \001(\r\022!\n\031p2p_via_peer_relay_pop_id\030\006"
  " \001(\007\022\027\n\017best_dc_ping_ms\030\t \001(\r\022\025\n\rbest_dc"
  "_score\030\n \001(\r\022 \n\030best_dc_via_relay_pop_id"
  "\030\013 \001(\007\022\032\n\022default_dc_ping_ms\030\014 \001(\r\022\030\n\020de"
  "fault_dc_score\030\r \001(\r\022#\n\033default_dc_via_r"
  "elay_pop_id\030\016 \001(\007\022\027\n\017test_dc_ping_ms\030\017 \001"
  "(\r\022\025\n\rtest_dc_score\030\020 \001(\r\022 \n\030test_dc_via"
  "_relay_pop_id\030\021 \001(\007\032@\n\nAltAddress\022\n\n\002id\030"
  "\001 \001(\t\022\025\n\rfront_ping_ms\030\002 \001(\r\022\017\n\007penalty\030"
  "\003 \001(\r\032e\n\020LegacyDataCenter\022\026\n\016data_center"
  "_id\030\001 \001(\007\022 \n\030best_dc_via_relay_pop_id\030\002 "
  "\001(\007\022\027\n\017best_dc_ping_ms\030\003 \001(\r\"\216\005\n&CMsgSte"
  "amDatagramClientSwitchedPrimary\022\025\n\rconne"
  "ction_id\030\001 \001(\007\022\017\n\007from_ip\030\002 \001(\007\022\021\n\tfrom_"
  "port\030\003 \001(\r\022\033\n\023from_router_cluster\030\004 \001(\007\022"
  "\030\n\020from_active_time\030\005 \001(\r\022 \n\030from_active"
  "_packets_recv\030\006 \001(\r\022\033\n\023from_dropped_reas"
  "on\030\007 \001(\t\022\016\n\006gap_ms\030\010 \001(\r\022O\n\020from_quality"
  "_now\030\t \001(\01325.CMsgSteamDatagramClientSwit"
  "chedPrimary.RouterQuality\022M\n\016to_quality_"
  "now\030\n \001(\01325.CMsgSteamDatagramClientSwitc"
  "hedPrimary.RouterQuality\022P\n\021from_quality"
  "_then\030\013 \001(\01325.CMsgSteamDatagramClientSwi"
  "tchedPrimary.RouterQuality\022N\n\017to_quality"
  "_then\030\014 \001(\01325.CMsgSteamDatagramClientSwi"
  "tchedPrimary.RouterQuality\032a\n\rRouterQual"
  "ity\022\r\n\005score\030\001 \001(\r\022\022\n\nfront_ping\030\002 \001(\r\022\021"
  "\n\tback_ping\030\003 \001(\r\022\032\n\022seconds_until_down\030"
  "\004 \001(\r\"\302\002\n\037CMsgSteamDatagramConnectReques"
  "t\022\025\n\rconnection_id\030\001 \001(\007\022\024\n\014my_timestamp"
  "\030\004 \001(\006\022\023\n\013ping_est_ms\030\005 \001(\r\022\024\n\014virtual_p"
  "ort\030\t \001(\r\022#\n\033gameserver_relay_session_id"
  "\030\002 \001(\r\0227\n\005crypt\030\006 \001(\0132(.CMsgSteamDatagra"
  "mSessionCryptInfoSigned\0221\n\004cert\030\007 \001(\0132#."
  "CMsgSteamDatagramCertificateSigned\022\026\n\016ro"
  "uting_secret\030\n \001(\006\022\036\n\026legacy_client_stea"
  "m_id\030\003 \001(\006\"\232\002\n\032CMsgSteamDatagramConnectO"
  "K\022\034\n\024client_connection_id\030\001 \001(\007\022\034\n\024serve"
  "r_connection_id\030\007 \001(\007\022\026\n\016your_timestamp\030"
  "\003 \001(\006\022\027\n\017delay_time_usec\030\004 \001(\r\022#\n\033gamese"
  "rver_relay_session_id\030\002 \001(\r\0227\n\005crypt\030\005 \001"
  "(\0132(.CMsgSteamDatagramSessionCryptInfoSi"
  "gned\0221\n\004cert\030\006 \001(\0132#.CMsgSteamDatagramCe"
  "rtificateSigned\"\256\003\n\'CMsgSteamNetworkingP"
  "2PSDRRoutingSummary\022\024\n\014initial_ping\030\001 \001("
  "\r\022 \n\030initial_ping_front_local\030\002 \001(\r\022!\n\031i"
  "nitial_ping_front_remote\030\003 \001(\r\022\025\n\rinitia"
  "l_score\030\004 \001(\r\022\031\n\021initial_pop_local\030\005 \001(\007"
  "\022\032\n\022initial_pop_remote\030\006 \001(\007\022\021\n\tbest_pin"
  "g\030\013 \001(\r\022\035\n\025best_ping_front_local\030\014 \001(\r\022\036"
  "\n\026best_ping_front_remote\030\r \001(\r\022\022\n\nbest_s"
  "core\030\016 \001(\r\022\026\n\016best_pop_local\030\017 \001(\007\022\027\n\017be"
  "st_pop_remote\030\020 \001(\007\022\021\n\tbest_time\030\021 \001(\r\022\026"
  "\n\016negotiation_ms\030\007 \001(\r\022\030\n\020selected_secon"
  "ds\030\010 \001(\r\"\217\001\n\"CMsgSteamDatagramP2PRouting"
  "Summary\0222\n\003ice\030\002 \001(\0132%.CMsgSteamNetworki"
  "ngICESessionSummary\0225\n\003sdr\030\003 \001(\0132(.CMsgS"
  "teamNetworkingP2PSDRRoutingSummary\"\351\006\n!C"
  "MsgSteamDatagramConnectionClosed\022\030\n\020to_c"
  "onnection_id\030\007 \001(\007\022\032\n\022from_connection_id"
  "\030\010 \001(\007\022\034\n\024from_identity_string\030\017 \001(\t\022M\n\033"
  "legacy_from_identity_binary\030\r \001(\0132(.CMsg"
  "SteamNetworkingIdentityLegacyBinary\022\034\n\024l"
  "egacy_from_steam_id\030\003 \001(\006\022*\n\"legacy_game"
  "server_relay_session_id\030\002 \001(\r\022\033\n\023to_rela"
  "y_session_id\030\t \001(\007\022\035\n\025from_relay_session"
  "_id\030\n \001(\007\022*\n\"forward_target_relay_routin"
  "g_token\030\013 \001(\014\022\037\n\027forward_target_revision"
  "\030\014 \001(\r\022G\n\nrelay_mode\030\004 \001(\0162-.CMsgSteamDa"
  "tagramConnectionClosed.ERelayMode:\004None\022"
  "\r\n\005debug\030\005 \001(\t\022\023\n\013reason_code\030\006 \001(\r\022\026\n\016r"
  "outing_secret\030\016 \001(\006\022\033\n\023not_primary_sessi"
  "on\030\020 \001(\010\022\035\n\025not_primary_transport\030\023 \001(\010\022"
  "\035\n\025relay_override_active\030\026 \001(\010\022:\n\rqualit"
  "y_relay\030\021 \001(\0132#.CMsgSteamDatagramConnect"
  "ionQuality\0228\n\013quality_e2e\030\022 \001(\0132#.CMsgSt"
  "eamDatagramConnectionQuality\022@\n\023p2p_rout"
  "ing_summary\030\025 \001(\0132#.CMsgSteamDatagramP2P"
  "RoutingSummary\"6\n\nERelayMode\022\010\n\004None\020\000\022\014"
  "\n\010EndToEnd\020\001\022\020\n\014ClosedByPeer\020\002\"\314\004\n\035CMsgS"
  "teamDatagramNoConnection\022\030\n\020to_connectio"
  "n_id\030\005 \001(\007\022\032\n\022from_connection_id\030\006 \001(\007\022*"
  "\n\"legacy_gameserver_relay_session_id\030\002 \001"
  "(\r\022\033\n\023to_relay_session_id\030\t \001(\007\022\035\n\025from_"
  "relay_session_id\030\n \001(\007\022\034\n\024from_identity_"
  "string\030\007 \001(\t\022\034\n\024legacy_from_steam_id\030\003 \001"
  "(\006\022\022\n\nend_to_end\030\004 \001(\010\022\033\n\023not_primary_se"
  "ssion\030\014 \001(\010\022\035\n\025not_primary_transport\030\017 \001"
  "(\010\022\035\n\025relay_override_active\030\021 \001(\010\022:\n\rqua"
  "lity_relay\030\r \001(\0132#.CMsgSteamDatagramConn"
  "ectionQuality\0228\n\013quality_e2e\030\016 \001(\0132#.CMs"
  "gSteamDatagramConnectionQuality\022@\n\023p2p_r"
  "outing_summary\030\020 \001(\0132#.CMsgSteamDatagram"
  "P2PRoutingSummary\022\026\n\016routing_secret\030\013 \001("
  "\006\022\022\n\tdummy_pad\030\377\007 \001(\007\"\334\002\n)CMsgSteamDatag"
  "ramGameserverSessionRequest\022\016\n\006ticket\030\001 "
  "\001(\014\022\026\n\016challenge_time\030\003 \001(\007\022\021\n\tchallenge"
  "\030\004 \001(\006\022\034\n\024client_connection_id\030\005 \001(\007\022\034\n\024"
  "server_connection_id\030\010 \001(\007\022\036\n\026network_co"
  "nfig_version\030\006 \001(\004\022\030\n\020protocol_version\030\007"
  " \001(\r\022\020\n\010platform\030\t \001(\t\022\r\n\005build\030\n \001(\t\022\037\n"
  "\027dev_gameserver_identity\030d \001(\t\022<\n\017dev_cl"
  "ient_cert\030e \001(\0132#.CMsgSteamDatagramCerti"
  "ficateSigned\"\350\001\n-CMsgSteamDatagramGamese"
  "rverSessionEstablished\022\025\n\rconnection_id\030"
  "\001 \001(\007\022\"\n\032gameserver_identity_string\030\002 \001("
  "\t\022\036\n\026seconds_until_shutdown\030\004 \001(\r\022\023\n\013seq"
  "_num_r2c\030\006 \001(\r\022$\n\034dummy_legacy_identity_"
  "binary\030\007 \001(\014\022!\n\031legacy_gameserver_steami"
  "d\030\003 \001(\006\"\255\003\n.CMsgSteamDatagramConnectionS"
  "tatsClientToRouter\022:\n\rquality_relay\030\001 \001("
  "\0132#.CMsgSteamDatagramConnectionQuality\0228"
  "\n\013quality_e2e\030\002 \001(\0132#.CMsgSteamDatagramC"
  "onnectionQuality\022\021\n\tack_relay\030\004 \003(\007\022\026\n\016l"
  "egacy_ack_e2e\030\005 \003(\007\022\r\n\005flags\030\006 \001(\r\022\034\n\024cl"
  "ient_connection_id\030\010 \001(\007\022\023\n\013seq_num_c2r\030"
  "\t \001(\r\022\023\n\013seq_num_e2e\030\n \001(\r\"\202\001\n\005Flags\022\025\n\021"
  "ACK_REQUEST_RELAY\020\001\022\023\n\017ACK_REQUEST_E2E\020\002"
  "\022\031\n\025ACK_REQUEST_IMMEDIATE\020\004\022\027\n\023NOT_PRIMA"
  "RY_SESSION\020\010\022\031\n\025CLIENT_RELAY_OVERRIDE\020 \""
  "\371\003\n.CMsgSteamDatagramConnectionStatsRout"
  "erToClient\022:\n\rquality_relay\030\001 \001(\0132#.CMsg"
  "SteamDatagramConnectionQuality\0228\n\013qualit"
  "y_e2e\030\002 \001(\0132#.CMsgSteamDatagramConnectio"
  "nQuality\022\036\n\026seconds_until_shutdown\030\006 \001(\r"
  "\022\032\n\022migrate_request_ip\030\n \001(\007\022\034\n\024migrate_"
  "request_port\030\013 \001(\r\022%\n\035scoring_penalty_re"
  "lay_cluster\030\014 \001(\r\022\021\n\tack_relay\030\r \003(\007\022\026\n\016"
  "legacy_ack_e2e\030\016 \003(\007\022\r\n\005flags\030\017 \001(\r\022\034\n\024c"
  "lient_connection_id\030\007 \001(\007\022\023\n\013seq_num_r2c"
  "\030\010 \001(\r\022\023\n\013seq_num_e2e\030\t \001(\r\"N\n\005Flags\022\025\n\021"
  "ACK_REQUEST_RELAY\020\001\022\023\n\017ACK_REQUEST_E2E\020\002"
  "\022\031\n\025ACK_REQUEST_IMMEDIATE\020\004\"\210\004\n.CMsgStea"
  "mDatagramConnectionStatsRouterToServer\022:"
  "\n\rquality_relay\030\001 \001(\0132#.CMsgSteamDatagra"
  "mConnectionQuality\0228\n\013quality_e2e\030\002 \001(\0132"
  "#.CMsgSteamDatagramConnectionQuality\022\021\n\t"
  "ack_relay\030\n \003(\007\022\026\n\016legacy_ack_e2e\030\013 \003(\007\022"
  "\r\n\005flags\030\014 \001(\r\022\023\n\013seq_num_r2s\030\005 \001(\r\022\023\n\013s"
  "eq_num_e2e\030\006 \001(\r\022\036\n\026client_identity_stri"
  "ng\030\017 \001(\t\022\036\n\026legacy_client_steam_id\030\007 \001(\006"
  "\022\030\n\020relay_session_id\030\010 \001(\r\022\034\n\024client_con"
  "nection_id\030\t \001(\007\022\034\n\024server_connection_id"
  "\030\r \001(\007\022\026\n\016routing_secret\030\016 \001(\006\"N\n\005Flags\022"
  "\025\n\021ACK_REQUEST_RELAY\020\001\022\023\n\017ACK_REQUEST_E2"
  "E\020\002\022\031\n\025ACK_REQUEST_IMMEDIATE\020\004\"\260\003\n.CMsgS"
  "teamDatagramConnectionStatsServerToRoute"
  "r\022:\n\rquality_relay\030\001 \001(\0132#.CMsgSteamData"
  "gramConnectionQuality\0228\n\013quality_e2e\030\002 \001"
  "(\0132#.CMsgSteamDatagramConnectionQuality\022"
  "\021\n\tack_relay\030\010 \003(\007\022\026\n\016legacy_ack_e2e\030\t \003"
  "(\007\022\r\n\005flags\030\n \001(\r\022\023\n\013seq_num_s2r\030\003 \001(\r\022\023"
  "\n\013seq_num_e2e\030\004 \001(\r\022\030\n\020relay_session_id\030"
  "\006 \001(\r\022\034\n\024client_connection_id\030\007 \001(\007\022\034\n\024s"
  "erver_connection_id\030\013 \001(\007\"N\n\005Flags\022\025\n\021AC"
  "K_REQUEST_RELAY\020\001\022\023\n\017ACK_REQUEST_E2E\020\002\022\031"
  "\n\025ACK_REQUEST_IMMEDIATE\020\004\"\305\003\n&CMsgSteamD"
  "atagramP2PSessionRequestBody\022\026\n\016challeng"
  "e_time\030\001 \001(\007\022\021\n\tchallenge\030\002 \001(\006\022\034\n\024clien"
  "t_connection_id\030\003 \001(\007\022\034\n\024legacy_peer_ste"
  "am_id\030\004 \001(\006\022\034\n\024peer_identity_string\030\013 \001("
  "\t\022\032\n\022peer_connection_id\030\005 \001(\007\022\026\n\016encrypt"
  "ed_data\030\016 \001(\014\022,\n$encryption_your_public_"
  "key_lead_byte\030\017 \001(\r\022*\n\"encryption_my_eph"
  "emeral_public_key\030\020 \001(\014\022\030\n\020protocol_vers"
  "ion\030\010 \001(\r\022\036\n\026network_config_version\030\t \001("
  "\004\022\020\n\010platform\030\014 \001(\t\022\r\n\005build\030\r \001(\t\032-\n\rEn"
  "cryptedData\022\034\n\024peer_identity_string\030\001 \001("
  "\t\"x\n\"CMsgSteamDatagramP2PSessionRequest\022"
  "1\n\004cert\030\001 \001(\0132#.CMsgSteamDatagramCertifi"
  "cateSigned\022\014\n\004body\030\002 \001(\014\022\021\n\tsignature\030\003 "
  "\001(\014\"\221\001\n&CMsgSteamDatagramP2PSessionEstab"
  "lished\022\025\n\rconnection_id\030\001 \001(\007\022\036\n\026seconds"
  "_until_shutdown\030\003 \001(\r\022\033\n\023relay_routing_t"
  "oken\030\004 \001(\014\022\023\n\013seq_num_r2c\030\005 \001(\r\"\211\005\n1CMsg"
  "SteamDatagramConnectionStatsP2PClientToR"
  "outer\022:\n\rquality_relay\030\001 \001(\0132#.CMsgSteam"
  "DatagramConnectionQuality\0228\n\013quality_e2e"
  "\030\002 \001(\0132#.CMsgSteamDatagramConnectionQual"
  "ity\022@\n\023p2p_routing_summary\030\016 \001(\0132#.CMsgS"
  "teamDatagramP2PRoutingSummary\022\021\n\tack_rel"
  "ay\030\003 \003(\007\022\026\n\016legacy_ack_e2e\030\004 \003(\007\022\r\n\005flag"
  "s\030\005 \001(\r\022*\n\"forward_target_relay_routing_"
  "token\030\006 \001(\014\022\037\n\027forward_target_revision\030\007"
  " \001(\r\022\016\n\006routes\030\010 \001(\014\022 \n\030ack_peer_routes_"
  "revision\030\t \001(\r\022\025\n\rconnection_id\030\n \001(\007\022\023\n"
  "\013seq_num_c2r\030\013 \001(\r\022\023\n\013seq_num_e2e\030\014 \001(\r\""
  "\241\001\n\005Flags\022\025\n\021ACK_REQUEST_RELAY\020\001\022\023\n\017ACK_"
  "REQUEST_E2E\020\002\022\031\n\025ACK_REQUEST_IMMEDIATE\020\004"
  "\022\027\n\023NOT_PRIMARY_SESSION\020\010\022\035\n\031NOT_PRIMARY"
  "_TRANSPORT_E2E\020\020\022\031\n\025CLIENT_RELAY_OVERRID"
  "E\020 \"\353\004\n1CMsgSteamDatagramConnectionStats"
  "P2PRouterToClient\022:\n\rquality_relay\030\001 \001(\013"
  "2#.CMsgSteamDatagramConnectionQuality\0228\n"
  "\013quality_e2e\030\002 \001(\0132#.CMsgSteamDatagramCo"
  "nnectionQuality\022\036\n\026seconds_until_shutdow"
  "n\030\003 \001(\r\022\032\n\022migrate_request_ip\030\004 \001(\007\022\034\n\024m"
  "igrate_request_port\030\005 \001(\r\022%\n\035scoring_pen"
  "alty_relay_cluster\030\006 \001(\r\022\021\n\tack_relay\030\007 "
  "\003(\007\022\026\n\016legacy_ack_e2e\030\010 \003(\007\022\r\n\005flags\030\t \001"
  "(\r\022#\n\033ack_forward_target_revision\030\n \001(\r\022"
  "\016\n\006routes\030\013 \001(\014\022 \n\030ack_peer_routes_revis"
  "ion\030\014 \001(\r\022\025\n\rconnection_id\030\r \001(\007\022\023\n\013seq_"
  "num_r2c\030\016 \001(\r\022\023\n\013seq_num_e2e\030\017 \001(\r\"m\n\005Fl"
  "ags\022\025\n\021ACK_REQUEST_RELAY\020\001\022\023\n\017ACK_REQUES"
  "T_E2E\020\002\022\031\n\025ACK_REQUEST_IMMEDIATE\020\004\022\035\n\031NO"
  "T_PRIMARY_TRANSPORT_E2E\020\020\"\240\001\n*CMsgSteamD"
  "atagramP2PBadRouteRouterToClient\022\025\n\rconn"
  "ection_id\030\001 \001(\007\022\"\n\032failed_relay_routing_"
  "token\030\002 \001(\014\022#\n\033ack_forward_target_revisi"
  "on\030\003 \001(\r\022\022\n\nkludge_pad\030c \001(\006\"\357\002\n\032CMsgSte"
  "amDatagramP2PRoutes\022@\n\016relay_clusters\030\001 "
  "\003(\0132(.CMsgSteamDatagramP2PRoutes.RelayCl"
  "uster\0221\n\006routes\030\002 \003(\0132!.CMsgSteamDatagra"
  "mP2PRoutes.Route\022\020\n\010revision\030\003 \001(\r\032k\n\014Re"
  "layCluster\022\016\n\006pop_id\030\001 \001(\007\022\017\n\007ping_ms\030\002 "
  "\001(\r\022\025\n\rscore_penalty\030\003 \001(\r\022#\n\033session_re"
  "lay_routing_token\030\004 \001(\014\032]\n\005Route\022\021\n\tmy_p"
  "op_id\030\001 \001(\007\022\023\n\013your_pop_id\030\002 \001(\007\022\024\n\014lega"
  "cy_score\030\003 \001(\r\022\026\n\016interior_score\030\004 \001(\r\"\314"
  "\001\n+CMsgSteamDatagramSetSecondaryAddressR"
  "equest\022\026\n\016client_main_ip\030\001 \001(\007\022\030\n\020client"
  "_main_port\030\002 \001(\007\022\034\n\024client_connection_id"
  "\030\003 \001(\007\022\027\n\017client_identity\030\004 \001(\t\022 \n\030reque"
  "st_send_duplication\030\005 \001(\010\022\022\n\nkludge_pad\030"
  "c \001(\014\"N\n*CMsgSteamDatagramSetSecondaryAd"
  "dressResult\022\017\n\007success\030\001 \001(\010\022\017\n\007message\030"
  "\002 \001(\t*\340\013\n\023ESteamDatagramMsgID\022\037\n\033k_EStea"
  "mDatagramMsg_Invalid\020\000\022)\n%k_ESteamDatagr"
  "amMsg_RouterPingRequest\020\001\022\'\n#k_ESteamDat"
  "agramMsg_RouterPingReply\020\002\022-\n)k_ESteamDa"
  "tagramMsg_GameserverPingRequest\020\003\0220\n,k_E"
  "SteamDatagramMsg_GameserverSessionReques"
  "t\020\005\0224\n0k_ESteamDatagramMsg_GameserverSes"
  "sionEstablished\020\006\022!\n\035k_ESteamDatagramMsg"
  "_NoSession\020\007\022\"\n\036k_ESteamDatagramMsg_Diag"
  "nostic\020\010\022*\n&k_ESteamDatagramMsg_DataClie"
  "ntToRouter\020\t\022*\n&k_ESteamDatagramMsg_Data"
  "RouterToServer\020\n\022*\n&k_ESteamDatagramMsg_"
  "DataServerToRouter\020\013\022*\n&k_ESteamDatagram"
  "Msg_DataRouterToClient\020\014\022\035\n\031k_ESteamData"
  "gramMsg_Stats\020\r\022/\n+k_ESteamDatagramMsg_C"
  "lientPingSampleRequest\020\016\022-\n)k_ESteamData"
  "gramMsg_ClientPingSampleReply\020\017\0225\n1k_ESt"
  "eamDatagramMsg_ClientToRouterSwitchedPri"
  "mary\020\020\022#\n\037k_ESteamDatagramMsg_RelayHealt"
  "h\020\021\022&\n\"k_ESteamDatagramMsg_ConnectReques"
  "t\020\022\022!\n\035k_ESteamDatagramMsg_ConnectOK\020\023\022("
  "\n$k_ESteamDatagramMsg_ConnectionClosed\020\024"
  "\022$\n k_ESteamDatagramMsg_NoConnection\020\025\022,"
  "\n(k_ESteamDatagramMsg_TicketDecryptReque"
  "st\020\026\022*\n&k_ESteamDatagramMsg_TicketDecryp"
  "tReply\020\027\022)\n%k_ESteamDatagramMsg_P2PSessi"
  "onRequest\020\030\022-\n)k_ESteamDatagramMsg_P2PSe"
  "ssionEstablished\020\031\022&\n\"k_ESteamDatagramMs"
  "g_P2PStatsClient\020\032\022%\n!k_ESteamDatagramMs"
  "g_P2PStatsRelay\020\033\022#\n\037k_ESteamDatagramMsg"
  "_P2PBadRoute\020\034\022+\n\'k_ESteamDatagramMsg_Ga"
  "meserverPingReply\020\035\0224\n0k_ESteamDatagramM"
  "sg_LegacyGameserverRegistration\020\036\0222\n.k_E"
  "SteamDatagramMsg_SetSecondaryAddressRequ"
  "est\020\037\0221\n-k_ESteamDatagramMsg_SetSecondar"
  "yAddressResult\020 \022/\n+k_ESteamDatagramMsg_"
  "RelayToRelayPingRequest\020!\022-\n)k_ESteamDat"
  "agramMsg_RelayToRelayPingReply\020\"B\005H\001\200\001\000"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_deps[2] = {
  &::descriptor_table_steamnetworkingsockets_5fmessages_2eproto,
  &::descriptor_table_steamnetworkingsockets_5fmessages_5fcerts_2eproto,
};
static ::_pbi::once_flag descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto = {
    false, false, 13799, descriptor_table_protodef_steamdatagram_5fmessages_5fsdr_2eproto,
    "steamdatagram_messages_sdr.proto",
    &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once, descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_deps, 2, 42,
    schemas, file_default_instances, TableStruct_steamdatagram_5fmessages_5fsdr_2eproto::offsets,
    file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto, file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto,
    file_level_service_descriptors_steamdatagram_5fmessages_5fsdr_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter() {
  return &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_steamdatagram_5fmessages_5fsdr_2eproto(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramRouterPingReply_AltAddress_Protocol_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[0];
}
bool CMsgSteamDatagramRouterPingReply_AltAddress_Protocol_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramRouterPingReply_AltAddress_Protocol CMsgSteamDatagramRouterPingReply_AltAddress::DefaultProtocol;
constexpr CMsgSteamDatagramRouterPingReply_AltAddress_Protocol CMsgSteamDatagramRouterPingReply_AltAddress::Protocol_MIN;
constexpr CMsgSteamDatagramRouterPingReply_AltAddress_Protocol CMsgSteamDatagramRouterPingReply_AltAddress::Protocol_MAX;
constexpr int CMsgSteamDatagramRouterPingReply_AltAddress::Protocol_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramRouterPingReply_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[1];
}
bool CMsgSteamDatagramRouterPingReply_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramRouterPingReply_Flags CMsgSteamDatagramRouterPingReply::FLAG_MAYBE_MORE_DATA_CENTERS;
constexpr CMsgSteamDatagramRouterPingReply_Flags CMsgSteamDatagramRouterPingReply::FLAG_MAYBE_MORE_ALT_ADDRESSES;
constexpr CMsgSteamDatagramRouterPingReply_Flags CMsgSteamDatagramRouterPingReply::Flags_MIN;
constexpr CMsgSteamDatagramRouterPingReply_Flags CMsgSteamDatagramRouterPingReply::Flags_MAX;
constexpr int CMsgSteamDatagramRouterPingReply::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionClosed_ERelayMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[2];
}
bool CMsgSteamDatagramConnectionClosed_ERelayMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionClosed_ERelayMode CMsgSteamDatagramConnectionClosed::None;
constexpr CMsgSteamDatagramConnectionClosed_ERelayMode CMsgSteamDatagramConnectionClosed::EndToEnd;
constexpr CMsgSteamDatagramConnectionClosed_ERelayMode CMsgSteamDatagramConnectionClosed::ClosedByPeer;
constexpr CMsgSteamDatagramConnectionClosed_ERelayMode CMsgSteamDatagramConnectionClosed::ERelayMode_MIN;
constexpr CMsgSteamDatagramConnectionClosed_ERelayMode CMsgSteamDatagramConnectionClosed::ERelayMode_MAX;
constexpr int CMsgSteamDatagramConnectionClosed::ERelayMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsClientToRouter_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[3];
}
bool CMsgSteamDatagramConnectionStatsClientToRouter_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 32:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::NOT_PRIMARY_SESSION;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::CLIENT_RELAY_OVERRIDE;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsClientToRouter_Flags CMsgSteamDatagramConnectionStatsClientToRouter::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsClientToRouter::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsRouterToClient_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[4];
}
bool CMsgSteamDatagramConnectionStatsRouterToClient_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsRouterToClient_Flags CMsgSteamDatagramConnectionStatsRouterToClient::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsRouterToClient_Flags CMsgSteamDatagramConnectionStatsRouterToClient::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsRouterToClient_Flags CMsgSteamDatagramConnectionStatsRouterToClient::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsRouterToClient_Flags CMsgSteamDatagramConnectionStatsRouterToClient::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsRouterToClient_Flags CMsgSteamDatagramConnectionStatsRouterToClient::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsRouterToClient::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsRouterToServer_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[5];
}
bool CMsgSteamDatagramConnectionStatsRouterToServer_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsRouterToServer_Flags CMsgSteamDatagramConnectionStatsRouterToServer::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsRouterToServer_Flags CMsgSteamDatagramConnectionStatsRouterToServer::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsRouterToServer_Flags CMsgSteamDatagramConnectionStatsRouterToServer::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsRouterToServer_Flags CMsgSteamDatagramConnectionStatsRouterToServer::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsRouterToServer_Flags CMsgSteamDatagramConnectionStatsRouterToServer::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsRouterToServer::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsServerToRouter_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[6];
}
bool CMsgSteamDatagramConnectionStatsServerToRouter_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsServerToRouter_Flags CMsgSteamDatagramConnectionStatsServerToRouter::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsServerToRouter_Flags CMsgSteamDatagramConnectionStatsServerToRouter::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsServerToRouter_Flags CMsgSteamDatagramConnectionStatsServerToRouter::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsServerToRouter_Flags CMsgSteamDatagramConnectionStatsServerToRouter::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsServerToRouter_Flags CMsgSteamDatagramConnectionStatsServerToRouter::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsServerToRouter::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[7];
}
bool CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::NOT_PRIMARY_SESSION;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::NOT_PRIMARY_TRANSPORT_E2E;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::CLIENT_RELAY_OVERRIDE;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags CMsgSteamDatagramConnectionStatsP2PClientToRouter::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsP2PClientToRouter::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[8];
}
bool CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 16:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::ACK_REQUEST_RELAY;
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::ACK_REQUEST_E2E;
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::ACK_REQUEST_IMMEDIATE;
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::NOT_PRIMARY_TRANSPORT_E2E;
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::Flags_MIN;
constexpr CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags CMsgSteamDatagramConnectionStatsP2PRouterToClient::Flags_MAX;
constexpr int CMsgSteamDatagramConnectionStatsP2PRouterToClient::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDatagramMsgID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto);
  return file_level_enum_descriptors_steamdatagram_5fmessages_5fsdr_2eproto[9];
}
bool ESteamDatagramMsgID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgSteamNetworkingIPAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamNetworkingIPAddress>()._impl_._has_bits_);
  static void set_has_v4(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_v6(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamNetworkingIPAddress::CMsgSteamNetworkingIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamNetworkingIPAddress)
}
CMsgSteamNetworkingIPAddress::CMsgSteamNetworkingIPAddress(const CMsgSteamNetworkingIPAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamNetworkingIPAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v6_){}
    , decltype(_impl_.v4_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.v6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.v6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_v6()) {
    _this->_impl_.v6_.Set(from._internal_v6(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.v4_ = from._impl_.v4_;
  // @@protoc_insertion_point(copy_constructor:CMsgSteamNetworkingIPAddress)
}

inline void CMsgSteamNetworkingIPAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v6_){}
    , decltype(_impl_.v4_){0u}
  };
  _impl_.v6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.v6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamNetworkingIPAddress::~CMsgSteamNetworkingIPAddress() {
  // @@protoc_insertion_point(destructor:CMsgSteamNetworkingIPAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamNetworkingIPAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v6_.Destroy();
}

void CMsgSteamNetworkingIPAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamNetworkingIPAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamNetworkingIPAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.v6_.ClearNonDefaultToEmpty();
  }
  _impl_.v4_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamNetworkingIPAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 v4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_v4(&has_bits);
          _impl_.v4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes v6 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_v6();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamNetworkingIPAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamNetworkingIPAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 v4 = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_v4(), target);
  }

  // optional bytes v6 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_v6(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamNetworkingIPAddress)
  return target;
}

size_t CMsgSteamNetworkingIPAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamNetworkingIPAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes v6 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_v6());
    }

    // optional fixed32 v4 = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamNetworkingIPAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamNetworkingIPAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamNetworkingIPAddress::GetClassData() const { return &_class_data_; }


void CMsgSteamNetworkingIPAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamNetworkingIPAddress*>(&to_msg);
  auto& from = static_cast<const CMsgSteamNetworkingIPAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamNetworkingIPAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_v6(from._internal_v6());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.v4_ = from._impl_.v4_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamNetworkingIPAddress::CopyFrom(const CMsgSteamNetworkingIPAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamNetworkingIPAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamNetworkingIPAddress::IsInitialized() const {
  return true;
}

void CMsgSteamNetworkingIPAddress::InternalSwap(CMsgSteamNetworkingIPAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.v6_, lhs_arena,
      &other->_impl_.v6_, rhs_arena
  );
  swap(_impl_.v4_, other->_impl_.v4_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamNetworkingIPAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[0]);
}

// ===================================================================

class CMsgSteamDatagramSignedMessageGeneric::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramSignedMessageGeneric>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramCertificateSigned& cert(const CMsgSteamDatagramSignedMessageGeneric* msg);
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dummy_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramSignedMessageGeneric::_Internal::cert(const CMsgSteamDatagramSignedMessageGeneric* msg) {
  return *msg->_impl_.cert_;
}
void CMsgSteamDatagramSignedMessageGeneric::clear_cert() {
  if (_impl_.cert_ != nullptr) _impl_.cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgSteamDatagramSignedMessageGeneric::CMsgSteamDatagramSignedMessageGeneric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramSignedMessageGeneric)
}
CMsgSteamDatagramSignedMessageGeneric::CMsgSteamDatagramSignedMessageGeneric(const CMsgSteamDatagramSignedMessageGeneric& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramSignedMessageGeneric* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.cert_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signed_data()) {
    _this->_impl_.signed_data_.Set(from._internal_signed_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dummy_pad()) {
    _this->_impl_.dummy_pad_.Set(from._internal_dummy_pad(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cert()) {
    _this->_impl_.cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.cert_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramSignedMessageGeneric)
}

inline void CMsgSteamDatagramSignedMessageGeneric::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.cert_){nullptr}
  };
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramSignedMessageGeneric::~CMsgSteamDatagramSignedMessageGeneric() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramSignedMessageGeneric)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramSignedMessageGeneric::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signed_data_.Destroy();
  _impl_.signature_.Destroy();
  _impl_.dummy_pad_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cert_;
}

void CMsgSteamDatagramSignedMessageGeneric::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramSignedMessageGeneric::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramSignedMessageGeneric)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signed_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.dummy_pad_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cert_ != nullptr);
      _impl_.cert_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramSignedMessageGeneric::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramCertificateSigned cert = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signed_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signed_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dummy_pad = 1023;
      case 1023:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_dummy_pad();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramSignedMessageGeneric::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramSignedMessageGeneric)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramCertificateSigned cert = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cert(this),
        _Internal::cert(this).GetCachedSize(), target, stream);
  }

  // optional bytes signed_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signed_data(), target);
  }

  // optional bytes signature = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  // optional bytes dummy_pad = 1023;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        1023, this->_internal_dummy_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramSignedMessageGeneric)
  return target;
}

size_t CMsgSteamDatagramSignedMessageGeneric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramSignedMessageGeneric)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes signed_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signed_data());
    }

    // optional bytes signature = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional bytes dummy_pad = 1023;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dummy_pad());
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramSignedMessageGeneric::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramSignedMessageGeneric::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramSignedMessageGeneric::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramSignedMessageGeneric::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramSignedMessageGeneric*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramSignedMessageGeneric&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramSignedMessageGeneric)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signed_data(from._internal_signed_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_dummy_pad(from._internal_dummy_pad());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_cert());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramSignedMessageGeneric::CopyFrom(const CMsgSteamDatagramSignedMessageGeneric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramSignedMessageGeneric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramSignedMessageGeneric::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramSignedMessageGeneric::InternalSwap(CMsgSteamDatagramSignedMessageGeneric* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signed_data_, lhs_arena,
      &other->_impl_.signed_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dummy_pad_, lhs_arena,
      &other->_impl_.dummy_pad_, rhs_arena
  );
  swap(_impl_.cert_, other->_impl_.cert_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramSignedMessageGeneric::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[1]);
}

// ===================================================================

class CMsgSteamDatagramRouterPingReply_RouteException::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramRouterPingReply_RouteException>()._impl_._has_bits_);
  static void set_has_data_center_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramRouterPingReply_RouteException::CMsgSteamDatagramRouterPingReply_RouteException(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramRouterPingReply.RouteException)
}
CMsgSteamDatagramRouterPingReply_RouteException::CMsgSteamDatagramRouterPingReply_RouteException(const CMsgSteamDatagramRouterPingReply_RouteException& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramRouterPingReply_RouteException* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_center_id_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.penalty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.data_center_id_, &from._impl_.data_center_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.penalty_) -
    reinterpret_cast<char*>(&_impl_.data_center_id_)) + sizeof(_impl_.penalty_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramRouterPingReply.RouteException)
}

inline void CMsgSteamDatagramRouterPingReply_RouteException::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_center_id_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.penalty_){0u}
  };
}

CMsgSteamDatagramRouterPingReply_RouteException::~CMsgSteamDatagramRouterPingReply_RouteException() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramRouterPingReply.RouteException)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramRouterPingReply_RouteException::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramRouterPingReply_RouteException::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramRouterPingReply_RouteException::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramRouterPingReply.RouteException)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.data_center_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.penalty_) -
        reinterpret_cast<char*>(&_impl_.data_center_id_)) + sizeof(_impl_.penalty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramRouterPingReply_RouteException::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 data_center_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_data_center_id(&has_bits);
          _impl_.data_center_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 penalty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_penalty(&has_bits);
          _impl_.penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramRouterPingReply_RouteException::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramRouterPingReply.RouteException)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 data_center_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_data_center_id(), target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flags(), target);
  }

  // optional uint32 penalty = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_penalty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramRouterPingReply.RouteException)
  return target;
}

size_t CMsgSteamDatagramRouterPingReply_RouteException::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramRouterPingReply.RouteException)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed32 data_center_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 penalty = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_penalty());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramRouterPingReply_RouteException::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramRouterPingReply_RouteException::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramRouterPingReply_RouteException::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramRouterPingReply_RouteException::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramRouterPingReply_RouteException*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramRouterPingReply_RouteException&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramRouterPingReply.RouteException)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.data_center_id_ = from._impl_.data_center_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.penalty_ = from._impl_.penalty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramRouterPingReply_RouteException::CopyFrom(const CMsgSteamDatagramRouterPingReply_RouteException& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramRouterPingReply.RouteException)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramRouterPingReply_RouteException::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramRouterPingReply_RouteException::InternalSwap(CMsgSteamDatagramRouterPingReply_RouteException* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply_RouteException, _impl_.penalty_)
      + sizeof(CMsgSteamDatagramRouterPingReply_RouteException::_impl_.penalty_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply_RouteException, _impl_.data_center_id_)>(
          reinterpret_cast<char*>(&_impl_.data_center_id_),
          reinterpret_cast<char*>(&other->_impl_.data_center_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramRouterPingReply_RouteException::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[2]);
}

// ===================================================================

class CMsgSteamDatagramRouterPingReply_AltAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramRouterPingReply_AltAddress>()._impl_._has_bits_);
  static void set_has_ipv4(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramRouterPingReply_AltAddress::CMsgSteamDatagramRouterPingReply_AltAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramRouterPingReply.AltAddress)
}
CMsgSteamDatagramRouterPingReply_AltAddress::CMsgSteamDatagramRouterPingReply_AltAddress(const CMsgSteamDatagramRouterPingReply_AltAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramRouterPingReply_AltAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.ipv4_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.penalty_){}
    , decltype(_impl_.protocol_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ipv4_, &from._impl_.ipv4_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.protocol_) -
    reinterpret_cast<char*>(&_impl_.ipv4_)) + sizeof(_impl_.protocol_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramRouterPingReply.AltAddress)
}

inline void CMsgSteamDatagramRouterPingReply_AltAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.ipv4_){0u}
    , decltype(_impl_.port_){0u}
    , decltype(_impl_.penalty_){0u}
    , decltype(_impl_.protocol_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramRouterPingReply_AltAddress::~CMsgSteamDatagramRouterPingReply_AltAddress() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramRouterPingReply.AltAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramRouterPingReply_AltAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void CMsgSteamDatagramRouterPingReply_AltAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramRouterPingReply_AltAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramRouterPingReply.AltAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.ipv4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.protocol_) -
        reinterpret_cast<char*>(&_impl_.ipv4_)) + sizeof(_impl_.protocol_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramRouterPingReply_AltAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 ipv4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_ipv4(&has_bits);
          _impl_.ipv4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 penalty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_penalty(&has_bits);
          _impl_.penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4 [default = DefaultProtocol];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgSteamDatagramRouterPingReply_AltAddress_Protocol_IsValid(val))) {
            _internal_set_protocol(static_cast<::CMsgSteamDatagramRouterPingReply_AltAddress_Protocol>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramRouterPingReply.AltAddress.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramRouterPingReply_AltAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramRouterPingReply.AltAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 ipv4 = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_ipv4(), target);
  }

  // optional uint32 port = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  // optional uint32 penalty = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_penalty(), target);
  }

  // optional .CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4 [default = DefaultProtocol];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_protocol(), target);
  }

  // optional string id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramRouterPingReply.AltAddress.id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramRouterPingReply.AltAddress)
  return target;
}

size_t CMsgSteamDatagramRouterPingReply_AltAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramRouterPingReply.AltAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional fixed32 ipv4 = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 port = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
    }

    // optional uint32 penalty = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_penalty());
    }

    // optional .CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4 [default = DefaultProtocol];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_protocol());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramRouterPingReply_AltAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramRouterPingReply_AltAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramRouterPingReply_AltAddress::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramRouterPingReply_AltAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramRouterPingReply_AltAddress*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramRouterPingReply_AltAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramRouterPingReply.AltAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ipv4_ = from._impl_.ipv4_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.penalty_ = from._impl_.penalty_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.protocol_ = from._impl_.protocol_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramRouterPingReply_AltAddress::CopyFrom(const CMsgSteamDatagramRouterPingReply_AltAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramRouterPingReply.AltAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramRouterPingReply_AltAddress::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramRouterPingReply_AltAddress::InternalSwap(CMsgSteamDatagramRouterPingReply_AltAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.protocol_)
      + sizeof(CMsgSteamDatagramRouterPingReply_AltAddress::_impl_.protocol_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply_AltAddress, _impl_.ipv4_)>(
          reinterpret_cast<char*>(&_impl_.ipv4_),
          reinterpret_cast<char*>(&other->_impl_.ipv4_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramRouterPingReply_AltAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[3]);
}

// ===================================================================

class CMsgSteamDatagramRouterPingReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramRouterPingReply>()._impl_._has_bits_);
  static void set_has_client_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_your_public_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_your_public_port(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_server_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_cookie(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_recv_tos(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_echo_sent_tos(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_sent_tos(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_echo_request_reply_tos(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_scoring_penalty_relay_cluster(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dummy_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dummy_varint(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

CMsgSteamDatagramRouterPingReply::CMsgSteamDatagramRouterPingReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramRouterPingReply)
}
CMsgSteamDatagramRouterPingReply::CMsgSteamDatagramRouterPingReply(const CMsgSteamDatagramRouterPingReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramRouterPingReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latency_datacenter_ids_){from._impl_.latency_datacenter_ids_}
    , decltype(_impl_.latency_ping_ms_){from._impl_.latency_ping_ms_}
    , /*decltype(_impl_._latency_ping_ms_cached_byte_size_)*/{0}
    , decltype(_impl_.route_exceptions_){from._impl_.route_exceptions_}
    , decltype(_impl_.alt_addresses_){from._impl_.alt_addresses_}
    , decltype(_impl_.latency_datacenter_ids_p2p_){from._impl_.latency_datacenter_ids_p2p_}
    , decltype(_impl_.latency_ping_ms_p2p_){from._impl_.latency_ping_ms_p2p_}
    , /*decltype(_impl_._latency_ping_ms_p2p_cached_byte_size_)*/{0}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.client_timestamp_){}
    , decltype(_impl_.your_public_ip_){}
    , decltype(_impl_.challenge_){}
    , decltype(_impl_.server_time_){}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.client_cookie_){}
    , decltype(_impl_.scoring_penalty_relay_cluster_){}
    , decltype(_impl_.your_public_port_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.recv_tos_){}
    , decltype(_impl_.echo_sent_tos_){}
    , decltype(_impl_.sent_tos_){}
    , decltype(_impl_.echo_request_reply_tos_){}
    , decltype(_impl_.dummy_varint_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dummy_pad()) {
    _this->_impl_.dummy_pad_.Set(from._internal_dummy_pad(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.client_timestamp_, &from._impl_.client_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dummy_varint_) -
    reinterpret_cast<char*>(&_impl_.client_timestamp_)) + sizeof(_impl_.dummy_varint_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramRouterPingReply)
}

inline void CMsgSteamDatagramRouterPingReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latency_datacenter_ids_){arena}
    , decltype(_impl_.latency_ping_ms_){arena}
    , /*decltype(_impl_._latency_ping_ms_cached_byte_size_)*/{0}
    , decltype(_impl_.route_exceptions_){arena}
    , decltype(_impl_.alt_addresses_){arena}
    , decltype(_impl_.latency_datacenter_ids_p2p_){arena}
    , decltype(_impl_.latency_ping_ms_p2p_){arena}
    , /*decltype(_impl_._latency_ping_ms_p2p_cached_byte_size_)*/{0}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.client_timestamp_){0u}
    , decltype(_impl_.your_public_ip_){0u}
    , decltype(_impl_.challenge_){uint64_t{0u}}
    , decltype(_impl_.server_time_){0u}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.client_cookie_){0u}
    , decltype(_impl_.scoring_penalty_relay_cluster_){0u}
    , decltype(_impl_.your_public_port_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.recv_tos_){0u}
    , decltype(_impl_.echo_sent_tos_){0u}
    , decltype(_impl_.sent_tos_){0u}
    , decltype(_impl_.echo_request_reply_tos_){0u}
    , decltype(_impl_.dummy_varint_){uint64_t{0u}}
  };
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramRouterPingReply::~CMsgSteamDatagramRouterPingReply() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramRouterPingReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramRouterPingReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latency_datacenter_ids_.~RepeatedField();
  _impl_.latency_ping_ms_.~RepeatedField();
  _impl_.route_exceptions_.~RepeatedPtrField();
  _impl_.alt_addresses_.~RepeatedPtrField();
  _impl_.latency_datacenter_ids_p2p_.~RepeatedField();
  _impl_.latency_ping_ms_p2p_.~RepeatedField();
  _impl_.dummy_pad_.Destroy();
}

void CMsgSteamDatagramRouterPingReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramRouterPingReply::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramRouterPingReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.latency_datacenter_ids_.Clear();
  _impl_.latency_ping_ms_.Clear();
  _impl_.route_exceptions_.Clear();
  _impl_.alt_addresses_.Clear();
  _impl_.latency_datacenter_ids_p2p_.Clear();
  _impl_.latency_ping_ms_p2p_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.dummy_pad_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.client_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scoring_penalty_relay_cluster_) -
        reinterpret_cast<char*>(&_impl_.client_timestamp_)) + sizeof(_impl_.scoring_penalty_relay_cluster_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.your_public_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dummy_varint_) -
        reinterpret_cast<char*>(&_impl_.your_public_port_)) + sizeof(_impl_.dummy_varint_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramRouterPingReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 client_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_client_timestamp(&has_bits);
          _impl_.client_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 latency_datacenter_ids = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_latency_datacenter_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_latency_datacenter_ids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 latency_ping_ms = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_latency_ping_ms(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_latency_ping_ms(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 your_public_ip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_your_public_ip(&has_bits);
          _impl_.your_public_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_server_time(&has_bits);
          _impl_.server_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 challenge = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_challenge(&has_bits);
          _impl_.challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_cookie = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_client_cookie(&has_bits);
          _impl_.client_cookie_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scoring_penalty_relay_cluster = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_scoring_penalty_relay_cluster(&has_bits);
          _impl_.scoring_penalty_relay_cluster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_route_exceptions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 your_public_port = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_your_public_port(&has_bits);
          _impl_.your_public_port_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alt_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 latency_datacenter_ids_p2p = 14 [packed = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_latency_datacenter_ids_p2p(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 117) {
          _internal_add_latency_datacenter_ids_p2p(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 latency_ping_ms_p2p = 15 [packed = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_latency_ping_ms_p2p(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 120) {
          _internal_add_latency_ping_ms_p2p(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recv_tos = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_recv_tos(&has_bits);
          _impl_.recv_tos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 echo_sent_tos = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_echo_sent_tos(&has_bits);
          _impl_.echo_sent_tos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sent_tos = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_sent_tos(&has_bits);
          _impl_.sent_tos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 echo_request_reply_tos = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_echo_request_reply_tos(&has_bits);
          _impl_.echo_request_reply_tos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dummy_pad = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dummy_pad();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dummy_varint = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dummy_varint(&has_bits);
          _impl_.dummy_varint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramRouterPingReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramRouterPingReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 client_timestamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_client_timestamp(), target);
  }

  // repeated fixed32 latency_datacenter_ids = 2 [packed = true];
  if (this->_internal_latency_datacenter_ids_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_latency_datacenter_ids(), target);
  }

  // repeated uint32 latency_ping_ms = 3 [packed = true];
  {
    int byte_size = _impl_._latency_ping_ms_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_latency_ping_ms(), byte_size, target);
    }
  }

  // optional fixed32 your_public_ip = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_your_public_ip(), target);
  }

  // optional fixed32 server_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_server_time(), target);
  }

  // optional fixed64 challenge = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(6, this->_internal_challenge(), target);
  }

  // optional uint32 seconds_until_shutdown = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_seconds_until_shutdown(), target);
  }

  // optional fixed32 client_cookie = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_client_cookie(), target);
  }

  // optional uint32 scoring_penalty_relay_cluster = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_scoring_penalty_relay_cluster(), target);
  }

  // repeated .CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_route_exceptions_size()); i < n; i++) {
    const auto& repfield = this->_internal_route_exceptions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional fixed32 your_public_port = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(11, this->_internal_your_public_port(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_flags(), target);
  }

  // repeated .CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alt_addresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_alt_addresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated fixed32 latency_datacenter_ids_p2p = 14 [packed = true];
  if (this->_internal_latency_datacenter_ids_p2p_size() > 0) {
    target = stream->WriteFixedPacked(14, _internal_latency_datacenter_ids_p2p(), target);
  }

  // repeated uint32 latency_ping_ms_p2p = 15 [packed = true];
  {
    int byte_size = _impl_._latency_ping_ms_p2p_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          15, _internal_latency_ping_ms_p2p(), byte_size, target);
    }
  }

  // optional uint32 recv_tos = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_recv_tos(), target);
  }

  // optional uint32 echo_sent_tos = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_echo_sent_tos(), target);
  }

  // optional uint32 sent_tos = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_sent_tos(), target);
  }

  // optional uint32 echo_request_reply_tos = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_echo_request_reply_tos(), target);
  }

  // optional bytes dummy_pad = 99;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        99, this->_internal_dummy_pad(), target);
  }

  // optional uint64 dummy_varint = 100;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(100, this->_internal_dummy_varint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramRouterPingReply)
  return target;
}

size_t CMsgSteamDatagramRouterPingReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramRouterPingReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 latency_datacenter_ids = 2 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_latency_datacenter_ids_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated uint32 latency_ping_ms = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.latency_ping_ms_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._latency_ping_ms_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;
  total_size += 1UL * this->_internal_route_exceptions_size();
  for (const auto& msg : this->_impl_.route_exceptions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13;
  total_size += 1UL * this->_internal_alt_addresses_size();
  for (const auto& msg : this->_impl_.alt_addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated fixed32 latency_datacenter_ids_p2p = 14 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_latency_datacenter_ids_p2p_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated uint32 latency_ping_ms_p2p = 15 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.latency_ping_ms_p2p_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._latency_ping_ms_p2p_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes dummy_pad = 99;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dummy_pad());
    }

    // optional fixed32 client_timestamp = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 your_public_ip = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed64 challenge = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional fixed32 server_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 seconds_until_shutdown = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional fixed32 client_cookie = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 scoring_penalty_relay_cluster = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scoring_penalty_relay_cluster());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional fixed32 your_public_port = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 recv_tos = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recv_tos());
    }

    // optional uint32 echo_sent_tos = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_echo_sent_tos());
    }

    // optional uint32 sent_tos = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_sent_tos());
    }

    // optional uint32 echo_request_reply_tos = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_echo_request_reply_tos());
    }

    // optional uint64 dummy_varint = 100;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_dummy_varint());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramRouterPingReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramRouterPingReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramRouterPingReply::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramRouterPingReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramRouterPingReply*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramRouterPingReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramRouterPingReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.latency_datacenter_ids_.MergeFrom(from._impl_.latency_datacenter_ids_);
  _this->_impl_.latency_ping_ms_.MergeFrom(from._impl_.latency_ping_ms_);
  _this->_impl_.route_exceptions_.MergeFrom(from._impl_.route_exceptions_);
  _this->_impl_.alt_addresses_.MergeFrom(from._impl_.alt_addresses_);
  _this->_impl_.latency_datacenter_ids_p2p_.MergeFrom(from._impl_.latency_datacenter_ids_p2p_);
  _this->_impl_.latency_ping_ms_p2p_.MergeFrom(from._impl_.latency_ping_ms_p2p_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dummy_pad(from._internal_dummy_pad());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.client_timestamp_ = from._impl_.client_timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.your_public_ip_ = from._impl_.your_public_ip_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.challenge_ = from._impl_.challenge_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.server_time_ = from._impl_.server_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.client_cookie_ = from._impl_.client_cookie_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.scoring_penalty_relay_cluster_ = from._impl_.scoring_penalty_relay_cluster_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.your_public_port_ = from._impl_.your_public_port_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.recv_tos_ = from._impl_.recv_tos_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.echo_sent_tos_ = from._impl_.echo_sent_tos_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.sent_tos_ = from._impl_.sent_tos_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.echo_request_reply_tos_ = from._impl_.echo_request_reply_tos_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.dummy_varint_ = from._impl_.dummy_varint_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramRouterPingReply::CopyFrom(const CMsgSteamDatagramRouterPingReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramRouterPingReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramRouterPingReply::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramRouterPingReply::InternalSwap(CMsgSteamDatagramRouterPingReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.latency_datacenter_ids_.InternalSwap(&other->_impl_.latency_datacenter_ids_);
  _impl_.latency_ping_ms_.InternalSwap(&other->_impl_.latency_ping_ms_);
  _impl_.route_exceptions_.InternalSwap(&other->_impl_.route_exceptions_);
  _impl_.alt_addresses_.InternalSwap(&other->_impl_.alt_addresses_);
  _impl_.latency_datacenter_ids_p2p_.InternalSwap(&other->_impl_.latency_datacenter_ids_p2p_);
  _impl_.latency_ping_ms_p2p_.InternalSwap(&other->_impl_.latency_ping_ms_p2p_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dummy_pad_, lhs_arena,
      &other->_impl_.dummy_pad_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply, _impl_.dummy_varint_)
      + sizeof(CMsgSteamDatagramRouterPingReply::_impl_.dummy_varint_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramRouterPingReply, _impl_.client_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.client_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.client_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramRouterPingReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[4]);
}

// ===================================================================

class CMsgSteamDatagramGameserverPingRequestBody::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramGameserverPingRequestBody>()._impl_._has_bits_);
  static void set_has_relay_popid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamNetworkingIPAddress& your_public_ip(const CMsgSteamDatagramGameserverPingRequestBody* msg);
  static void set_has_your_public_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_your_public_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_relay_unix_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_routing_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_echo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSteamNetworkingIPAddress&
CMsgSteamDatagramGameserverPingRequestBody::_Internal::your_public_ip(const CMsgSteamDatagramGameserverPingRequestBody* msg) {
  return *msg->_impl_.your_public_ip_;
}
CMsgSteamDatagramGameserverPingRequestBody::CMsgSteamDatagramGameserverPingRequestBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramGameserverPingRequestBody)
}
CMsgSteamDatagramGameserverPingRequestBody::CMsgSteamDatagramGameserverPingRequestBody(const CMsgSteamDatagramGameserverPingRequestBody& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramGameserverPingRequestBody* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.my_ips_){from._impl_.my_ips_}
    , decltype(_impl_.echo_){}
    , decltype(_impl_.your_public_ip_){nullptr}
    , decltype(_impl_.relay_popid_){}
    , decltype(_impl_.your_public_port_){}
    , decltype(_impl_.relay_unix_time_){}
    , decltype(_impl_.routing_secret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.echo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.echo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_echo()) {
    _this->_impl_.echo_.Set(from._internal_echo(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_your_public_ip()) {
    _this->_impl_.your_public_ip_ = new ::CMsgSteamNetworkingIPAddress(*from._impl_.your_public_ip_);
  }
  ::memcpy(&_impl_.relay_popid_, &from._impl_.relay_popid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.routing_secret_) -
    reinterpret_cast<char*>(&_impl_.relay_popid_)) + sizeof(_impl_.routing_secret_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramGameserverPingRequestBody)
}

inline void CMsgSteamDatagramGameserverPingRequestBody::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.my_ips_){arena}
    , decltype(_impl_.echo_){}
    , decltype(_impl_.your_public_ip_){nullptr}
    , decltype(_impl_.relay_popid_){0u}
    , decltype(_impl_.your_public_port_){0u}
    , decltype(_impl_.relay_unix_time_){uint64_t{0u}}
    , decltype(_impl_.routing_secret_){uint64_t{0u}}
  };
  _impl_.echo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.echo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramGameserverPingRequestBody::~CMsgSteamDatagramGameserverPingRequestBody() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramGameserverPingRequestBody)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramGameserverPingRequestBody::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.my_ips_.~RepeatedPtrField();
  _impl_.echo_.Destroy();
  if (this != internal_default_instance()) delete _impl_.your_public_ip_;
}

void CMsgSteamDatagramGameserverPingRequestBody::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramGameserverPingRequestBody::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramGameserverPingRequestBody)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.my_ips_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.echo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.your_public_ip_ != nullptr);
      _impl_.your_public_ip_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.relay_popid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.routing_secret_) -
        reinterpret_cast<char*>(&_impl_.relay_popid_)) + sizeof(_impl_.routing_secret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramGameserverPingRequestBody::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 relay_popid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_relay_popid(&has_bits);
          _impl_.relay_popid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamNetworkingIPAddress your_public_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_your_public_ip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 your_public_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_your_public_port(&has_bits);
          _impl_.your_public_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 relay_unix_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_relay_unix_time(&has_bits);
          _impl_.relay_unix_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 routing_secret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_routing_secret(&has_bits);
          _impl_.routing_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamNetworkingIPAddress my_ips = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_my_ips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes echo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_echo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramGameserverPingRequestBody::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramGameserverPingRequestBody)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 relay_popid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_relay_popid(), target);
  }

  // optional .CMsgSteamNetworkingIPAddress your_public_ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::your_public_ip(this),
        _Internal::your_public_ip(this).GetCachedSize(), target, stream);
  }

  // optional uint32 your_public_port = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_your_public_port(), target);
  }

  // optional uint64 relay_unix_time = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_relay_unix_time(), target);
  }

  // optional fixed64 routing_secret = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(5, this->_internal_routing_secret(), target);
  }

  // repeated .CMsgSteamNetworkingIPAddress my_ips = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_my_ips_size()); i < n; i++) {
    const auto& repfield = this->_internal_my_ips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes echo = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_echo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramGameserverPingRequestBody)
  return target;
}

size_t CMsgSteamDatagramGameserverPingRequestBody::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramGameserverPingRequestBody)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSteamNetworkingIPAddress my_ips = 6;
  total_size += 1UL * this->_internal_my_ips_size();
  for (const auto& msg : this->_impl_.my_ips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes echo = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_echo());
    }

    // optional .CMsgSteamNetworkingIPAddress your_public_ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.your_public_ip_);
    }

    // optional fixed32 relay_popid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 your_public_port = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_your_public_port());
    }

    // optional uint64 relay_unix_time = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_relay_unix_time());
    }

    // optional fixed64 routing_secret = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramGameserverPingRequestBody::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramGameserverPingRequestBody::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramGameserverPingRequestBody::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramGameserverPingRequestBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramGameserverPingRequestBody*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramGameserverPingRequestBody&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramGameserverPingRequestBody)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.my_ips_.MergeFrom(from._impl_.my_ips_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_echo(from._internal_echo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_your_public_ip()->::CMsgSteamNetworkingIPAddress::MergeFrom(
          from._internal_your_public_ip());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.relay_popid_ = from._impl_.relay_popid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.your_public_port_ = from._impl_.your_public_port_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.relay_unix_time_ = from._impl_.relay_unix_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.routing_secret_ = from._impl_.routing_secret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramGameserverPingRequestBody::CopyFrom(const CMsgSteamDatagramGameserverPingRequestBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramGameserverPingRequestBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramGameserverPingRequestBody::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramGameserverPingRequestBody::InternalSwap(CMsgSteamDatagramGameserverPingRequestBody* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.my_ips_.InternalSwap(&other->_impl_.my_ips_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.echo_, lhs_arena,
      &other->_impl_.echo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingRequestBody, _impl_.routing_secret_)
      + sizeof(CMsgSteamDatagramGameserverPingRequestBody::_impl_.routing_secret_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingRequestBody, _impl_.your_public_ip_)>(
          reinterpret_cast<char*>(&_impl_.your_public_ip_),
          reinterpret_cast<char*>(&other->_impl_.your_public_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramGameserverPingRequestBody::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[5]);
}

// ===================================================================

class CMsgSteamDatagramGameserverPingRequestEnvelope::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramGameserverPingRequestEnvelope>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramCertificateSigned& cert(const CMsgSteamDatagramGameserverPingRequestEnvelope* msg);
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_legacy_your_public_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_legacy_your_public_port(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_legacy_relay_unix_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_legacy_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_legacy_router_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dummy_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramGameserverPingRequestEnvelope::_Internal::cert(const CMsgSteamDatagramGameserverPingRequestEnvelope* msg) {
  return *msg->_impl_.cert_;
}
void CMsgSteamDatagramGameserverPingRequestEnvelope::clear_cert() {
  if (_impl_.cert_ != nullptr) _impl_.cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgSteamDatagramGameserverPingRequestEnvelope::CMsgSteamDatagramGameserverPingRequestEnvelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramGameserverPingRequestEnvelope)
}
CMsgSteamDatagramGameserverPingRequestEnvelope::CMsgSteamDatagramGameserverPingRequestEnvelope(const CMsgSteamDatagramGameserverPingRequestEnvelope& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramGameserverPingRequestEnvelope* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.legacy_your_public_ip_){}
    , decltype(_impl_.legacy_relay_unix_time_){}
    , decltype(_impl_.legacy_challenge_){}
    , decltype(_impl_.legacy_router_timestamp_){}
    , decltype(_impl_.legacy_your_public_port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signed_data()) {
    _this->_impl_.signed_data_.Set(from._internal_signed_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dummy_pad()) {
    _this->_impl_.dummy_pad_.Set(from._internal_dummy_pad(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cert()) {
    _this->_impl_.cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.cert_);
  }
  ::memcpy(&_impl_.legacy_your_public_ip_, &from._impl_.legacy_your_public_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.legacy_your_public_port_) -
    reinterpret_cast<char*>(&_impl_.legacy_your_public_ip_)) + sizeof(_impl_.legacy_your_public_port_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramGameserverPingRequestEnvelope)
}

inline void CMsgSteamDatagramGameserverPingRequestEnvelope::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.dummy_pad_){}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.legacy_your_public_ip_){0u}
    , decltype(_impl_.legacy_relay_unix_time_){0u}
    , decltype(_impl_.legacy_challenge_){uint64_t{0u}}
    , decltype(_impl_.legacy_router_timestamp_){0u}
    , decltype(_impl_.legacy_your_public_port_){0u}
  };
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dummy_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramGameserverPingRequestEnvelope::~CMsgSteamDatagramGameserverPingRequestEnvelope() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramGameserverPingRequestEnvelope)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramGameserverPingRequestEnvelope::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signed_data_.Destroy();
  _impl_.signature_.Destroy();
  _impl_.dummy_pad_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cert_;
}

void CMsgSteamDatagramGameserverPingRequestEnvelope::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramGameserverPingRequestEnvelope::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramGameserverPingRequestEnvelope)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signed_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.dummy_pad_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cert_ != nullptr);
      _impl_.cert_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.legacy_your_public_ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.legacy_router_timestamp_) -
        reinterpret_cast<char*>(&_impl_.legacy_your_public_ip_)) + sizeof(_impl_.legacy_router_timestamp_));
  }
  _impl_.legacy_your_public_port_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramGameserverPingRequestEnvelope::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 legacy_your_public_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_legacy_your_public_ip(&has_bits);
          _impl_.legacy_your_public_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 legacy_relay_unix_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_legacy_relay_unix_time(&has_bits);
          _impl_.legacy_relay_unix_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_challenge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_challenge(&has_bits);
          _impl_.legacy_challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 legacy_router_timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_legacy_router_timestamp(&has_bits);
          _impl_.legacy_router_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 legacy_your_public_port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_legacy_your_public_port(&has_bits);
          _impl_.legacy_your_public_port_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramCertificateSigned cert = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signed_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_signed_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dummy_pad = 1023;
      case 1023:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_dummy_pad();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramGameserverPingRequestEnvelope::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramGameserverPingRequestEnvelope)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 legacy_your_public_ip = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_legacy_your_public_ip(), target);
  }

  // optional fixed32 legacy_relay_unix_time = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_legacy_relay_unix_time(), target);
  }

  // optional fixed64 legacy_challenge = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_challenge(), target);
  }

  // optional fixed32 legacy_router_timestamp = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_legacy_router_timestamp(), target);
  }

  // optional fixed32 legacy_your_public_port = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_legacy_your_public_port(), target);
  }

  // optional .CMsgSteamDatagramCertificateSigned cert = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::cert(this),
        _Internal::cert(this).GetCachedSize(), target, stream);
  }

  // optional bytes signed_data = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_signed_data(), target);
  }

  // optional bytes signature = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_signature(), target);
  }

  // optional bytes dummy_pad = 1023;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        1023, this->_internal_dummy_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramGameserverPingRequestEnvelope)
  return target;
}

size_t CMsgSteamDatagramGameserverPingRequestEnvelope::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramGameserverPingRequestEnvelope)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes signed_data = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signed_data());
    }

    // optional bytes signature = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional bytes dummy_pad = 1023;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dummy_pad());
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_);
    }

    // optional fixed32 legacy_your_public_ip = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 legacy_relay_unix_time = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional fixed64 legacy_challenge = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional fixed32 legacy_router_timestamp = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional fixed32 legacy_your_public_port = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramGameserverPingRequestEnvelope::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramGameserverPingRequestEnvelope::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramGameserverPingRequestEnvelope::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramGameserverPingRequestEnvelope::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramGameserverPingRequestEnvelope*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramGameserverPingRequestEnvelope&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramGameserverPingRequestEnvelope)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signed_data(from._internal_signed_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_dummy_pad(from._internal_dummy_pad());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_cert());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.legacy_your_public_ip_ = from._impl_.legacy_your_public_ip_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.legacy_relay_unix_time_ = from._impl_.legacy_relay_unix_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.legacy_challenge_ = from._impl_.legacy_challenge_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.legacy_router_timestamp_ = from._impl_.legacy_router_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_legacy_your_public_port(from._internal_legacy_your_public_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramGameserverPingRequestEnvelope::CopyFrom(const CMsgSteamDatagramGameserverPingRequestEnvelope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramGameserverPingRequestEnvelope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramGameserverPingRequestEnvelope::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramGameserverPingRequestEnvelope::InternalSwap(CMsgSteamDatagramGameserverPingRequestEnvelope* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signed_data_, lhs_arena,
      &other->_impl_.signed_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dummy_pad_, lhs_arena,
      &other->_impl_.dummy_pad_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.legacy_your_public_port_)
      + sizeof(CMsgSteamDatagramGameserverPingRequestEnvelope::_impl_.legacy_your_public_port_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingRequestEnvelope, _impl_.cert_)>(
          reinterpret_cast<char*>(&_impl_.cert_),
          reinterpret_cast<char*>(&other->_impl_.cert_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramGameserverPingRequestEnvelope::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[6]);
}

// ===================================================================

class CMsgSteamDatagramGameserverPingReplyData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramGameserverPingReplyData>()._impl_._has_bits_);
  static void set_has_echo_relay_unix_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_echo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_legacy_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_legacy_router_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_data_center_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_build(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_config_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_my_unix_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_routing_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramGameserverPingReplyData::CMsgSteamDatagramGameserverPingReplyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramGameserverPingReplyData)
}
CMsgSteamDatagramGameserverPingReplyData::CMsgSteamDatagramGameserverPingReplyData(const CMsgSteamDatagramGameserverPingReplyData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramGameserverPingReplyData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.routing_blob_){}
    , decltype(_impl_.legacy_challenge_){}
    , decltype(_impl_.echo_relay_unix_time_){}
    , decltype(_impl_.legacy_router_timestamp_){}
    , decltype(_impl_.data_center_id_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.protocol_version_){}
    , decltype(_impl_.my_unix_time_){}
    , decltype(_impl_.network_config_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.echo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.echo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_echo()) {
    _this->_impl_.echo_.Set(from._internal_echo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build()) {
    _this->_impl_.build_.Set(from._internal_build(), 
      _this->GetArenaForAllocation());
  }
  _impl_.routing_blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routing_blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_routing_blob()) {
    _this->_impl_.routing_blob_.Set(from._internal_routing_blob(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.legacy_challenge_, &from._impl_.legacy_challenge_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.network_config_version_) -
    reinterpret_cast<char*>(&_impl_.legacy_challenge_)) + sizeof(_impl_.network_config_version_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramGameserverPingReplyData)
}

inline void CMsgSteamDatagramGameserverPingReplyData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.routing_blob_){}
    , decltype(_impl_.legacy_challenge_){uint64_t{0u}}
    , decltype(_impl_.echo_relay_unix_time_){0u}
    , decltype(_impl_.legacy_router_timestamp_){0u}
    , decltype(_impl_.data_center_id_){0u}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.protocol_version_){0u}
    , decltype(_impl_.my_unix_time_){0u}
    , decltype(_impl_.network_config_version_){uint64_t{0u}}
  };
  _impl_.echo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.echo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.routing_blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routing_blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramGameserverPingReplyData::~CMsgSteamDatagramGameserverPingReplyData() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramGameserverPingReplyData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramGameserverPingReplyData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.echo_.Destroy();
  _impl_.build_.Destroy();
  _impl_.routing_blob_.Destroy();
}

void CMsgSteamDatagramGameserverPingReplyData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramGameserverPingReplyData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramGameserverPingReplyData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.echo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.routing_blob_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.legacy_challenge_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.legacy_challenge_)) + sizeof(_impl_.appid_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.protocol_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.network_config_version_) -
        reinterpret_cast<char*>(&_impl_.protocol_version_)) + sizeof(_impl_.network_config_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramGameserverPingReplyData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 echo_relay_unix_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_echo_relay_unix_time(&has_bits);
          _impl_.echo_relay_unix_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_challenge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_challenge(&has_bits);
          _impl_.legacy_challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 legacy_router_timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_legacy_router_timestamp(&has_bits);
          _impl_.legacy_router_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 data_center_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_data_center_id(&has_bits);
          _impl_.data_center_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 protocol_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_protocol_version(&has_bits);
          _impl_.protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes echo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_echo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string build = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramGameserverPingReplyData.build");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 network_config_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_network_config_version(&has_bits);
          _impl_.network_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 my_unix_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_my_unix_time(&has_bits);
          _impl_.my_unix_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes routing_blob = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_routing_blob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramGameserverPingReplyData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramGameserverPingReplyData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 echo_relay_unix_time = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_echo_relay_unix_time(), target);
  }

  // optional fixed64 legacy_challenge = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_challenge(), target);
  }

  // optional fixed32 legacy_router_timestamp = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_legacy_router_timestamp(), target);
  }

  // optional fixed32 data_center_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_data_center_id(), target);
  }

  // optional uint32 appid = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_appid(), target);
  }

  // optional uint32 protocol_version = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_protocol_version(), target);
  }

  // optional bytes echo = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_echo(), target);
  }

  // optional string build = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_build().data(), static_cast<int>(this->_internal_build().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramGameserverPingReplyData.build");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_build(), target);
  }

  // optional uint64 network_config_version = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_network_config_version(), target);
  }

  // optional fixed32 my_unix_time = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(11, this->_internal_my_unix_time(), target);
  }

  // optional bytes routing_blob = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_routing_blob(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramGameserverPingReplyData)
  return target;
}

size_t CMsgSteamDatagramGameserverPingReplyData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramGameserverPingReplyData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes echo = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_echo());
    }

    // optional string build = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build());
    }

    // optional bytes routing_blob = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_routing_blob());
    }

    // optional fixed64 legacy_challenge = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional fixed32 echo_relay_unix_time = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 legacy_router_timestamp = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional fixed32 data_center_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 appid = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 protocol_version = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_version());
    }

    // optional fixed32 my_unix_time = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint64 network_config_version = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_network_config_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramGameserverPingReplyData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramGameserverPingReplyData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramGameserverPingReplyData::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramGameserverPingReplyData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramGameserverPingReplyData*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramGameserverPingReplyData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramGameserverPingReplyData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_echo(from._internal_echo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_build(from._internal_build());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_routing_blob(from._internal_routing_blob());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.legacy_challenge_ = from._impl_.legacy_challenge_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.echo_relay_unix_time_ = from._impl_.echo_relay_unix_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.legacy_router_timestamp_ = from._impl_.legacy_router_timestamp_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.data_center_id_ = from._impl_.data_center_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.my_unix_time_ = from._impl_.my_unix_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.network_config_version_ = from._impl_.network_config_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramGameserverPingReplyData::CopyFrom(const CMsgSteamDatagramGameserverPingReplyData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramGameserverPingReplyData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramGameserverPingReplyData::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramGameserverPingReplyData::InternalSwap(CMsgSteamDatagramGameserverPingReplyData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.echo_, lhs_arena,
      &other->_impl_.echo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.build_, lhs_arena,
      &other->_impl_.build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.routing_blob_, lhs_arena,
      &other->_impl_.routing_blob_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingReplyData, _impl_.network_config_version_)
      + sizeof(CMsgSteamDatagramGameserverPingReplyData::_impl_.network_config_version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverPingReplyData, _impl_.legacy_challenge_)>(
          reinterpret_cast<char*>(&_impl_.legacy_challenge_),
          reinterpret_cast<char*>(&other->_impl_.legacy_challenge_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramGameserverPingReplyData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[7]);
}

// ===================================================================

class CMsgSteamDatagramNoSessionRelayToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramNoSessionRelayToClient>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_your_public_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_your_public_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_server_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSteamDatagramNoSessionRelayToClient::CMsgSteamDatagramNoSessionRelayToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramNoSessionRelayToClient)
}
CMsgSteamDatagramNoSessionRelayToClient::CMsgSteamDatagramNoSessionRelayToClient(const CMsgSteamDatagramNoSessionRelayToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramNoSessionRelayToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.your_public_ip_){}
    , decltype(_impl_.server_time_){}
    , decltype(_impl_.challenge_){}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.your_public_port_){}
    , decltype(_impl_.connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.your_public_ip_, &from._impl_.your_public_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.connection_id_) -
    reinterpret_cast<char*>(&_impl_.your_public_ip_)) + sizeof(_impl_.connection_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramNoSessionRelayToClient)
}

inline void CMsgSteamDatagramNoSessionRelayToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.your_public_ip_){0u}
    , decltype(_impl_.server_time_){0u}
    , decltype(_impl_.challenge_){uint64_t{0u}}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.your_public_port_){0u}
    , decltype(_impl_.connection_id_){0u}
  };
}

CMsgSteamDatagramNoSessionRelayToClient::~CMsgSteamDatagramNoSessionRelayToClient() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramNoSessionRelayToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramNoSessionRelayToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramNoSessionRelayToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramNoSessionRelayToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramNoSessionRelayToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.your_public_ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.connection_id_) -
        reinterpret_cast<char*>(&_impl_.your_public_ip_)) + sizeof(_impl_.connection_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramNoSessionRelayToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 your_public_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_your_public_ip(&has_bits);
          _impl_.your_public_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_server_time(&has_bits);
          _impl_.server_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 challenge = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_challenge(&has_bits);
          _impl_.challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 your_public_port = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_your_public_port(&has_bits);
          _impl_.your_public_port_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramNoSessionRelayToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramNoSessionRelayToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 your_public_ip = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_your_public_ip(), target);
  }

  // optional fixed32 server_time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_server_time(), target);
  }

  // optional fixed64 challenge = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_challenge(), target);
  }

  // optional uint32 seconds_until_shutdown = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_seconds_until_shutdown(), target);
  }

  // optional fixed32 your_public_port = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_your_public_port(), target);
  }

  // optional fixed32 connection_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_connection_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramNoSessionRelayToClient)
  return target;
}

size_t CMsgSteamDatagramNoSessionRelayToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramNoSessionRelayToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed32 your_public_ip = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 server_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed64 challenge = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 seconds_until_shutdown = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional fixed32 your_public_port = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 connection_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramNoSessionRelayToClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramNoSessionRelayToClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramNoSessionRelayToClient::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramNoSessionRelayToClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramNoSessionRelayToClient*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramNoSessionRelayToClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramNoSessionRelayToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.your_public_ip_ = from._impl_.your_public_ip_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.server_time_ = from._impl_.server_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.challenge_ = from._impl_.challenge_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.your_public_port_ = from._impl_.your_public_port_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramNoSessionRelayToClient::CopyFrom(const CMsgSteamDatagramNoSessionRelayToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramNoSessionRelayToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramNoSessionRelayToClient::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramNoSessionRelayToClient::InternalSwap(CMsgSteamDatagramNoSessionRelayToClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoSessionRelayToClient, _impl_.connection_id_)
      + sizeof(CMsgSteamDatagramNoSessionRelayToClient::_impl_.connection_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoSessionRelayToClient, _impl_.your_public_ip_)>(
          reinterpret_cast<char*>(&_impl_.your_public_ip_),
          reinterpret_cast<char*>(&other->_impl_.your_public_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramNoSessionRelayToClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[8]);
}

// ===================================================================

class CMsgSteamDatagramNoSessionRelayToPeer::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramNoSessionRelayToPeer>()._impl_._has_bits_);
  static void set_has_legacy_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_from_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kludge_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramNoSessionRelayToPeer::CMsgSteamDatagramNoSessionRelayToPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramNoSessionRelayToPeer)
}
CMsgSteamDatagramNoSessionRelayToPeer::CMsgSteamDatagramNoSessionRelayToPeer(const CMsgSteamDatagramNoSessionRelayToPeer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramNoSessionRelayToPeer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.legacy_relay_session_id_){}
    , decltype(_impl_.from_relay_session_id_){}
    , decltype(_impl_.kludge_pad_){}
    , decltype(_impl_.from_connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.legacy_relay_session_id_, &from._impl_.legacy_relay_session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.from_connection_id_) -
    reinterpret_cast<char*>(&_impl_.legacy_relay_session_id_)) + sizeof(_impl_.from_connection_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramNoSessionRelayToPeer)
}

inline void CMsgSteamDatagramNoSessionRelayToPeer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.legacy_relay_session_id_){0u}
    , decltype(_impl_.from_relay_session_id_){0u}
    , decltype(_impl_.kludge_pad_){uint64_t{0u}}
    , decltype(_impl_.from_connection_id_){0u}
  };
}

CMsgSteamDatagramNoSessionRelayToPeer::~CMsgSteamDatagramNoSessionRelayToPeer() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramNoSessionRelayToPeer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramNoSessionRelayToPeer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramNoSessionRelayToPeer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramNoSessionRelayToPeer::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramNoSessionRelayToPeer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.legacy_relay_session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_connection_id_) -
        reinterpret_cast<char*>(&_impl_.legacy_relay_session_id_)) + sizeof(_impl_.from_connection_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramNoSessionRelayToPeer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 legacy_relay_session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_legacy_relay_session_id(&has_bits);
          _impl_.legacy_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_relay_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_from_relay_session_id(&has_bits);
          _impl_.from_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_from_connection_id(&has_bits);
          _impl_.from_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 kludge_pad = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_kludge_pad(&has_bits);
          _impl_.kludge_pad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramNoSessionRelayToPeer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramNoSessionRelayToPeer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 legacy_relay_session_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_legacy_relay_session_id(), target);
  }

  // optional fixed32 from_relay_session_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_from_relay_session_id(), target);
  }

  // optional fixed32 from_connection_id = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_from_connection_id(), target);
  }

  // optional fixed64 kludge_pad = 99;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(99, this->_internal_kludge_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramNoSessionRelayToPeer)
  return target;
}

size_t CMsgSteamDatagramNoSessionRelayToPeer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramNoSessionRelayToPeer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 legacy_relay_session_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_relay_session_id());
    }

    // optional fixed32 from_relay_session_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed64 kludge_pad = 99;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 8;
    }

    // optional fixed32 from_connection_id = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramNoSessionRelayToPeer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramNoSessionRelayToPeer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramNoSessionRelayToPeer::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramNoSessionRelayToPeer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramNoSessionRelayToPeer*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramNoSessionRelayToPeer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramNoSessionRelayToPeer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.legacy_relay_session_id_ = from._impl_.legacy_relay_session_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.from_relay_session_id_ = from._impl_.from_relay_session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.kludge_pad_ = from._impl_.kludge_pad_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.from_connection_id_ = from._impl_.from_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramNoSessionRelayToPeer::CopyFrom(const CMsgSteamDatagramNoSessionRelayToPeer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramNoSessionRelayToPeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramNoSessionRelayToPeer::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramNoSessionRelayToPeer::InternalSwap(CMsgSteamDatagramNoSessionRelayToPeer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoSessionRelayToPeer, _impl_.from_connection_id_)
      + sizeof(CMsgSteamDatagramNoSessionRelayToPeer::_impl_.from_connection_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoSessionRelayToPeer, _impl_.legacy_relay_session_id_)>(
          reinterpret_cast<char*>(&_impl_.legacy_relay_session_id_),
          reinterpret_cast<char*>(&other->_impl_.legacy_relay_session_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramNoSessionRelayToPeer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[9]);
}

// ===================================================================

class CMsgTOSTreatment::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTOSTreatment>()._impl_._has_bits_);
  static void set_has_l4s_detect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_up_ecn1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_down_dscp45(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgTOSTreatment::CMsgTOSTreatment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTOSTreatment)
}
CMsgTOSTreatment::CMsgTOSTreatment(const CMsgTOSTreatment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTOSTreatment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.l4s_detect_){}
    , decltype(_impl_.up_ecn1_){}
    , decltype(_impl_.down_dscp45_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.l4s_detect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.l4s_detect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_l4s_detect()) {
    _this->_impl_.l4s_detect_.Set(from._internal_l4s_detect(), 
      _this->GetArenaForAllocation());
  }
  _impl_.up_ecn1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.up_ecn1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_up_ecn1()) {
    _this->_impl_.up_ecn1_.Set(from._internal_up_ecn1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.down_dscp45_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.down_dscp45_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_down_dscp45()) {
    _this->_impl_.down_dscp45_.Set(from._internal_down_dscp45(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTOSTreatment)
}

inline void CMsgTOSTreatment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.l4s_detect_){}
    , decltype(_impl_.up_ecn1_){}
    , decltype(_impl_.down_dscp45_){}
  };
  _impl_.l4s_detect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.l4s_detect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.up_ecn1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.up_ecn1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.down_dscp45_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.down_dscp45_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgTOSTreatment::~CMsgTOSTreatment() {
  // @@protoc_insertion_point(destructor:CMsgTOSTreatment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTOSTreatment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.l4s_detect_.Destroy();
  _impl_.up_ecn1_.Destroy();
  _impl_.down_dscp45_.Destroy();
}

void CMsgTOSTreatment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTOSTreatment::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTOSTreatment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.l4s_detect_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.up_ecn1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.down_dscp45_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTOSTreatment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string l4s_detect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_l4s_detect();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTOSTreatment.l4s_detect");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string up_ecn1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_up_ecn1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTOSTreatment.up_ecn1");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string down_dscp45 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_down_dscp45();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTOSTreatment.down_dscp45");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTOSTreatment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTOSTreatment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string l4s_detect = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_l4s_detect().data(), static_cast<int>(this->_internal_l4s_detect().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTOSTreatment.l4s_detect");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_l4s_detect(), target);
  }

  // optional string up_ecn1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_up_ecn1().data(), static_cast<int>(this->_internal_up_ecn1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTOSTreatment.up_ecn1");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_up_ecn1(), target);
  }

  // optional string down_dscp45 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_down_dscp45().data(), static_cast<int>(this->_internal_down_dscp45().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTOSTreatment.down_dscp45");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_down_dscp45(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTOSTreatment)
  return target;
}

size_t CMsgTOSTreatment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTOSTreatment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string l4s_detect = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_l4s_detect());
    }

    // optional string up_ecn1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_up_ecn1());
    }

    // optional string down_dscp45 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_down_dscp45());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTOSTreatment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTOSTreatment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTOSTreatment::GetClassData() const { return &_class_data_; }


void CMsgTOSTreatment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTOSTreatment*>(&to_msg);
  auto& from = static_cast<const CMsgTOSTreatment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTOSTreatment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_l4s_detect(from._internal_l4s_detect());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_up_ecn1(from._internal_up_ecn1());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_down_dscp45(from._internal_down_dscp45());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTOSTreatment::CopyFrom(const CMsgTOSTreatment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTOSTreatment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTOSTreatment::IsInitialized() const {
  return true;
}

void CMsgTOSTreatment::InternalSwap(CMsgTOSTreatment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.l4s_detect_, lhs_arena,
      &other->_impl_.l4s_detect_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.up_ecn1_, lhs_arena,
      &other->_impl_.up_ecn1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.down_dscp45_, lhs_arena,
      &other->_impl_.down_dscp45_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTOSTreatment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[10]);
}

// ===================================================================

class CMsgSteamDatagramClientPingSampleRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientPingSampleRequest>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramClientPingSampleRequest::CMsgSteamDatagramClientPingSampleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientPingSampleRequest)
}
CMsgSteamDatagramClientPingSampleRequest::CMsgSteamDatagramClientPingSampleRequest(const CMsgSteamDatagramClientPingSampleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientPingSampleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.connection_id_ = from._impl_.connection_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientPingSampleRequest)
}

inline void CMsgSteamDatagramClientPingSampleRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_id_){0u}
  };
}

CMsgSteamDatagramClientPingSampleRequest::~CMsgSteamDatagramClientPingSampleRequest() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientPingSampleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientPingSampleRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramClientPingSampleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientPingSampleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientPingSampleRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.connection_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientPingSampleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientPingSampleRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientPingSampleRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientPingSampleRequest)
  return target;
}

size_t CMsgSteamDatagramClientPingSampleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientPingSampleRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed32 connection_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientPingSampleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientPingSampleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientPingSampleRequest::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientPingSampleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientPingSampleRequest*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientPingSampleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientPingSampleRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_connection_id()) {
    _this->_internal_set_connection_id(from._internal_connection_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientPingSampleRequest::CopyFrom(const CMsgSteamDatagramClientPingSampleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientPingSampleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientPingSampleRequest::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientPingSampleRequest::InternalSwap(CMsgSteamDatagramClientPingSampleRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.connection_id_, other->_impl_.connection_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientPingSampleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[11]);
}

// ===================================================================

class CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_front_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
}
CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress(const CMsgSteamDatagramClientPingSampleReply_POP_AltAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientPingSampleReply_POP_AltAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.front_ping_ms_){}
    , decltype(_impl_.penalty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.front_ping_ms_, &from._impl_.front_ping_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.penalty_) -
    reinterpret_cast<char*>(&_impl_.front_ping_ms_)) + sizeof(_impl_.penalty_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
}

inline void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.front_ping_ms_){0u}
    , decltype(_impl_.penalty_){0u}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::~CMsgSteamDatagramClientPingSampleReply_POP_AltAddress() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.front_ping_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.penalty_) -
        reinterpret_cast<char*>(&_impl_.front_ping_ms_)) + sizeof(_impl_.penalty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 front_ping_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_front_ping_ms(&has_bits);
          _impl_.front_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 penalty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_penalty(&has_bits);
          _impl_.penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional uint32 front_ping_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_front_ping_ms(), target);
  }

  // optional uint32 penalty = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_penalty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  return target;
}

size_t CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional uint32 front_ping_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_front_ping_ms());
    }

    // optional uint32 penalty = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_penalty());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientPingSampleReply_POP_AltAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.front_ping_ms_ = from._impl_.front_ping_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.penalty_ = from._impl_.penalty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::CopyFrom(const CMsgSteamDatagramClientPingSampleReply_POP_AltAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::InternalSwap(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_.penalty_)
      + sizeof(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::_impl_.penalty_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, _impl_.front_ping_ms_)>(
          reinterpret_cast<char*>(&_impl_.front_ping_ms_),
          reinterpret_cast<char*>(&other->_impl_.front_ping_ms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[12]);
}

// ===================================================================

class CMsgSteamDatagramClientPingSampleReply_POP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientPingSampleReply_POP>()._impl_._has_bits_);
  static void set_has_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_default_front_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cluster_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_default_e2e_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_default_e2e_score(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_p2p_via_peer_relay_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_best_dc_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_best_dc_score(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_best_dc_via_relay_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_default_dc_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_default_dc_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_default_dc_via_relay_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_test_dc_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_test_dc_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_test_dc_via_relay_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

CMsgSteamDatagramClientPingSampleReply_POP::CMsgSteamDatagramClientPingSampleReply_POP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientPingSampleReply.POP)
}
CMsgSteamDatagramClientPingSampleReply_POP::CMsgSteamDatagramClientPingSampleReply_POP(const CMsgSteamDatagramClientPingSampleReply_POP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientPingSampleReply_POP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alt_addresses_){from._impl_.alt_addresses_}
    , decltype(_impl_.pop_id_){}
    , decltype(_impl_.default_front_ping_ms_){}
    , decltype(_impl_.default_e2e_ping_ms_){}
    , decltype(_impl_.cluster_penalty_){}
    , decltype(_impl_.default_e2e_score_){}
    , decltype(_impl_.p2p_via_peer_relay_pop_id_){}
    , decltype(_impl_.best_dc_ping_ms_){}
    , decltype(_impl_.best_dc_score_){}
    , decltype(_impl_.best_dc_via_relay_pop_id_){}
    , decltype(_impl_.default_dc_ping_ms_){}
    , decltype(_impl_.default_dc_score_){}
    , decltype(_impl_.default_dc_via_relay_pop_id_){}
    , decltype(_impl_.test_dc_ping_ms_){}
    , decltype(_impl_.test_dc_score_){}
    , decltype(_impl_.test_dc_via_relay_pop_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pop_id_, &from._impl_.pop_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.test_dc_via_relay_pop_id_) -
    reinterpret_cast<char*>(&_impl_.pop_id_)) + sizeof(_impl_.test_dc_via_relay_pop_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientPingSampleReply.POP)
}

inline void CMsgSteamDatagramClientPingSampleReply_POP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alt_addresses_){arena}
    , decltype(_impl_.pop_id_){0u}
    , decltype(_impl_.default_front_ping_ms_){0u}
    , decltype(_impl_.default_e2e_ping_ms_){0u}
    , decltype(_impl_.cluster_penalty_){0u}
    , decltype(_impl_.default_e2e_score_){0u}
    , decltype(_impl_.p2p_via_peer_relay_pop_id_){0u}
    , decltype(_impl_.best_dc_ping_ms_){0u}
    , decltype(_impl_.best_dc_score_){0u}
    , decltype(_impl_.best_dc_via_relay_pop_id_){0u}
    , decltype(_impl_.default_dc_ping_ms_){0u}
    , decltype(_impl_.default_dc_score_){0u}
    , decltype(_impl_.default_dc_via_relay_pop_id_){0u}
    , decltype(_impl_.test_dc_ping_ms_){0u}
    , decltype(_impl_.test_dc_score_){0u}
    , decltype(_impl_.test_dc_via_relay_pop_id_){0u}
  };
}

CMsgSteamDatagramClientPingSampleReply_POP::~CMsgSteamDatagramClientPingSampleReply_POP() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientPingSampleReply.POP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientPingSampleReply_POP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.alt_addresses_.~RepeatedPtrField();
}

void CMsgSteamDatagramClientPingSampleReply_POP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientPingSampleReply_POP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientPingSampleReply.POP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.alt_addresses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.pop_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.best_dc_score_) -
        reinterpret_cast<char*>(&_impl_.pop_id_)) + sizeof(_impl_.best_dc_score_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.best_dc_via_relay_pop_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.test_dc_via_relay_pop_id_) -
        reinterpret_cast<char*>(&_impl_.best_dc_via_relay_pop_id_)) + sizeof(_impl_.test_dc_via_relay_pop_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientPingSampleReply_POP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 pop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_pop_id(&has_bits);
          _impl_.pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 default_front_ping_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_default_front_ping_ms(&has_bits);
          _impl_.default_front_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 default_e2e_ping_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_default_e2e_ping_ms(&has_bits);
          _impl_.default_e2e_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cluster_penalty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cluster_penalty(&has_bits);
          _impl_.cluster_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 default_e2e_score = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_default_e2e_score(&has_bits);
          _impl_.default_e2e_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 p2p_via_peer_relay_pop_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_p2p_via_peer_relay_pop_id(&has_bits);
          _impl_.p2p_via_peer_relay_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alt_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_dc_ping_ms = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_best_dc_ping_ms(&has_bits);
          _impl_.best_dc_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_dc_score = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_best_dc_score(&has_bits);
          _impl_.best_dc_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 best_dc_via_relay_pop_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_best_dc_via_relay_pop_id(&has_bits);
          _impl_.best_dc_via_relay_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 default_dc_ping_ms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_default_dc_ping_ms(&has_bits);
          _impl_.default_dc_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 default_dc_score = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_default_dc_score(&has_bits);
          _impl_.default_dc_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 default_dc_via_relay_pop_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_default_dc_via_relay_pop_id(&has_bits);
          _impl_.default_dc_via_relay_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 test_dc_ping_ms = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_test_dc_ping_ms(&has_bits);
          _impl_.test_dc_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 test_dc_score = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_test_dc_score(&has_bits);
          _impl_.test_dc_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 test_dc_via_relay_pop_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_test_dc_via_relay_pop_id(&has_bits);
          _impl_.test_dc_via_relay_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientPingSampleReply_POP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientPingSampleReply.POP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 pop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_pop_id(), target);
  }

  // optional uint32 default_front_ping_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_default_front_ping_ms(), target);
  }

  // optional uint32 default_e2e_ping_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_default_e2e_ping_ms(), target);
  }

  // optional uint32 cluster_penalty = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cluster_penalty(), target);
  }

  // optional uint32 default_e2e_score = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_default_e2e_score(), target);
  }

  // optional fixed32 p2p_via_peer_relay_pop_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_p2p_via_peer_relay_pop_id(), target);
  }

  // repeated .CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alt_addresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_alt_addresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 best_dc_ping_ms = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_best_dc_ping_ms(), target);
  }

  // optional uint32 best_dc_score = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_best_dc_score(), target);
  }

  // optional fixed32 best_dc_via_relay_pop_id = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(11, this->_internal_best_dc_via_relay_pop_id(), target);
  }

  // optional uint32 default_dc_ping_ms = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_default_dc_ping_ms(), target);
  }

  // optional uint32 default_dc_score = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_default_dc_score(), target);
  }

  // optional fixed32 default_dc_via_relay_pop_id = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(14, this->_internal_default_dc_via_relay_pop_id(), target);
  }

  // optional uint32 test_dc_ping_ms = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_test_dc_ping_ms(), target);
  }

  // optional uint32 test_dc_score = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_test_dc_score(), target);
  }

  // optional fixed32 test_dc_via_relay_pop_id = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(17, this->_internal_test_dc_via_relay_pop_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientPingSampleReply.POP)
  return target;
}

size_t CMsgSteamDatagramClientPingSampleReply_POP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientPingSampleReply.POP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7;
  total_size += 1UL * this->_internal_alt_addresses_size();
  for (const auto& msg : this->_impl_.alt_addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed32 pop_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 default_front_ping_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_default_front_ping_ms());
    }

    // optional uint32 default_e2e_ping_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_default_e2e_ping_ms());
    }

    // optional uint32 cluster_penalty = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cluster_penalty());
    }

    // optional uint32 default_e2e_score = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_default_e2e_score());
    }

    // optional fixed32 p2p_via_peer_relay_pop_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 best_dc_ping_ms = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_dc_ping_ms());
    }

    // optional uint32 best_dc_score = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_dc_score());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional fixed32 best_dc_via_relay_pop_id = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 default_dc_ping_ms = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_default_dc_ping_ms());
    }

    // optional uint32 default_dc_score = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_default_dc_score());
    }

    // optional fixed32 default_dc_via_relay_pop_id = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional uint32 test_dc_ping_ms = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_test_dc_ping_ms());
    }

    // optional uint32 test_dc_score = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_test_dc_score());
    }

    // optional fixed32 test_dc_via_relay_pop_id = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientPingSampleReply_POP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientPingSampleReply_POP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientPingSampleReply_POP::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientPingSampleReply_POP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientPingSampleReply_POP*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientPingSampleReply_POP&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientPingSampleReply.POP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.alt_addresses_.MergeFrom(from._impl_.alt_addresses_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pop_id_ = from._impl_.pop_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.default_front_ping_ms_ = from._impl_.default_front_ping_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.default_e2e_ping_ms_ = from._impl_.default_e2e_ping_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cluster_penalty_ = from._impl_.cluster_penalty_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.default_e2e_score_ = from._impl_.default_e2e_score_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.p2p_via_peer_relay_pop_id_ = from._impl_.p2p_via_peer_relay_pop_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.best_dc_ping_ms_ = from._impl_.best_dc_ping_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.best_dc_score_ = from._impl_.best_dc_score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.best_dc_via_relay_pop_id_ = from._impl_.best_dc_via_relay_pop_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.default_dc_ping_ms_ = from._impl_.default_dc_ping_ms_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.default_dc_score_ = from._impl_.default_dc_score_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.default_dc_via_relay_pop_id_ = from._impl_.default_dc_via_relay_pop_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.test_dc_ping_ms_ = from._impl_.test_dc_ping_ms_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.test_dc_score_ = from._impl_.test_dc_score_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.test_dc_via_relay_pop_id_ = from._impl_.test_dc_via_relay_pop_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientPingSampleReply_POP::CopyFrom(const CMsgSteamDatagramClientPingSampleReply_POP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientPingSampleReply.POP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientPingSampleReply_POP::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientPingSampleReply_POP::InternalSwap(CMsgSteamDatagramClientPingSampleReply_POP* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.alt_addresses_.InternalSwap(&other->_impl_.alt_addresses_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_POP, _impl_.test_dc_via_relay_pop_id_)
      + sizeof(CMsgSteamDatagramClientPingSampleReply_POP::_impl_.test_dc_via_relay_pop_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_POP, _impl_.pop_id_)>(
          reinterpret_cast<char*>(&_impl_.pop_id_),
          reinterpret_cast<char*>(&other->_impl_.pop_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientPingSampleReply_POP::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[13]);
}

// ===================================================================

class CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>()._impl_._has_bits_);
  static void set_has_data_center_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_best_dc_via_relay_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_best_dc_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
}
CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter(const CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_center_id_){}
    , decltype(_impl_.best_dc_via_relay_pop_id_){}
    , decltype(_impl_.best_dc_ping_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.data_center_id_, &from._impl_.data_center_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.best_dc_ping_ms_) -
    reinterpret_cast<char*>(&_impl_.data_center_id_)) + sizeof(_impl_.best_dc_ping_ms_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
}

inline void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_center_id_){0u}
    , decltype(_impl_.best_dc_via_relay_pop_id_){0u}
    , decltype(_impl_.best_dc_ping_ms_){0u}
  };
}

CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::~CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.data_center_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.best_dc_ping_ms_) -
        reinterpret_cast<char*>(&_impl_.data_center_id_)) + sizeof(_impl_.best_dc_ping_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 data_center_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_data_center_id(&has_bits);
          _impl_.data_center_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 best_dc_via_relay_pop_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_best_dc_via_relay_pop_id(&has_bits);
          _impl_.best_dc_via_relay_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_dc_ping_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_best_dc_ping_ms(&has_bits);
          _impl_.best_dc_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 data_center_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_data_center_id(), target);
  }

  // optional fixed32 best_dc_via_relay_pop_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_best_dc_via_relay_pop_id(), target);
  }

  // optional uint32 best_dc_ping_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_best_dc_ping_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  return target;
}

size_t CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed32 data_center_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 best_dc_via_relay_pop_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 best_dc_ping_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_dc_ping_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.data_center_id_ = from._impl_.data_center_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.best_dc_via_relay_pop_id_ = from._impl_.best_dc_via_relay_pop_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.best_dc_ping_ms_ = from._impl_.best_dc_ping_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::CopyFrom(const CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::InternalSwap(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_.best_dc_ping_ms_)
      + sizeof(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::_impl_.best_dc_ping_ms_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, _impl_.data_center_id_)>(
          reinterpret_cast<char*>(&_impl_.data_center_id_),
          reinterpret_cast<char*>(&other->_impl_.data_center_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[14]);
}

// ===================================================================

class CMsgSteamDatagramClientPingSampleReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientPingSampleReply>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_relay_override_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgTOSTreatment& tos(const CMsgSteamDatagramClientPingSampleReply* msg);
  static void set_has_tos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgTOSTreatment&
CMsgSteamDatagramClientPingSampleReply::_Internal::tos(const CMsgSteamDatagramClientPingSampleReply* msg) {
  return *msg->_impl_.tos_;
}
CMsgSteamDatagramClientPingSampleReply::CMsgSteamDatagramClientPingSampleReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientPingSampleReply)
}
CMsgSteamDatagramClientPingSampleReply::CMsgSteamDatagramClientPingSampleReply(const CMsgSteamDatagramClientPingSampleReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientPingSampleReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pops_){from._impl_.pops_}
    , decltype(_impl_.legacy_data_centers_){from._impl_.legacy_data_centers_}
    , decltype(_impl_.tos_){nullptr}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.relay_override_active_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tos()) {
    _this->_impl_.tos_ = new ::CMsgTOSTreatment(*from._impl_.tos_);
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.relay_override_active_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.relay_override_active_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientPingSampleReply)
}

inline void CMsgSteamDatagramClientPingSampleReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pops_){arena}
    , decltype(_impl_.legacy_data_centers_){arena}
    , decltype(_impl_.tos_){nullptr}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.relay_override_active_){false}
  };
}

CMsgSteamDatagramClientPingSampleReply::~CMsgSteamDatagramClientPingSampleReply() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientPingSampleReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientPingSampleReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pops_.~RepeatedPtrField();
  _impl_.legacy_data_centers_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.tos_;
}

void CMsgSteamDatagramClientPingSampleReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientPingSampleReply::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientPingSampleReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pops_.Clear();
  _impl_.legacy_data_centers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tos_ != nullptr);
    _impl_.tos_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.relay_override_active_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.relay_override_active_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientPingSampleReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramClientPingSampleReply.POP pops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_legacy_data_centers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool relay_override_active = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_relay_override_active(&has_bits);
          _impl_.relay_override_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgTOSTreatment tos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_tos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientPingSampleReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientPingSampleReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // repeated .CMsgSteamDatagramClientPingSampleReply.POP pops = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pops_size()); i < n; i++) {
    const auto& repfield = this->_internal_pops(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_legacy_data_centers_size()); i < n; i++) {
    const auto& repfield = this->_internal_legacy_data_centers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool relay_override_active = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_relay_override_active(), target);
  }

  // optional .CMsgTOSTreatment tos = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::tos(this),
        _Internal::tos(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientPingSampleReply)
  return target;
}

size_t CMsgSteamDatagramClientPingSampleReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientPingSampleReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSteamDatagramClientPingSampleReply.POP pops = 2;
  total_size += 1UL * this->_internal_pops_size();
  for (const auto& msg : this->_impl_.pops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3;
  total_size += 1UL * this->_internal_legacy_data_centers_size();
  for (const auto& msg : this->_impl_.legacy_data_centers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTOSTreatment tos = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tos_);
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool relay_override_active = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientPingSampleReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientPingSampleReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientPingSampleReply::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientPingSampleReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientPingSampleReply*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientPingSampleReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientPingSampleReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pops_.MergeFrom(from._impl_.pops_);
  _this->_impl_.legacy_data_centers_.MergeFrom(from._impl_.legacy_data_centers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tos()->::CMsgTOSTreatment::MergeFrom(
          from._internal_tos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.relay_override_active_ = from._impl_.relay_override_active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientPingSampleReply::CopyFrom(const CMsgSteamDatagramClientPingSampleReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientPingSampleReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientPingSampleReply::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientPingSampleReply::InternalSwap(CMsgSteamDatagramClientPingSampleReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pops_.InternalSwap(&other->_impl_.pops_);
  _impl_.legacy_data_centers_.InternalSwap(&other->_impl_.legacy_data_centers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply, _impl_.relay_override_active_)
      + sizeof(CMsgSteamDatagramClientPingSampleReply::_impl_.relay_override_active_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientPingSampleReply, _impl_.tos_)>(
          reinterpret_cast<char*>(&_impl_.tos_),
          reinterpret_cast<char*>(&other->_impl_.tos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientPingSampleReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[15]);
}

// ===================================================================

class CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>()._impl_._has_bits_);
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_front_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_back_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seconds_until_down(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
}
CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(const CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientSwitchedPrimary_RouterQuality* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.score_){}
    , decltype(_impl_.front_ping_){}
    , decltype(_impl_.back_ping_){}
    , decltype(_impl_.seconds_until_down_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.score_, &from._impl_.score_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seconds_until_down_) -
    reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.seconds_until_down_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
}

inline void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.score_){0u}
    , decltype(_impl_.front_ping_){0u}
    , decltype(_impl_.back_ping_){0u}
    , decltype(_impl_.seconds_until_down_){0u}
  };
}

CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::~CMsgSteamDatagramClientSwitchedPrimary_RouterQuality() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seconds_until_down_) -
        reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.seconds_until_down_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 score = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 front_ping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_front_ping(&has_bits);
          _impl_.front_ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 back_ping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_back_ping(&has_bits);
          _impl_.back_ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_down = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seconds_until_down(&has_bits);
          _impl_.seconds_until_down_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 score = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_score(), target);
  }

  // optional uint32 front_ping = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_front_ping(), target);
  }

  // optional uint32 back_ping = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_back_ping(), target);
  }

  // optional uint32 seconds_until_down = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_seconds_until_down(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  return target;
}

size_t CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 score = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_score());
    }

    // optional uint32 front_ping = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_front_ping());
    }

    // optional uint32 back_ping = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_back_ping());
    }

    // optional uint32 seconds_until_down = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_down());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientSwitchedPrimary_RouterQuality&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.front_ping_ = from._impl_.front_ping_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.back_ping_ = from._impl_.back_ping_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seconds_until_down_ = from._impl_.seconds_until_down_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::CopyFrom(const CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::InternalSwap(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.seconds_until_down_)
      + sizeof(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::_impl_.seconds_until_down_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, _impl_.score_)>(
          reinterpret_cast<char*>(&_impl_.score_),
          reinterpret_cast<char*>(&other->_impl_.score_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[16]);
}

// ===================================================================

class CMsgSteamDatagramClientSwitchedPrimary::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramClientSwitchedPrimary>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_from_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_from_port(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_from_router_cluster(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_from_active_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_from_active_packets_recv(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_from_dropped_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gap_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& from_quality_now(const CMsgSteamDatagramClientSwitchedPrimary* msg);
  static void set_has_from_quality_now(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& to_quality_now(const CMsgSteamDatagramClientSwitchedPrimary* msg);
  static void set_has_to_quality_now(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& from_quality_then(const CMsgSteamDatagramClientSwitchedPrimary* msg);
  static void set_has_from_quality_then(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality& to_quality_then(const CMsgSteamDatagramClientSwitchedPrimary* msg);
  static void set_has_to_quality_then(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality&
CMsgSteamDatagramClientSwitchedPrimary::_Internal::from_quality_now(const CMsgSteamDatagramClientSwitchedPrimary* msg) {
  return *msg->_impl_.from_quality_now_;
}
const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality&
CMsgSteamDatagramClientSwitchedPrimary::_Internal::to_quality_now(const CMsgSteamDatagramClientSwitchedPrimary* msg) {
  return *msg->_impl_.to_quality_now_;
}
const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality&
CMsgSteamDatagramClientSwitchedPrimary::_Internal::from_quality_then(const CMsgSteamDatagramClientSwitchedPrimary* msg) {
  return *msg->_impl_.from_quality_then_;
}
const ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality&
CMsgSteamDatagramClientSwitchedPrimary::_Internal::to_quality_then(const CMsgSteamDatagramClientSwitchedPrimary* msg) {
  return *msg->_impl_.to_quality_then_;
}
CMsgSteamDatagramClientSwitchedPrimary::CMsgSteamDatagramClientSwitchedPrimary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramClientSwitchedPrimary)
}
CMsgSteamDatagramClientSwitchedPrimary::CMsgSteamDatagramClientSwitchedPrimary(const CMsgSteamDatagramClientSwitchedPrimary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramClientSwitchedPrimary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_dropped_reason_){}
    , decltype(_impl_.from_quality_now_){nullptr}
    , decltype(_impl_.to_quality_now_){nullptr}
    , decltype(_impl_.from_quality_then_){nullptr}
    , decltype(_impl_.to_quality_then_){nullptr}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.from_ip_){}
    , decltype(_impl_.from_port_){}
    , decltype(_impl_.from_router_cluster_){}
    , decltype(_impl_.from_active_time_){}
    , decltype(_impl_.from_active_packets_recv_){}
    , decltype(_impl_.gap_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.from_dropped_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_dropped_reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_from_dropped_reason()) {
    _this->_impl_.from_dropped_reason_.Set(from._internal_from_dropped_reason(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_from_quality_now()) {
    _this->_impl_.from_quality_now_ = new ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(*from._impl_.from_quality_now_);
  }
  if (from._internal_has_to_quality_now()) {
    _this->_impl_.to_quality_now_ = new ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(*from._impl_.to_quality_now_);
  }
  if (from._internal_has_from_quality_then()) {
    _this->_impl_.from_quality_then_ = new ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(*from._impl_.from_quality_then_);
  }
  if (from._internal_has_to_quality_then()) {
    _this->_impl_.to_quality_then_ = new ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality(*from._impl_.to_quality_then_);
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gap_ms_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.gap_ms_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramClientSwitchedPrimary)
}

inline void CMsgSteamDatagramClientSwitchedPrimary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_dropped_reason_){}
    , decltype(_impl_.from_quality_now_){nullptr}
    , decltype(_impl_.to_quality_now_){nullptr}
    , decltype(_impl_.from_quality_then_){nullptr}
    , decltype(_impl_.to_quality_then_){nullptr}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.from_ip_){0u}
    , decltype(_impl_.from_port_){0u}
    , decltype(_impl_.from_router_cluster_){0u}
    , decltype(_impl_.from_active_time_){0u}
    , decltype(_impl_.from_active_packets_recv_){0u}
    , decltype(_impl_.gap_ms_){0u}
  };
  _impl_.from_dropped_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_dropped_reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramClientSwitchedPrimary::~CMsgSteamDatagramClientSwitchedPrimary() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramClientSwitchedPrimary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramClientSwitchedPrimary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_dropped_reason_.Destroy();
  if (this != internal_default_instance()) delete _impl_.from_quality_now_;
  if (this != internal_default_instance()) delete _impl_.to_quality_now_;
  if (this != internal_default_instance()) delete _impl_.from_quality_then_;
  if (this != internal_default_instance()) delete _impl_.to_quality_then_;
}

void CMsgSteamDatagramClientSwitchedPrimary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramClientSwitchedPrimary::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramClientSwitchedPrimary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.from_dropped_reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.from_quality_now_ != nullptr);
      _impl_.from_quality_now_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.to_quality_now_ != nullptr);
      _impl_.to_quality_now_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.from_quality_then_ != nullptr);
      _impl_.from_quality_then_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.to_quality_then_ != nullptr);
      _impl_.to_quality_then_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_port_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.from_port_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.from_router_cluster_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gap_ms_) -
        reinterpret_cast<char*>(&_impl_.from_router_cluster_)) + sizeof(_impl_.gap_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramClientSwitchedPrimary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_from_ip(&has_bits);
          _impl_.from_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_from_port(&has_bits);
          _impl_.from_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_router_cluster = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_from_router_cluster(&has_bits);
          _impl_.from_router_cluster_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from_active_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from_active_time(&has_bits);
          _impl_.from_active_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from_active_packets_recv = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_from_active_packets_recv(&has_bits);
          _impl_.from_active_packets_recv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string from_dropped_reason = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_from_dropped_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramClientSwitchedPrimary.from_dropped_reason");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gap_ms = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_gap_ms(&has_bits);
          _impl_.gap_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_from_quality_now(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_quality_now(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_from_quality_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_quality_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramClientSwitchedPrimary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramClientSwitchedPrimary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // optional fixed32 from_ip = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_from_ip(), target);
  }

  // optional uint32 from_port = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_from_port(), target);
  }

  // optional fixed32 from_router_cluster = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_from_router_cluster(), target);
  }

  // optional uint32 from_active_time = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_from_active_time(), target);
  }

  // optional uint32 from_active_packets_recv = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_from_active_packets_recv(), target);
  }

  // optional string from_dropped_reason = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_from_dropped_reason().data(), static_cast<int>(this->_internal_from_dropped_reason().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramClientSwitchedPrimary.from_dropped_reason");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_from_dropped_reason(), target);
  }

  // optional uint32 gap_ms = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_gap_ms(), target);
  }

  // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::from_quality_now(this),
        _Internal::from_quality_now(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::to_quality_now(this),
        _Internal::to_quality_now(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::from_quality_then(this),
        _Internal::from_quality_then(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::to_quality_then(this),
        _Internal::to_quality_then(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramClientSwitchedPrimary)
  return target;
}

size_t CMsgSteamDatagramClientSwitchedPrimary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramClientSwitchedPrimary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string from_dropped_reason = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_dropped_reason());
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.from_quality_now_);
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.to_quality_now_);
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.from_quality_then_);
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.to_quality_then_);
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional fixed32 from_ip = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 from_port = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_port());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional fixed32 from_router_cluster = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 from_active_time = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_active_time());
    }

    // optional uint32 from_active_packets_recv = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_active_packets_recv());
    }

    // optional uint32 gap_ms = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gap_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramClientSwitchedPrimary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramClientSwitchedPrimary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramClientSwitchedPrimary::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramClientSwitchedPrimary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramClientSwitchedPrimary*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramClientSwitchedPrimary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramClientSwitchedPrimary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_from_dropped_reason(from._internal_from_dropped_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_from_quality_now()->::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeFrom(
          from._internal_from_quality_now());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_to_quality_now()->::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeFrom(
          from._internal_to_quality_now());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_from_quality_then()->::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeFrom(
          from._internal_from_quality_then());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_to_quality_then()->::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::MergeFrom(
          from._internal_to_quality_then());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.from_ip_ = from._impl_.from_ip_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.from_port_ = from._impl_.from_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.from_router_cluster_ = from._impl_.from_router_cluster_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.from_active_time_ = from._impl_.from_active_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.from_active_packets_recv_ = from._impl_.from_active_packets_recv_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.gap_ms_ = from._impl_.gap_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramClientSwitchedPrimary::CopyFrom(const CMsgSteamDatagramClientSwitchedPrimary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramClientSwitchedPrimary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramClientSwitchedPrimary::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramClientSwitchedPrimary::InternalSwap(CMsgSteamDatagramClientSwitchedPrimary* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_dropped_reason_, lhs_arena,
      &other->_impl_.from_dropped_reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientSwitchedPrimary, _impl_.gap_ms_)
      + sizeof(CMsgSteamDatagramClientSwitchedPrimary::_impl_.gap_ms_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramClientSwitchedPrimary, _impl_.from_quality_now_)>(
          reinterpret_cast<char*>(&_impl_.from_quality_now_),
          reinterpret_cast<char*>(&other->_impl_.from_quality_now_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramClientSwitchedPrimary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[17]);
}

// ===================================================================

class CMsgSteamDatagramConnectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectRequest>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_my_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ping_est_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_virtual_port(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gameserver_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgSteamDatagramSessionCryptInfoSigned& crypt(const CMsgSteamDatagramConnectRequest* msg);
  static void set_has_crypt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamDatagramCertificateSigned& cert(const CMsgSteamDatagramConnectRequest* msg);
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_routing_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_legacy_client_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSteamDatagramSessionCryptInfoSigned&
CMsgSteamDatagramConnectRequest::_Internal::crypt(const CMsgSteamDatagramConnectRequest* msg) {
  return *msg->_impl_.crypt_;
}
const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramConnectRequest::_Internal::cert(const CMsgSteamDatagramConnectRequest* msg) {
  return *msg->_impl_.cert_;
}
void CMsgSteamDatagramConnectRequest::clear_crypt() {
  if (_impl_.crypt_ != nullptr) _impl_.crypt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgSteamDatagramConnectRequest::clear_cert() {
  if (_impl_.cert_ != nullptr) _impl_.cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgSteamDatagramConnectRequest::CMsgSteamDatagramConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectRequest)
}
CMsgSteamDatagramConnectRequest::CMsgSteamDatagramConnectRequest(const CMsgSteamDatagramConnectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crypt_){nullptr}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.gameserver_relay_session_id_){}
    , decltype(_impl_.legacy_client_steam_id_){}
    , decltype(_impl_.my_timestamp_){}
    , decltype(_impl_.ping_est_ms_){}
    , decltype(_impl_.virtual_port_){}
    , decltype(_impl_.routing_secret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_crypt()) {
    _this->_impl_.crypt_ = new ::CMsgSteamDatagramSessionCryptInfoSigned(*from._impl_.crypt_);
  }
  if (from._internal_has_cert()) {
    _this->_impl_.cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.cert_);
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.routing_secret_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.routing_secret_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectRequest)
}

inline void CMsgSteamDatagramConnectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crypt_){nullptr}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.gameserver_relay_session_id_){0u}
    , decltype(_impl_.legacy_client_steam_id_){uint64_t{0u}}
    , decltype(_impl_.my_timestamp_){uint64_t{0u}}
    , decltype(_impl_.ping_est_ms_){0u}
    , decltype(_impl_.virtual_port_){0u}
    , decltype(_impl_.routing_secret_){uint64_t{0u}}
  };
}

CMsgSteamDatagramConnectRequest::~CMsgSteamDatagramConnectRequest() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.crypt_;
  if (this != internal_default_instance()) delete _impl_.cert_;
}

void CMsgSteamDatagramConnectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.crypt_ != nullptr);
      _impl_.crypt_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cert_ != nullptr);
      _impl_.cert_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.virtual_port_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.virtual_port_));
  }
  _impl_.routing_secret_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameserver_relay_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameserver_relay_session_id(&has_bits);
          _impl_.gameserver_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_client_steam_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_client_steam_id(&has_bits);
          _impl_.legacy_client_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 my_timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_my_timestamp(&has_bits);
          _impl_.my_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ping_est_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ping_est_ms(&has_bits);
          _impl_.ping_est_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_crypt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramCertificateSigned cert = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 virtual_port = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_virtual_port(&has_bits);
          _impl_.virtual_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 routing_secret = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_routing_secret(&has_bits);
          _impl_.routing_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // optional uint32 gameserver_relay_session_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameserver_relay_session_id(), target);
  }

  // optional fixed64 legacy_client_steam_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_client_steam_id(), target);
  }

  // optional fixed64 my_timestamp = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_my_timestamp(), target);
  }

  // optional uint32 ping_est_ms = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ping_est_ms(), target);
  }

  // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::crypt(this),
        _Internal::crypt(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramCertificateSigned cert = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::cert(this),
        _Internal::cert(this).GetCachedSize(), target, stream);
  }

  // optional uint32 virtual_port = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_virtual_port(), target);
  }

  // optional fixed64 routing_secret = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_routing_secret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectRequest)
  return target;
}

size_t CMsgSteamDatagramConnectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crypt_);
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_);
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 gameserver_relay_session_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameserver_relay_session_id());
    }

    // optional fixed64 legacy_client_steam_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional fixed64 my_timestamp = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 ping_est_ms = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ping_est_ms());
    }

    // optional uint32 virtual_port = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_virtual_port());
    }

  }
  // optional fixed64 routing_secret = 10;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectRequest::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectRequest*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_crypt()->::CMsgSteamDatagramSessionCryptInfoSigned::MergeFrom(
          from._internal_crypt());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_cert());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gameserver_relay_session_id_ = from._impl_.gameserver_relay_session_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.legacy_client_steam_id_ = from._impl_.legacy_client_steam_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.my_timestamp_ = from._impl_.my_timestamp_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ping_est_ms_ = from._impl_.ping_est_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.virtual_port_ = from._impl_.virtual_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_routing_secret(from._internal_routing_secret());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectRequest::CopyFrom(const CMsgSteamDatagramConnectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectRequest::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectRequest::InternalSwap(CMsgSteamDatagramConnectRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectRequest, _impl_.routing_secret_)
      + sizeof(CMsgSteamDatagramConnectRequest::_impl_.routing_secret_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectRequest, _impl_.crypt_)>(
          reinterpret_cast<char*>(&_impl_.crypt_),
          reinterpret_cast<char*>(&other->_impl_.crypt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[18]);
}

// ===================================================================

class CMsgSteamDatagramConnectOK::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectOK>()._impl_._has_bits_);
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_your_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_delay_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gameserver_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgSteamDatagramSessionCryptInfoSigned& crypt(const CMsgSteamDatagramConnectOK* msg);
  static void set_has_crypt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamDatagramCertificateSigned& cert(const CMsgSteamDatagramConnectOK* msg);
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSteamDatagramSessionCryptInfoSigned&
CMsgSteamDatagramConnectOK::_Internal::crypt(const CMsgSteamDatagramConnectOK* msg) {
  return *msg->_impl_.crypt_;
}
const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramConnectOK::_Internal::cert(const CMsgSteamDatagramConnectOK* msg) {
  return *msg->_impl_.cert_;
}
void CMsgSteamDatagramConnectOK::clear_crypt() {
  if (_impl_.crypt_ != nullptr) _impl_.crypt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgSteamDatagramConnectOK::clear_cert() {
  if (_impl_.cert_ != nullptr) _impl_.cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgSteamDatagramConnectOK::CMsgSteamDatagramConnectOK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectOK)
}
CMsgSteamDatagramConnectOK::CMsgSteamDatagramConnectOK(const CMsgSteamDatagramConnectOK& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectOK* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crypt_){nullptr}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.gameserver_relay_session_id_){}
    , decltype(_impl_.your_timestamp_){}
    , decltype(_impl_.delay_time_usec_){}
    , decltype(_impl_.server_connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_crypt()) {
    _this->_impl_.crypt_ = new ::CMsgSteamDatagramSessionCryptInfoSigned(*from._impl_.crypt_);
  }
  if (from._internal_has_cert()) {
    _this->_impl_.cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.cert_);
  }
  ::memcpy(&_impl_.client_connection_id_, &from._impl_.client_connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.server_connection_id_) -
    reinterpret_cast<char*>(&_impl_.client_connection_id_)) + sizeof(_impl_.server_connection_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectOK)
}

inline void CMsgSteamDatagramConnectOK::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crypt_){nullptr}
    , decltype(_impl_.cert_){nullptr}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.gameserver_relay_session_id_){0u}
    , decltype(_impl_.your_timestamp_){uint64_t{0u}}
    , decltype(_impl_.delay_time_usec_){0u}
    , decltype(_impl_.server_connection_id_){0u}
  };
}

CMsgSteamDatagramConnectOK::~CMsgSteamDatagramConnectOK() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectOK)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectOK::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.crypt_;
  if (this != internal_default_instance()) delete _impl_.cert_;
}

void CMsgSteamDatagramConnectOK::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectOK::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectOK)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.crypt_ != nullptr);
      _impl_.crypt_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cert_ != nullptr);
      _impl_.cert_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.client_connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_connection_id_) -
        reinterpret_cast<char*>(&_impl_.client_connection_id_)) + sizeof(_impl_.server_connection_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectOK::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 client_connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameserver_relay_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameserver_relay_session_id(&has_bits);
          _impl_.gameserver_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 your_timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_your_timestamp(&has_bits);
          _impl_.your_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 delay_time_usec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_delay_time_usec(&has_bits);
          _impl_.delay_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_crypt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramCertificateSigned cert = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_server_connection_id(&has_bits);
          _impl_.server_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectOK::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectOK)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 client_connection_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_client_connection_id(), target);
  }

  // optional uint32 gameserver_relay_session_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameserver_relay_session_id(), target);
  }

  // optional fixed64 your_timestamp = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_your_timestamp(), target);
  }

  // optional uint32 delay_time_usec = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_delay_time_usec(), target);
  }

  // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::crypt(this),
        _Internal::crypt(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramCertificateSigned cert = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::cert(this),
        _Internal::cert(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 server_connection_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_server_connection_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectOK)
  return target;
}

size_t CMsgSteamDatagramConnectOK::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectOK)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crypt_);
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_);
    }

    // optional fixed32 client_connection_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 gameserver_relay_session_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameserver_relay_session_id());
    }

    // optional fixed64 your_timestamp = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint32 delay_time_usec = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_delay_time_usec());
    }

    // optional fixed32 server_connection_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectOK::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectOK::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectOK::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectOK::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectOK*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectOK&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectOK)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_crypt()->::CMsgSteamDatagramSessionCryptInfoSigned::MergeFrom(
          from._internal_crypt());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_cert());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gameserver_relay_session_id_ = from._impl_.gameserver_relay_session_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.your_timestamp_ = from._impl_.your_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.delay_time_usec_ = from._impl_.delay_time_usec_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.server_connection_id_ = from._impl_.server_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectOK::CopyFrom(const CMsgSteamDatagramConnectOK& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectOK)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectOK::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectOK::InternalSwap(CMsgSteamDatagramConnectOK* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectOK, _impl_.server_connection_id_)
      + sizeof(CMsgSteamDatagramConnectOK::_impl_.server_connection_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectOK, _impl_.crypt_)>(
          reinterpret_cast<char*>(&_impl_.crypt_),
          reinterpret_cast<char*>(&other->_impl_.crypt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectOK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[19]);
}

// ===================================================================

class CMsgSteamNetworkingP2PSDRRoutingSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamNetworkingP2PSDRRoutingSummary>()._impl_._has_bits_);
  static void set_has_initial_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_initial_ping_front_local(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_initial_ping_front_remote(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_initial_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_initial_pop_local(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_initial_pop_remote(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_best_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_best_ping_front_local(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_best_ping_front_remote(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_best_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_best_pop_local(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_best_pop_remote(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_best_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_negotiation_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_selected_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgSteamNetworkingP2PSDRRoutingSummary::CMsgSteamNetworkingP2PSDRRoutingSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamNetworkingP2PSDRRoutingSummary)
}
CMsgSteamNetworkingP2PSDRRoutingSummary::CMsgSteamNetworkingP2PSDRRoutingSummary(const CMsgSteamNetworkingP2PSDRRoutingSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamNetworkingP2PSDRRoutingSummary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_ping_){}
    , decltype(_impl_.initial_ping_front_local_){}
    , decltype(_impl_.initial_ping_front_remote_){}
    , decltype(_impl_.initial_score_){}
    , decltype(_impl_.initial_pop_local_){}
    , decltype(_impl_.initial_pop_remote_){}
    , decltype(_impl_.negotiation_ms_){}
    , decltype(_impl_.selected_seconds_){}
    , decltype(_impl_.best_ping_){}
    , decltype(_impl_.best_ping_front_local_){}
    , decltype(_impl_.best_ping_front_remote_){}
    , decltype(_impl_.best_score_){}
    , decltype(_impl_.best_pop_local_){}
    , decltype(_impl_.best_pop_remote_){}
    , decltype(_impl_.best_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.initial_ping_, &from._impl_.initial_ping_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.best_time_) -
    reinterpret_cast<char*>(&_impl_.initial_ping_)) + sizeof(_impl_.best_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamNetworkingP2PSDRRoutingSummary)
}

inline void CMsgSteamNetworkingP2PSDRRoutingSummary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_ping_){0u}
    , decltype(_impl_.initial_ping_front_local_){0u}
    , decltype(_impl_.initial_ping_front_remote_){0u}
    , decltype(_impl_.initial_score_){0u}
    , decltype(_impl_.initial_pop_local_){0u}
    , decltype(_impl_.initial_pop_remote_){0u}
    , decltype(_impl_.negotiation_ms_){0u}
    , decltype(_impl_.selected_seconds_){0u}
    , decltype(_impl_.best_ping_){0u}
    , decltype(_impl_.best_ping_front_local_){0u}
    , decltype(_impl_.best_ping_front_remote_){0u}
    , decltype(_impl_.best_score_){0u}
    , decltype(_impl_.best_pop_local_){0u}
    , decltype(_impl_.best_pop_remote_){0u}
    , decltype(_impl_.best_time_){0u}
  };
}

CMsgSteamNetworkingP2PSDRRoutingSummary::~CMsgSteamNetworkingP2PSDRRoutingSummary() {
  // @@protoc_insertion_point(destructor:CMsgSteamNetworkingP2PSDRRoutingSummary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamNetworkingP2PSDRRoutingSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamNetworkingP2PSDRRoutingSummary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamNetworkingP2PSDRRoutingSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamNetworkingP2PSDRRoutingSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.initial_ping_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selected_seconds_) -
        reinterpret_cast<char*>(&_impl_.initial_ping_)) + sizeof(_impl_.selected_seconds_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.best_ping_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.best_time_) -
        reinterpret_cast<char*>(&_impl_.best_ping_)) + sizeof(_impl_.best_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamNetworkingP2PSDRRoutingSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 initial_ping = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_initial_ping(&has_bits);
          _impl_.initial_ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_ping_front_local = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_initial_ping_front_local(&has_bits);
          _impl_.initial_ping_front_local_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_ping_front_remote = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_initial_ping_front_remote(&has_bits);
          _impl_.initial_ping_front_remote_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_initial_score(&has_bits);
          _impl_.initial_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 initial_pop_local = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_initial_pop_local(&has_bits);
          _impl_.initial_pop_local_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 initial_pop_remote = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_initial_pop_remote(&has_bits);
          _impl_.initial_pop_remote_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 negotiation_ms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_negotiation_ms(&has_bits);
          _impl_.negotiation_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selected_seconds = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_selected_seconds(&has_bits);
          _impl_.selected_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_ping = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_best_ping(&has_bits);
          _impl_.best_ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_ping_front_local = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_best_ping_front_local(&has_bits);
          _impl_.best_ping_front_local_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_ping_front_remote = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_best_ping_front_remote(&has_bits);
          _impl_.best_ping_front_remote_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_score = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_best_score(&has_bits);
          _impl_.best_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 best_pop_local = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_best_pop_local(&has_bits);
          _impl_.best_pop_local_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 best_pop_remote = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_best_pop_remote(&has_bits);
          _impl_.best_pop_remote_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 best_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_best_time(&has_bits);
          _impl_.best_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamNetworkingP2PSDRRoutingSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamNetworkingP2PSDRRoutingSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 initial_ping = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_initial_ping(), target);
  }

  // optional uint32 initial_ping_front_local = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_initial_ping_front_local(), target);
  }

  // optional uint32 initial_ping_front_remote = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_initial_ping_front_remote(), target);
  }

  // optional uint32 initial_score = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_initial_score(), target);
  }

  // optional fixed32 initial_pop_local = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_initial_pop_local(), target);
  }

  // optional fixed32 initial_pop_remote = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_initial_pop_remote(), target);
  }

  // optional uint32 negotiation_ms = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_negotiation_ms(), target);
  }

  // optional uint32 selected_seconds = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_selected_seconds(), target);
  }

  // optional uint32 best_ping = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_best_ping(), target);
  }

  // optional uint32 best_ping_front_local = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_best_ping_front_local(), target);
  }

  // optional uint32 best_ping_front_remote = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_best_ping_front_remote(), target);
  }

  // optional uint32 best_score = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_best_score(), target);
  }

  // optional fixed32 best_pop_local = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(15, this->_internal_best_pop_local(), target);
  }

  // optional fixed32 best_pop_remote = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(16, this->_internal_best_pop_remote(), target);
  }

  // optional uint32 best_time = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_best_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamNetworkingP2PSDRRoutingSummary)
  return target;
}

size_t CMsgSteamNetworkingP2PSDRRoutingSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamNetworkingP2PSDRRoutingSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 initial_ping = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_ping());
    }

    // optional uint32 initial_ping_front_local = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_ping_front_local());
    }

    // optional uint32 initial_ping_front_remote = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_ping_front_remote());
    }

    // optional uint32 initial_score = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_score());
    }

    // optional fixed32 initial_pop_local = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 initial_pop_remote = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 negotiation_ms = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_negotiation_ms());
    }

    // optional uint32 selected_seconds = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selected_seconds());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 best_ping = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_ping());
    }

    // optional uint32 best_ping_front_local = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_ping_front_local());
    }

    // optional uint32 best_ping_front_remote = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_ping_front_remote());
    }

    // optional uint32 best_score = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_best_score());
    }

    // optional fixed32 best_pop_local = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 best_pop_remote = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional uint32 best_time = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_best_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamNetworkingP2PSDRRoutingSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamNetworkingP2PSDRRoutingSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamNetworkingP2PSDRRoutingSummary::GetClassData() const { return &_class_data_; }


void CMsgSteamNetworkingP2PSDRRoutingSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamNetworkingP2PSDRRoutingSummary*>(&to_msg);
  auto& from = static_cast<const CMsgSteamNetworkingP2PSDRRoutingSummary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamNetworkingP2PSDRRoutingSummary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.initial_ping_ = from._impl_.initial_ping_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.initial_ping_front_local_ = from._impl_.initial_ping_front_local_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.initial_ping_front_remote_ = from._impl_.initial_ping_front_remote_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.initial_score_ = from._impl_.initial_score_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.initial_pop_local_ = from._impl_.initial_pop_local_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.initial_pop_remote_ = from._impl_.initial_pop_remote_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.negotiation_ms_ = from._impl_.negotiation_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.selected_seconds_ = from._impl_.selected_seconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.best_ping_ = from._impl_.best_ping_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.best_ping_front_local_ = from._impl_.best_ping_front_local_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.best_ping_front_remote_ = from._impl_.best_ping_front_remote_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.best_score_ = from._impl_.best_score_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.best_pop_local_ = from._impl_.best_pop_local_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.best_pop_remote_ = from._impl_.best_pop_remote_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.best_time_ = from._impl_.best_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamNetworkingP2PSDRRoutingSummary::CopyFrom(const CMsgSteamNetworkingP2PSDRRoutingSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamNetworkingP2PSDRRoutingSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamNetworkingP2PSDRRoutingSummary::IsInitialized() const {
  return true;
}

void CMsgSteamNetworkingP2PSDRRoutingSummary::InternalSwap(CMsgSteamNetworkingP2PSDRRoutingSummary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.best_time_)
      + sizeof(CMsgSteamNetworkingP2PSDRRoutingSummary::_impl_.best_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamNetworkingP2PSDRRoutingSummary, _impl_.initial_ping_)>(
          reinterpret_cast<char*>(&_impl_.initial_ping_),
          reinterpret_cast<char*>(&other->_impl_.initial_ping_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamNetworkingP2PSDRRoutingSummary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[20]);
}

// ===================================================================

class CMsgSteamDatagramP2PRoutingSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PRoutingSummary>()._impl_._has_bits_);
  static const ::CMsgSteamNetworkingICESessionSummary& ice(const CMsgSteamDatagramP2PRoutingSummary* msg);
  static void set_has_ice(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamNetworkingP2PSDRRoutingSummary& sdr(const CMsgSteamDatagramP2PRoutingSummary* msg);
  static void set_has_sdr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSteamNetworkingICESessionSummary&
CMsgSteamDatagramP2PRoutingSummary::_Internal::ice(const CMsgSteamDatagramP2PRoutingSummary* msg) {
  return *msg->_impl_.ice_;
}
const ::CMsgSteamNetworkingP2PSDRRoutingSummary&
CMsgSteamDatagramP2PRoutingSummary::_Internal::sdr(const CMsgSteamDatagramP2PRoutingSummary* msg) {
  return *msg->_impl_.sdr_;
}
void CMsgSteamDatagramP2PRoutingSummary::clear_ice() {
  if (_impl_.ice_ != nullptr) _impl_.ice_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgSteamDatagramP2PRoutingSummary::CMsgSteamDatagramP2PRoutingSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PRoutingSummary)
}
CMsgSteamDatagramP2PRoutingSummary::CMsgSteamDatagramP2PRoutingSummary(const CMsgSteamDatagramP2PRoutingSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PRoutingSummary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ice_){nullptr}
    , decltype(_impl_.sdr_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ice()) {
    _this->_impl_.ice_ = new ::CMsgSteamNetworkingICESessionSummary(*from._impl_.ice_);
  }
  if (from._internal_has_sdr()) {
    _this->_impl_.sdr_ = new ::CMsgSteamNetworkingP2PSDRRoutingSummary(*from._impl_.sdr_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PRoutingSummary)
}

inline void CMsgSteamDatagramP2PRoutingSummary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ice_){nullptr}
    , decltype(_impl_.sdr_){nullptr}
  };
}

CMsgSteamDatagramP2PRoutingSummary::~CMsgSteamDatagramP2PRoutingSummary() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PRoutingSummary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PRoutingSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ice_;
  if (this != internal_default_instance()) delete _impl_.sdr_;
}

void CMsgSteamDatagramP2PRoutingSummary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PRoutingSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PRoutingSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.ice_ != nullptr);
      _impl_.ice_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sdr_ != nullptr);
      _impl_.sdr_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PRoutingSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamNetworkingICESessionSummary ice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sdr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PRoutingSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PRoutingSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamNetworkingICESessionSummary ice = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ice(this),
        _Internal::ice(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sdr(this),
        _Internal::sdr(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PRoutingSummary)
  return target;
}

size_t CMsgSteamDatagramP2PRoutingSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PRoutingSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSteamNetworkingICESessionSummary ice = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ice_);
    }

    // optional .CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sdr_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PRoutingSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PRoutingSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PRoutingSummary::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PRoutingSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PRoutingSummary*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PRoutingSummary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PRoutingSummary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ice()->::CMsgSteamNetworkingICESessionSummary::MergeFrom(
          from._internal_ice());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sdr()->::CMsgSteamNetworkingP2PSDRRoutingSummary::MergeFrom(
          from._internal_sdr());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PRoutingSummary::CopyFrom(const CMsgSteamDatagramP2PRoutingSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PRoutingSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PRoutingSummary::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PRoutingSummary::InternalSwap(CMsgSteamDatagramP2PRoutingSummary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutingSummary, _impl_.sdr_)
      + sizeof(CMsgSteamDatagramP2PRoutingSummary::_impl_.sdr_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutingSummary, _impl_.ice_)>(
          reinterpret_cast<char*>(&_impl_.ice_),
          reinterpret_cast<char*>(&other->_impl_.ice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PRoutingSummary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[21]);
}

// ===================================================================

class CMsgSteamDatagramConnectionClosed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionClosed>()._impl_._has_bits_);
  static void set_has_to_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_from_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_from_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamNetworkingIdentityLegacyBinary& legacy_from_identity_binary(const CMsgSteamDatagramConnectionClosed* msg);
  static void set_has_legacy_from_identity_binary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_legacy_from_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_legacy_gameserver_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_to_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_from_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_forward_target_relay_routing_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_forward_target_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_relay_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reason_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_routing_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_not_primary_session(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_not_primary_transport(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_relay_override_active(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionClosed* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionClosed* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CMsgSteamDatagramP2PRoutingSummary& p2p_routing_summary(const CMsgSteamDatagramConnectionClosed* msg);
  static void set_has_p2p_routing_summary(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::CMsgSteamNetworkingIdentityLegacyBinary&
CMsgSteamDatagramConnectionClosed::_Internal::legacy_from_identity_binary(const CMsgSteamDatagramConnectionClosed* msg) {
  return *msg->_impl_.legacy_from_identity_binary_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionClosed::_Internal::quality_relay(const CMsgSteamDatagramConnectionClosed* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionClosed::_Internal::quality_e2e(const CMsgSteamDatagramConnectionClosed* msg) {
  return *msg->_impl_.quality_e2e_;
}
const ::CMsgSteamDatagramP2PRoutingSummary&
CMsgSteamDatagramConnectionClosed::_Internal::p2p_routing_summary(const CMsgSteamDatagramConnectionClosed* msg) {
  return *msg->_impl_.p2p_routing_summary_;
}
void CMsgSteamDatagramConnectionClosed::clear_legacy_from_identity_binary() {
  if (_impl_.legacy_from_identity_binary_ != nullptr) _impl_.legacy_from_identity_binary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CMsgSteamDatagramConnectionClosed::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CMsgSteamDatagramConnectionClosed::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CMsgSteamDatagramConnectionClosed::CMsgSteamDatagramConnectionClosed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionClosed)
}
CMsgSteamDatagramConnectionClosed::CMsgSteamDatagramConnectionClosed(const CMsgSteamDatagramConnectionClosed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionClosed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.debug_){}
    , decltype(_impl_.forward_target_relay_routing_token_){}
    , decltype(_impl_.from_identity_string_){}
    , decltype(_impl_.legacy_from_identity_binary_){nullptr}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.legacy_from_steam_id_){}
    , decltype(_impl_.legacy_gameserver_relay_session_id_){}
    , decltype(_impl_.relay_mode_){}
    , decltype(_impl_.reason_code_){}
    , decltype(_impl_.to_connection_id_){}
    , decltype(_impl_.from_connection_id_){}
    , decltype(_impl_.to_relay_session_id_){}
    , decltype(_impl_.from_relay_session_id_){}
    , decltype(_impl_.forward_target_revision_){}
    , decltype(_impl_.routing_secret_){}
    , decltype(_impl_.not_primary_session_){}
    , decltype(_impl_.not_primary_transport_){}
    , decltype(_impl_.relay_override_active_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.debug_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_debug()) {
    _this->_impl_.debug_.Set(from._internal_debug(), 
      _this->GetArenaForAllocation());
  }
  _impl_.forward_target_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forward_target_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forward_target_relay_routing_token()) {
    _this->_impl_.forward_target_relay_routing_token_.Set(from._internal_forward_target_relay_routing_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.from_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_from_identity_string()) {
    _this->_impl_.from_identity_string_.Set(from._internal_from_identity_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_legacy_from_identity_binary()) {
    _this->_impl_.legacy_from_identity_binary_ = new ::CMsgSteamNetworkingIdentityLegacyBinary(*from._impl_.legacy_from_identity_binary_);
  }
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  if (from._internal_has_p2p_routing_summary()) {
    _this->_impl_.p2p_routing_summary_ = new ::CMsgSteamDatagramP2PRoutingSummary(*from._impl_.p2p_routing_summary_);
  }
  ::memcpy(&_impl_.legacy_from_steam_id_, &from._impl_.legacy_from_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.relay_override_active_) -
    reinterpret_cast<char*>(&_impl_.legacy_from_steam_id_)) + sizeof(_impl_.relay_override_active_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionClosed)
}

inline void CMsgSteamDatagramConnectionClosed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.debug_){}
    , decltype(_impl_.forward_target_relay_routing_token_){}
    , decltype(_impl_.from_identity_string_){}
    , decltype(_impl_.legacy_from_identity_binary_){nullptr}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.legacy_from_steam_id_){uint64_t{0u}}
    , decltype(_impl_.legacy_gameserver_relay_session_id_){0u}
    , decltype(_impl_.relay_mode_){0}
    , decltype(_impl_.reason_code_){0u}
    , decltype(_impl_.to_connection_id_){0u}
    , decltype(_impl_.from_connection_id_){0u}
    , decltype(_impl_.to_relay_session_id_){0u}
    , decltype(_impl_.from_relay_session_id_){0u}
    , decltype(_impl_.forward_target_revision_){0u}
    , decltype(_impl_.routing_secret_){uint64_t{0u}}
    , decltype(_impl_.not_primary_session_){false}
    , decltype(_impl_.not_primary_transport_){false}
    , decltype(_impl_.relay_override_active_){false}
  };
  _impl_.debug_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.forward_target_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forward_target_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramConnectionClosed::~CMsgSteamDatagramConnectionClosed() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionClosed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionClosed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.debug_.Destroy();
  _impl_.forward_target_relay_routing_token_.Destroy();
  _impl_.from_identity_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.legacy_from_identity_binary_;
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
  if (this != internal_default_instance()) delete _impl_.p2p_routing_summary_;
}

void CMsgSteamDatagramConnectionClosed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionClosed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionClosed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.debug_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.forward_target_relay_routing_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.from_identity_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.legacy_from_identity_binary_ != nullptr);
      _impl_.legacy_from_identity_binary_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.p2p_routing_summary_ != nullptr);
      _impl_.p2p_routing_summary_->Clear();
    }
  }
  _impl_.legacy_from_steam_id_ = uint64_t{0u};
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.legacy_gameserver_relay_session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.forward_target_revision_) -
        reinterpret_cast<char*>(&_impl_.legacy_gameserver_relay_session_id_)) + sizeof(_impl_.forward_target_revision_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.routing_secret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.relay_override_active_) -
        reinterpret_cast<char*>(&_impl_.routing_secret_)) + sizeof(_impl_.relay_override_active_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionClosed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 legacy_gameserver_relay_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_legacy_gameserver_relay_session_id(&has_bits);
          _impl_.legacy_gameserver_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_from_steam_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_from_steam_id(&has_bits);
          _impl_.legacy_from_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4 [default = None];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgSteamDatagramConnectionClosed_ERelayMode_IsValid(val))) {
            _internal_set_relay_mode(static_cast<::CMsgSteamDatagramConnectionClosed_ERelayMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string debug = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_debug();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramConnectionClosed.debug");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reason_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_reason_code(&has_bits);
          _impl_.reason_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 to_connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_to_connection_id(&has_bits);
          _impl_.to_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_connection_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_from_connection_id(&has_bits);
          _impl_.from_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 to_relay_session_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_to_relay_session_id(&has_bits);
          _impl_.to_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_relay_session_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_from_relay_session_id(&has_bits);
          _impl_.from_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes forward_target_relay_routing_token = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_forward_target_relay_routing_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 forward_target_revision = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_forward_target_revision(&has_bits);
          _impl_.forward_target_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_legacy_from_identity_binary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 routing_secret = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_routing_secret(&has_bits);
          _impl_.routing_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string from_identity_string = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_from_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramConnectionClosed.from_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool not_primary_session = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_not_primary_session(&has_bits);
          _impl_.not_primary_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool not_primary_transport = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_not_primary_transport(&has_bits);
          _impl_.not_primary_transport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_p2p_routing_summary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool relay_override_active = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_relay_override_active(&has_bits);
          _impl_.relay_override_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionClosed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionClosed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 legacy_gameserver_relay_session_id = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_legacy_gameserver_relay_session_id(), target);
  }

  // optional fixed64 legacy_from_steam_id = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_from_steam_id(), target);
  }

  // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4 [default = None];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_relay_mode(), target);
  }

  // optional string debug = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_debug().data(), static_cast<int>(this->_internal_debug().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramConnectionClosed.debug");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_debug(), target);
  }

  // optional uint32 reason_code = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_reason_code(), target);
  }

  // optional fixed32 to_connection_id = 7;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_to_connection_id(), target);
  }

  // optional fixed32 from_connection_id = 8;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_from_connection_id(), target);
  }

  // optional fixed32 to_relay_session_id = 9;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_to_relay_session_id(), target);
  }

  // optional fixed32 from_relay_session_id = 10;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_from_relay_session_id(), target);
  }

  // optional bytes forward_target_relay_routing_token = 11;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_forward_target_relay_routing_token(), target);
  }

  // optional uint32 forward_target_revision = 12;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_forward_target_revision(), target);
  }

  // optional .CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::legacy_from_identity_binary(this),
        _Internal::legacy_from_identity_binary(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 routing_secret = 14;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(14, this->_internal_routing_secret(), target);
  }

  // optional string from_identity_string = 15;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_from_identity_string().data(), static_cast<int>(this->_internal_from_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramConnectionClosed.from_identity_string");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_from_identity_string(), target);
  }

  // optional bool not_primary_session = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_not_primary_session(), target);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 17;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 18;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional bool not_primary_transport = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_not_primary_transport(), target);
  }

  // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::p2p_routing_summary(this),
        _Internal::p2p_routing_summary(this).GetCachedSize(), target, stream);
  }

  // optional bool relay_override_active = 22;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_relay_override_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionClosed)
  return target;
}

size_t CMsgSteamDatagramConnectionClosed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionClosed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string debug = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_debug());
    }

    // optional bytes forward_target_relay_routing_token = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_forward_target_relay_routing_token());
    }

    // optional string from_identity_string = 15;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_identity_string());
    }

    // optional .CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.legacy_from_identity_binary_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 17;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 18;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.p2p_routing_summary_);
    }

    // optional fixed64 legacy_from_steam_id = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 legacy_gameserver_relay_session_id = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_gameserver_relay_session_id());
    }

    // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4 [default = None];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_relay_mode());
    }

    // optional uint32 reason_code = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reason_code());
    }

    // optional fixed32 to_connection_id = 7;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional fixed32 from_connection_id = 8;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 to_relay_session_id = 9;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 from_relay_session_id = 10;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional uint32 forward_target_revision = 12;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_forward_target_revision());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional fixed64 routing_secret = 14;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional bool not_primary_session = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool not_primary_transport = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool relay_override_active = 22;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionClosed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionClosed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionClosed::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionClosed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionClosed*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionClosed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionClosed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_debug(from._internal_debug());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_forward_target_relay_routing_token(from._internal_forward_target_relay_routing_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_from_identity_string(from._internal_from_identity_string());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_legacy_from_identity_binary()->::CMsgSteamNetworkingIdentityLegacyBinary::MergeFrom(
          from._internal_legacy_from_identity_binary());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_p2p_routing_summary()->::CMsgSteamDatagramP2PRoutingSummary::MergeFrom(
          from._internal_p2p_routing_summary());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.legacy_from_steam_id_ = from._impl_.legacy_from_steam_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.legacy_gameserver_relay_session_id_ = from._impl_.legacy_gameserver_relay_session_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.relay_mode_ = from._impl_.relay_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.reason_code_ = from._impl_.reason_code_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.to_connection_id_ = from._impl_.to_connection_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.from_connection_id_ = from._impl_.from_connection_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.to_relay_session_id_ = from._impl_.to_relay_session_id_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.from_relay_session_id_ = from._impl_.from_relay_session_id_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.forward_target_revision_ = from._impl_.forward_target_revision_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.routing_secret_ = from._impl_.routing_secret_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.not_primary_session_ = from._impl_.not_primary_session_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.not_primary_transport_ = from._impl_.not_primary_transport_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.relay_override_active_ = from._impl_.relay_override_active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionClosed::CopyFrom(const CMsgSteamDatagramConnectionClosed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionClosed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionClosed::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionClosed::InternalSwap(CMsgSteamDatagramConnectionClosed* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.debug_, lhs_arena,
      &other->_impl_.debug_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.forward_target_relay_routing_token_, lhs_arena,
      &other->_impl_.forward_target_relay_routing_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_identity_string_, lhs_arena,
      &other->_impl_.from_identity_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionClosed, _impl_.relay_override_active_)
      + sizeof(CMsgSteamDatagramConnectionClosed::_impl_.relay_override_active_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionClosed, _impl_.legacy_from_identity_binary_)>(
          reinterpret_cast<char*>(&_impl_.legacy_from_identity_binary_),
          reinterpret_cast<char*>(&other->_impl_.legacy_from_identity_binary_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionClosed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[22]);
}

// ===================================================================

class CMsgSteamDatagramNoConnection::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramNoConnection>()._impl_._has_bits_);
  static void set_has_to_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_from_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_legacy_gameserver_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_to_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_from_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_from_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_legacy_from_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_end_to_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_not_primary_session(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_not_primary_transport(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_relay_override_active(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramNoConnection* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramNoConnection* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamDatagramP2PRoutingSummary& p2p_routing_summary(const CMsgSteamDatagramNoConnection* msg);
  static void set_has_p2p_routing_summary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_routing_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dummy_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramNoConnection::_Internal::quality_relay(const CMsgSteamDatagramNoConnection* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramNoConnection::_Internal::quality_e2e(const CMsgSteamDatagramNoConnection* msg) {
  return *msg->_impl_.quality_e2e_;
}
const ::CMsgSteamDatagramP2PRoutingSummary&
CMsgSteamDatagramNoConnection::_Internal::p2p_routing_summary(const CMsgSteamDatagramNoConnection* msg) {
  return *msg->_impl_.p2p_routing_summary_;
}
void CMsgSteamDatagramNoConnection::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgSteamDatagramNoConnection::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgSteamDatagramNoConnection::CMsgSteamDatagramNoConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramNoConnection)
}
CMsgSteamDatagramNoConnection::CMsgSteamDatagramNoConnection(const CMsgSteamDatagramNoConnection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramNoConnection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_identity_string_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.legacy_from_steam_id_){}
    , decltype(_impl_.legacy_gameserver_relay_session_id_){}
    , decltype(_impl_.to_connection_id_){}
    , decltype(_impl_.from_connection_id_){}
    , decltype(_impl_.to_relay_session_id_){}
    , decltype(_impl_.routing_secret_){}
    , decltype(_impl_.from_relay_session_id_){}
    , decltype(_impl_.end_to_end_){}
    , decltype(_impl_.not_primary_session_){}
    , decltype(_impl_.not_primary_transport_){}
    , decltype(_impl_.relay_override_active_){}
    , decltype(_impl_.dummy_pad_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.from_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_from_identity_string()) {
    _this->_impl_.from_identity_string_.Set(from._internal_from_identity_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  if (from._internal_has_p2p_routing_summary()) {
    _this->_impl_.p2p_routing_summary_ = new ::CMsgSteamDatagramP2PRoutingSummary(*from._impl_.p2p_routing_summary_);
  }
  ::memcpy(&_impl_.legacy_from_steam_id_, &from._impl_.legacy_from_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dummy_pad_) -
    reinterpret_cast<char*>(&_impl_.legacy_from_steam_id_)) + sizeof(_impl_.dummy_pad_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramNoConnection)
}

inline void CMsgSteamDatagramNoConnection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_identity_string_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.legacy_from_steam_id_){uint64_t{0u}}
    , decltype(_impl_.legacy_gameserver_relay_session_id_){0u}
    , decltype(_impl_.to_connection_id_){0u}
    , decltype(_impl_.from_connection_id_){0u}
    , decltype(_impl_.to_relay_session_id_){0u}
    , decltype(_impl_.routing_secret_){uint64_t{0u}}
    , decltype(_impl_.from_relay_session_id_){0u}
    , decltype(_impl_.end_to_end_){false}
    , decltype(_impl_.not_primary_session_){false}
    , decltype(_impl_.not_primary_transport_){false}
    , decltype(_impl_.relay_override_active_){false}
    , decltype(_impl_.dummy_pad_){0u}
  };
  _impl_.from_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramNoConnection::~CMsgSteamDatagramNoConnection() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramNoConnection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramNoConnection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_identity_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
  if (this != internal_default_instance()) delete _impl_.p2p_routing_summary_;
}

void CMsgSteamDatagramNoConnection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramNoConnection::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramNoConnection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.from_identity_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.p2p_routing_summary_ != nullptr);
      _impl_.p2p_routing_summary_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.legacy_from_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_connection_id_) -
        reinterpret_cast<char*>(&_impl_.legacy_from_steam_id_)) + sizeof(_impl_.from_connection_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.to_relay_session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dummy_pad_) -
        reinterpret_cast<char*>(&_impl_.to_relay_session_id_)) + sizeof(_impl_.dummy_pad_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramNoConnection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 legacy_gameserver_relay_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_legacy_gameserver_relay_session_id(&has_bits);
          _impl_.legacy_gameserver_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_from_steam_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_from_steam_id(&has_bits);
          _impl_.legacy_from_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool end_to_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_end_to_end(&has_bits);
          _impl_.end_to_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 to_connection_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_to_connection_id(&has_bits);
          _impl_.to_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_connection_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_from_connection_id(&has_bits);
          _impl_.from_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string from_identity_string = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_from_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramNoConnection.from_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 to_relay_session_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_to_relay_session_id(&has_bits);
          _impl_.to_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 from_relay_session_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_from_relay_session_id(&has_bits);
          _impl_.from_relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 routing_secret = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_routing_secret(&has_bits);
          _impl_.routing_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool not_primary_session = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_not_primary_session(&has_bits);
          _impl_.not_primary_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool not_primary_transport = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_not_primary_transport(&has_bits);
          _impl_.not_primary_transport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_p2p_routing_summary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool relay_override_active = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_relay_override_active(&has_bits);
          _impl_.relay_override_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 dummy_pad = 1023;
      case 1023:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          _Internal::set_has_dummy_pad(&has_bits);
          _impl_.dummy_pad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramNoConnection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramNoConnection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 legacy_gameserver_relay_session_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_legacy_gameserver_relay_session_id(), target);
  }

  // optional fixed64 legacy_from_steam_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_from_steam_id(), target);
  }

  // optional bool end_to_end = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_end_to_end(), target);
  }

  // optional fixed32 to_connection_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_to_connection_id(), target);
  }

  // optional fixed32 from_connection_id = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_from_connection_id(), target);
  }

  // optional string from_identity_string = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_from_identity_string().data(), static_cast<int>(this->_internal_from_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramNoConnection.from_identity_string");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_from_identity_string(), target);
  }

  // optional fixed32 to_relay_session_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_to_relay_session_id(), target);
  }

  // optional fixed32 from_relay_session_id = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_from_relay_session_id(), target);
  }

  // optional fixed64 routing_secret = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(11, this->_internal_routing_secret(), target);
  }

  // optional bool not_primary_session = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_not_primary_session(), target);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 13;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 14;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional bool not_primary_transport = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_not_primary_transport(), target);
  }

  // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::p2p_routing_summary(this),
        _Internal::p2p_routing_summary(this).GetCachedSize(), target, stream);
  }

  // optional bool relay_override_active = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_relay_override_active(), target);
  }

  // optional fixed32 dummy_pad = 1023;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1023, this->_internal_dummy_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramNoConnection)
  return target;
}

size_t CMsgSteamDatagramNoConnection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramNoConnection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string from_identity_string = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_identity_string());
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.p2p_routing_summary_);
    }

    // optional fixed64 legacy_from_steam_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint32 legacy_gameserver_relay_session_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_gameserver_relay_session_id());
    }

    // optional fixed32 to_connection_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed32 from_connection_id = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional fixed32 to_relay_session_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed64 routing_secret = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional fixed32 from_relay_session_id = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional bool end_to_end = 4;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool not_primary_session = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool not_primary_transport = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool relay_override_active = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional fixed32 dummy_pad = 1023;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramNoConnection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramNoConnection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramNoConnection::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramNoConnection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramNoConnection*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramNoConnection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramNoConnection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_from_identity_string(from._internal_from_identity_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_p2p_routing_summary()->::CMsgSteamDatagramP2PRoutingSummary::MergeFrom(
          from._internal_p2p_routing_summary());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.legacy_from_steam_id_ = from._impl_.legacy_from_steam_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.legacy_gameserver_relay_session_id_ = from._impl_.legacy_gameserver_relay_session_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.to_connection_id_ = from._impl_.to_connection_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.from_connection_id_ = from._impl_.from_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.to_relay_session_id_ = from._impl_.to_relay_session_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.routing_secret_ = from._impl_.routing_secret_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.from_relay_session_id_ = from._impl_.from_relay_session_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.end_to_end_ = from._impl_.end_to_end_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.not_primary_session_ = from._impl_.not_primary_session_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.not_primary_transport_ = from._impl_.not_primary_transport_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.relay_override_active_ = from._impl_.relay_override_active_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.dummy_pad_ = from._impl_.dummy_pad_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramNoConnection::CopyFrom(const CMsgSteamDatagramNoConnection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramNoConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramNoConnection::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramNoConnection::InternalSwap(CMsgSteamDatagramNoConnection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_identity_string_, lhs_arena,
      &other->_impl_.from_identity_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoConnection, _impl_.dummy_pad_)
      + sizeof(CMsgSteamDatagramNoConnection::_impl_.dummy_pad_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramNoConnection, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramNoConnection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[23]);
}

// ===================================================================

class CMsgSteamDatagramGameserverSessionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramGameserverSessionRequest>()._impl_._has_bits_);
  static void set_has_ticket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_challenge_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_server_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_network_config_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_build(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dev_gameserver_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgSteamDatagramCertificateSigned& dev_client_cert(const CMsgSteamDatagramGameserverSessionRequest* msg);
  static void set_has_dev_client_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramGameserverSessionRequest::_Internal::dev_client_cert(const CMsgSteamDatagramGameserverSessionRequest* msg) {
  return *msg->_impl_.dev_client_cert_;
}
void CMsgSteamDatagramGameserverSessionRequest::clear_dev_client_cert() {
  if (_impl_.dev_client_cert_ != nullptr) _impl_.dev_client_cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CMsgSteamDatagramGameserverSessionRequest::CMsgSteamDatagramGameserverSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramGameserverSessionRequest)
}
CMsgSteamDatagramGameserverSessionRequest::CMsgSteamDatagramGameserverSessionRequest(const CMsgSteamDatagramGameserverSessionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramGameserverSessionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ticket_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.dev_gameserver_identity_){}
    , decltype(_impl_.dev_client_cert_){nullptr}
    , decltype(_impl_.challenge_){}
    , decltype(_impl_.challenge_time_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.network_config_version_){}
    , decltype(_impl_.protocol_version_){}
    , decltype(_impl_.server_connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ticket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ticket()) {
    _this->_impl_.ticket_.Set(from._internal_ticket(), 
      _this->GetArenaForAllocation());
  }
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    _this->_impl_.platform_.Set(from._internal_platform(), 
      _this->GetArenaForAllocation());
  }
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build()) {
    _this->_impl_.build_.Set(from._internal_build(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dev_gameserver_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_gameserver_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dev_gameserver_identity()) {
    _this->_impl_.dev_gameserver_identity_.Set(from._internal_dev_gameserver_identity(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dev_client_cert()) {
    _this->_impl_.dev_client_cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.dev_client_cert_);
  }
  ::memcpy(&_impl_.challenge_, &from._impl_.challenge_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.server_connection_id_) -
    reinterpret_cast<char*>(&_impl_.challenge_)) + sizeof(_impl_.server_connection_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramGameserverSessionRequest)
}

inline void CMsgSteamDatagramGameserverSessionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ticket_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.dev_gameserver_identity_){}
    , decltype(_impl_.dev_client_cert_){nullptr}
    , decltype(_impl_.challenge_){uint64_t{0u}}
    , decltype(_impl_.challenge_time_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.network_config_version_){uint64_t{0u}}
    , decltype(_impl_.protocol_version_){0u}
    , decltype(_impl_.server_connection_id_){0u}
  };
  _impl_.ticket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ticket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dev_gameserver_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_gameserver_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramGameserverSessionRequest::~CMsgSteamDatagramGameserverSessionRequest() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramGameserverSessionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramGameserverSessionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticket_.Destroy();
  _impl_.platform_.Destroy();
  _impl_.build_.Destroy();
  _impl_.dev_gameserver_identity_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dev_client_cert_;
}

void CMsgSteamDatagramGameserverSessionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramGameserverSessionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramGameserverSessionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ticket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.dev_gameserver_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.dev_client_cert_ != nullptr);
      _impl_.dev_client_cert_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.challenge_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_connection_id_) -
        reinterpret_cast<char*>(&_impl_.challenge_)) + sizeof(_impl_.client_connection_id_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.network_config_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_connection_id_) -
        reinterpret_cast<char*>(&_impl_.network_config_version_)) + sizeof(_impl_.server_connection_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramGameserverSessionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ticket = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ticket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 challenge_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_challenge_time(&has_bits);
          _impl_.challenge_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 challenge = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_challenge(&has_bits);
          _impl_.challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 network_config_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_network_config_version(&has_bits);
          _impl_.network_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 protocol_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_protocol_version(&has_bits);
          _impl_.protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_connection_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_server_connection_id(&has_bits);
          _impl_.server_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramGameserverSessionRequest.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string build = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramGameserverSessionRequest.build");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string dev_gameserver_identity = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_dev_gameserver_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramGameserverSessionRequest.dev_gameserver_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramCertificateSigned dev_client_cert = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_dev_client_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramGameserverSessionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramGameserverSessionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ticket = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ticket(), target);
  }

  // optional fixed32 challenge_time = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_challenge_time(), target);
  }

  // optional fixed64 challenge = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_challenge(), target);
  }

  // optional fixed32 client_connection_id = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_client_connection_id(), target);
  }

  // optional uint64 network_config_version = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_network_config_version(), target);
  }

  // optional uint32 protocol_version = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_protocol_version(), target);
  }

  // optional fixed32 server_connection_id = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_server_connection_id(), target);
  }

  // optional string platform = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramGameserverSessionRequest.platform");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_platform(), target);
  }

  // optional string build = 10;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_build().data(), static_cast<int>(this->_internal_build().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramGameserverSessionRequest.build");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_build(), target);
  }

  // optional string dev_gameserver_identity = 100;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dev_gameserver_identity().data(), static_cast<int>(this->_internal_dev_gameserver_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramGameserverSessionRequest.dev_gameserver_identity");
    target = stream->WriteStringMaybeAliased(
        100, this->_internal_dev_gameserver_identity(), target);
  }

  // optional .CMsgSteamDatagramCertificateSigned dev_client_cert = 101;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(101, _Internal::dev_client_cert(this),
        _Internal::dev_client_cert(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramGameserverSessionRequest)
  return target;
}

size_t CMsgSteamDatagramGameserverSessionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramGameserverSessionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ticket = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ticket());
    }

    // optional string platform = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional string build = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build());
    }

    // optional string dev_gameserver_identity = 100;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dev_gameserver_identity());
    }

    // optional .CMsgSteamDatagramCertificateSigned dev_client_cert = 101;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dev_client_cert_);
    }

    // optional fixed64 challenge = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional fixed32 challenge_time = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed32 client_connection_id = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 network_config_version = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_network_config_version());
    }

    // optional uint32 protocol_version = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_version());
    }

    // optional fixed32 server_connection_id = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramGameserverSessionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramGameserverSessionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramGameserverSessionRequest::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramGameserverSessionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramGameserverSessionRequest*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramGameserverSessionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramGameserverSessionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ticket(from._internal_ticket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_build(from._internal_build());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_dev_gameserver_identity(from._internal_dev_gameserver_identity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_dev_client_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_dev_client_cert());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.challenge_ = from._impl_.challenge_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.challenge_time_ = from._impl_.challenge_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.network_config_version_ = from._impl_.network_config_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.server_connection_id_ = from._impl_.server_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramGameserverSessionRequest::CopyFrom(const CMsgSteamDatagramGameserverSessionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramGameserverSessionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramGameserverSessionRequest::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramGameserverSessionRequest::InternalSwap(CMsgSteamDatagramGameserverSessionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ticket_, lhs_arena,
      &other->_impl_.ticket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.platform_, lhs_arena,
      &other->_impl_.platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.build_, lhs_arena,
      &other->_impl_.build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dev_gameserver_identity_, lhs_arena,
      &other->_impl_.dev_gameserver_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverSessionRequest, _impl_.server_connection_id_)
      + sizeof(CMsgSteamDatagramGameserverSessionRequest::_impl_.server_connection_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverSessionRequest, _impl_.dev_client_cert_)>(
          reinterpret_cast<char*>(&_impl_.dev_client_cert_),
          reinterpret_cast<char*>(&other->_impl_.dev_client_cert_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramGameserverSessionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[24]);
}

// ===================================================================

class CMsgSteamDatagramGameserverSessionEstablished::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramGameserverSessionEstablished>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gameserver_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq_num_r2c(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dummy_legacy_identity_binary(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_legacy_gameserver_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgSteamDatagramGameserverSessionEstablished::CMsgSteamDatagramGameserverSessionEstablished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramGameserverSessionEstablished)
}
CMsgSteamDatagramGameserverSessionEstablished::CMsgSteamDatagramGameserverSessionEstablished(const CMsgSteamDatagramGameserverSessionEstablished& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramGameserverSessionEstablished* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameserver_identity_string_){}
    , decltype(_impl_.dummy_legacy_identity_binary_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.legacy_gameserver_steamid_){}
    , decltype(_impl_.seq_num_r2c_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gameserver_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gameserver_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gameserver_identity_string()) {
    _this->_impl_.gameserver_identity_string_.Set(from._internal_gameserver_identity_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dummy_legacy_identity_binary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_legacy_identity_binary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dummy_legacy_identity_binary()) {
    _this->_impl_.dummy_legacy_identity_binary_.Set(from._internal_dummy_legacy_identity_binary(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_num_r2c_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.seq_num_r2c_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramGameserverSessionEstablished)
}

inline void CMsgSteamDatagramGameserverSessionEstablished::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameserver_identity_string_){}
    , decltype(_impl_.dummy_legacy_identity_binary_){}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.legacy_gameserver_steamid_){uint64_t{0u}}
    , decltype(_impl_.seq_num_r2c_){0u}
  };
  _impl_.gameserver_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gameserver_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dummy_legacy_identity_binary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dummy_legacy_identity_binary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramGameserverSessionEstablished::~CMsgSteamDatagramGameserverSessionEstablished() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramGameserverSessionEstablished)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramGameserverSessionEstablished::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gameserver_identity_string_.Destroy();
  _impl_.dummy_legacy_identity_binary_.Destroy();
}

void CMsgSteamDatagramGameserverSessionEstablished::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramGameserverSessionEstablished::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramGameserverSessionEstablished)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gameserver_identity_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dummy_legacy_identity_binary_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_r2c_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.seq_num_r2c_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramGameserverSessionEstablished::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string gameserver_identity_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_gameserver_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramGameserverSessionEstablished.gameserver_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_gameserver_steamid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_legacy_gameserver_steamid(&has_bits);
          _impl_.legacy_gameserver_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_r2c = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_seq_num_r2c(&has_bits);
          _impl_.seq_num_r2c_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dummy_legacy_identity_binary = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_dummy_legacy_identity_binary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramGameserverSessionEstablished::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramGameserverSessionEstablished)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // optional string gameserver_identity_string = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gameserver_identity_string().data(), static_cast<int>(this->_internal_gameserver_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramGameserverSessionEstablished.gameserver_identity_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_gameserver_identity_string(), target);
  }

  // optional fixed64 legacy_gameserver_steamid = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_legacy_gameserver_steamid(), target);
  }

  // optional uint32 seconds_until_shutdown = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_seconds_until_shutdown(), target);
  }

  // optional uint32 seq_num_r2c = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_seq_num_r2c(), target);
  }

  // optional bytes dummy_legacy_identity_binary = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_dummy_legacy_identity_binary(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramGameserverSessionEstablished)
  return target;
}

size_t CMsgSteamDatagramGameserverSessionEstablished::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramGameserverSessionEstablished)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string gameserver_identity_string = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gameserver_identity_string());
    }

    // optional bytes dummy_legacy_identity_binary = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dummy_legacy_identity_binary());
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 seconds_until_shutdown = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional fixed64 legacy_gameserver_steamid = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint32 seq_num_r2c = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_r2c());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramGameserverSessionEstablished::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramGameserverSessionEstablished::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramGameserverSessionEstablished::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramGameserverSessionEstablished::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramGameserverSessionEstablished*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramGameserverSessionEstablished&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramGameserverSessionEstablished)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gameserver_identity_string(from._internal_gameserver_identity_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dummy_legacy_identity_binary(from._internal_dummy_legacy_identity_binary());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.legacy_gameserver_steamid_ = from._impl_.legacy_gameserver_steamid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.seq_num_r2c_ = from._impl_.seq_num_r2c_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramGameserverSessionEstablished::CopyFrom(const CMsgSteamDatagramGameserverSessionEstablished& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramGameserverSessionEstablished)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramGameserverSessionEstablished::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramGameserverSessionEstablished::InternalSwap(CMsgSteamDatagramGameserverSessionEstablished* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gameserver_identity_string_, lhs_arena,
      &other->_impl_.gameserver_identity_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dummy_legacy_identity_binary_, lhs_arena,
      &other->_impl_.dummy_legacy_identity_binary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverSessionEstablished, _impl_.seq_num_r2c_)
      + sizeof(CMsgSteamDatagramGameserverSessionEstablished::_impl_.seq_num_r2c_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramGameserverSessionEstablished, _impl_.connection_id_)>(
          reinterpret_cast<char*>(&_impl_.connection_id_),
          reinterpret_cast<char*>(&other->_impl_.connection_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramGameserverSessionEstablished::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[25]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsClientToRouter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsClientToRouter>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsClientToRouter* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsClientToRouter* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq_num_c2r(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsClientToRouter::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsClientToRouter* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsClientToRouter::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsClientToRouter* msg) {
  return *msg->_impl_.quality_e2e_;
}
void CMsgSteamDatagramConnectionStatsClientToRouter::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgSteamDatagramConnectionStatsClientToRouter::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgSteamDatagramConnectionStatsClientToRouter::CMsgSteamDatagramConnectionStatsClientToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsClientToRouter)
}
CMsgSteamDatagramConnectionStatsClientToRouter::CMsgSteamDatagramConnectionStatsClientToRouter(const CMsgSteamDatagramConnectionStatsClientToRouter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsClientToRouter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.seq_num_c2r_){}
    , decltype(_impl_.seq_num_e2e_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.seq_num_e2e_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsClientToRouter)
}

inline void CMsgSteamDatagramConnectionStatsClientToRouter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.seq_num_c2r_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
  };
}

CMsgSteamDatagramConnectionStatsClientToRouter::~CMsgSteamDatagramConnectionStatsClientToRouter() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsClientToRouter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsClientToRouter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
}

void CMsgSteamDatagramConnectionStatsClientToRouter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsClientToRouter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsClientToRouter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.seq_num_e2e_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsClientToRouter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<45>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_c2r = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_seq_num_c2r(&has_bits);
          _impl_.seq_num_c2r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsClientToRouter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsClientToRouter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // repeated fixed32 ack_relay = 4;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 5;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_flags(), target);
  }

  // optional fixed32 client_connection_id = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_client_connection_id(), target);
  }

  // optional uint32 seq_num_c2r = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_seq_num_c2r(), target);
  }

  // optional uint32 seq_num_e2e = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_seq_num_e2e(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsClientToRouter)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsClientToRouter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsClientToRouter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional uint32 flags = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional fixed32 client_connection_id = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 seq_num_c2r = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_c2r());
    }

    // optional uint32 seq_num_e2e = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsClientToRouter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsClientToRouter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsClientToRouter::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsClientToRouter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsClientToRouter*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsClientToRouter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsClientToRouter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.seq_num_c2r_ = from._impl_.seq_num_c2r_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsClientToRouter::CopyFrom(const CMsgSteamDatagramConnectionStatsClientToRouter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsClientToRouter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsClientToRouter::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsClientToRouter::InternalSwap(CMsgSteamDatagramConnectionStatsClientToRouter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.seq_num_e2e_)
      + sizeof(CMsgSteamDatagramConnectionStatsClientToRouter::_impl_.seq_num_e2e_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsClientToRouter, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsClientToRouter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[26]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsRouterToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsRouterToClient>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsRouterToClient* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsRouterToClient* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_migrate_request_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_migrate_request_port(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scoring_penalty_relay_cluster(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq_num_r2c(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsRouterToClient::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsRouterToClient* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsRouterToClient::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsRouterToClient* msg) {
  return *msg->_impl_.quality_e2e_;
}
void CMsgSteamDatagramConnectionStatsRouterToClient::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgSteamDatagramConnectionStatsRouterToClient::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgSteamDatagramConnectionStatsRouterToClient::CMsgSteamDatagramConnectionStatsRouterToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsRouterToClient)
}
CMsgSteamDatagramConnectionStatsRouterToClient::CMsgSteamDatagramConnectionStatsRouterToClient(const CMsgSteamDatagramConnectionStatsRouterToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsRouterToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.seq_num_r2c_){}
    , decltype(_impl_.seq_num_e2e_){}
    , decltype(_impl_.migrate_request_ip_){}
    , decltype(_impl_.migrate_request_port_){}
    , decltype(_impl_.scoring_penalty_relay_cluster_){}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  ::memcpy(&_impl_.seconds_until_shutdown_, &from._impl_.seconds_until_shutdown_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.seconds_until_shutdown_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsRouterToClient)
}

inline void CMsgSteamDatagramConnectionStatsRouterToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.seq_num_r2c_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
    , decltype(_impl_.migrate_request_ip_){0u}
    , decltype(_impl_.migrate_request_port_){0u}
    , decltype(_impl_.scoring_penalty_relay_cluster_){0u}
    , decltype(_impl_.flags_){0u}
  };
}

CMsgSteamDatagramConnectionStatsRouterToClient::~CMsgSteamDatagramConnectionStatsRouterToClient() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsRouterToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsRouterToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
}

void CMsgSteamDatagramConnectionStatsRouterToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsRouterToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsRouterToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.seconds_until_shutdown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.migrate_request_port_) -
        reinterpret_cast<char*>(&_impl_.seconds_until_shutdown_)) + sizeof(_impl_.migrate_request_port_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.scoring_penalty_relay_cluster_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.scoring_penalty_relay_cluster_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsRouterToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_r2c = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_seq_num_r2c(&has_bits);
          _impl_.seq_num_r2c_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 migrate_request_ip = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_migrate_request_ip(&has_bits);
          _impl_.migrate_request_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 migrate_request_port = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_migrate_request_port(&has_bits);
          _impl_.migrate_request_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scoring_penalty_relay_cluster = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_scoring_penalty_relay_cluster(&has_bits);
          _impl_.scoring_penalty_relay_cluster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<109>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<117>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsRouterToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsRouterToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional uint32 seconds_until_shutdown = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_seconds_until_shutdown(), target);
  }

  // optional fixed32 client_connection_id = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_client_connection_id(), target);
  }

  // optional uint32 seq_num_r2c = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_seq_num_r2c(), target);
  }

  // optional uint32 seq_num_e2e = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_seq_num_e2e(), target);
  }

  // optional fixed32 migrate_request_ip = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_migrate_request_ip(), target);
  }

  // optional uint32 migrate_request_port = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_migrate_request_port(), target);
  }

  // optional uint32 scoring_penalty_relay_cluster = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_scoring_penalty_relay_cluster(), target);
  }

  // repeated fixed32 ack_relay = 13;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(13, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 14;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(14, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsRouterToClient)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsRouterToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsRouterToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 14;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional uint32 seconds_until_shutdown = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional fixed32 client_connection_id = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 seq_num_r2c = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_r2c());
    }

    // optional uint32 seq_num_e2e = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

    // optional fixed32 migrate_request_ip = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 migrate_request_port = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_migrate_request_port());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 scoring_penalty_relay_cluster = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scoring_penalty_relay_cluster());
    }

    // optional uint32 flags = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsRouterToClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsRouterToClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsRouterToClient::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsRouterToClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsRouterToClient*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsRouterToClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsRouterToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.seq_num_r2c_ = from._impl_.seq_num_r2c_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.migrate_request_ip_ = from._impl_.migrate_request_ip_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.migrate_request_port_ = from._impl_.migrate_request_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.scoring_penalty_relay_cluster_ = from._impl_.scoring_penalty_relay_cluster_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsRouterToClient::CopyFrom(const CMsgSteamDatagramConnectionStatsRouterToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsRouterToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsRouterToClient::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsRouterToClient::InternalSwap(CMsgSteamDatagramConnectionStatsRouterToClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.flags_)
      + sizeof(CMsgSteamDatagramConnectionStatsRouterToClient::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsRouterToClient, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsRouterToClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[27]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsRouterToServer::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsRouterToServer>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsRouterToServer* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsRouterToServer* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_seq_num_r2s(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_legacy_client_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_server_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_routing_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsRouterToServer::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsRouterToServer* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsRouterToServer::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsRouterToServer* msg) {
  return *msg->_impl_.quality_e2e_;
}
void CMsgSteamDatagramConnectionStatsRouterToServer::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgSteamDatagramConnectionStatsRouterToServer::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgSteamDatagramConnectionStatsRouterToServer::CMsgSteamDatagramConnectionStatsRouterToServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsRouterToServer)
}
CMsgSteamDatagramConnectionStatsRouterToServer::CMsgSteamDatagramConnectionStatsRouterToServer(const CMsgSteamDatagramConnectionStatsRouterToServer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsRouterToServer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.client_identity_string_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seq_num_r2s_){}
    , decltype(_impl_.seq_num_e2e_){}
    , decltype(_impl_.legacy_client_steam_id_){}
    , decltype(_impl_.relay_session_id_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.server_connection_id_){}
    , decltype(_impl_.routing_secret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_identity_string()) {
    _this->_impl_.client_identity_string_.Set(from._internal_client_identity_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  ::memcpy(&_impl_.seq_num_r2s_, &from._impl_.seq_num_r2s_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.routing_secret_) -
    reinterpret_cast<char*>(&_impl_.seq_num_r2s_)) + sizeof(_impl_.routing_secret_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsRouterToServer)
}

inline void CMsgSteamDatagramConnectionStatsRouterToServer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.client_identity_string_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seq_num_r2s_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
    , decltype(_impl_.legacy_client_steam_id_){uint64_t{0u}}
    , decltype(_impl_.relay_session_id_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.server_connection_id_){0u}
    , decltype(_impl_.routing_secret_){uint64_t{0u}}
  };
  _impl_.client_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramConnectionStatsRouterToServer::~CMsgSteamDatagramConnectionStatsRouterToServer() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsRouterToServer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsRouterToServer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  _impl_.client_identity_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
}

void CMsgSteamDatagramConnectionStatsRouterToServer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsRouterToServer::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsRouterToServer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_identity_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.seq_num_r2s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_connection_id_) -
        reinterpret_cast<char*>(&_impl_.seq_num_r2s_)) + sizeof(_impl_.client_connection_id_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.routing_secret_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.routing_secret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsRouterToServer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_r2s = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_seq_num_r2s(&has_bits);
          _impl_.seq_num_r2s_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_client_steam_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_legacy_client_steam_id(&has_bits);
          _impl_.legacy_client_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 relay_session_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_relay_session_id(&has_bits);
          _impl_.relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<85>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<93>(ptr));
        } else if (static_cast<uint8_t>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_connection_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_server_connection_id(&has_bits);
          _impl_.server_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 routing_secret = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_routing_secret(&has_bits);
          _impl_.routing_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string client_identity_string = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_client_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramConnectionStatsRouterToServer.client_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsRouterToServer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsRouterToServer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional uint32 seq_num_r2s = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_seq_num_r2s(), target);
  }

  // optional uint32 seq_num_e2e = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_seq_num_e2e(), target);
  }

  // optional fixed64 legacy_client_steam_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(7, this->_internal_legacy_client_steam_id(), target);
  }

  // optional uint32 relay_session_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_relay_session_id(), target);
  }

  // optional fixed32 client_connection_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_client_connection_id(), target);
  }

  // repeated fixed32 ack_relay = 10;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 11;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(11, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_flags(), target);
  }

  // optional fixed32 server_connection_id = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(13, this->_internal_server_connection_id(), target);
  }

  // optional fixed64 routing_secret = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(14, this->_internal_routing_secret(), target);
  }

  // optional string client_identity_string = 15;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_client_identity_string().data(), static_cast<int>(this->_internal_client_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramConnectionStatsRouterToServer.client_identity_string");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_client_identity_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsRouterToServer)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsRouterToServer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsRouterToServer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string client_identity_string = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_identity_string());
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional uint32 seq_num_r2s = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_r2s());
    }

    // optional uint32 seq_num_e2e = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

    // optional fixed64 legacy_client_steam_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 relay_session_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_relay_session_id());
    }

    // optional fixed32 client_connection_id = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional fixed32 server_connection_id = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional fixed64 routing_secret = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsRouterToServer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsRouterToServer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsRouterToServer::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsRouterToServer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsRouterToServer*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsRouterToServer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsRouterToServer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_identity_string(from._internal_client_identity_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seq_num_r2s_ = from._impl_.seq_num_r2s_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.legacy_client_steam_id_ = from._impl_.legacy_client_steam_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.relay_session_id_ = from._impl_.relay_session_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.server_connection_id_ = from._impl_.server_connection_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.routing_secret_ = from._impl_.routing_secret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsRouterToServer::CopyFrom(const CMsgSteamDatagramConnectionStatsRouterToServer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsRouterToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsRouterToServer::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsRouterToServer::InternalSwap(CMsgSteamDatagramConnectionStatsRouterToServer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_identity_string_, lhs_arena,
      &other->_impl_.client_identity_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.routing_secret_)
      + sizeof(CMsgSteamDatagramConnectionStatsRouterToServer::_impl_.routing_secret_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsRouterToServer, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsRouterToServer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[28]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsServerToRouter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsServerToRouter>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsServerToRouter* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsServerToRouter* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_seq_num_s2r(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_relay_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_server_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsServerToRouter::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsServerToRouter* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsServerToRouter::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsServerToRouter* msg) {
  return *msg->_impl_.quality_e2e_;
}
void CMsgSteamDatagramConnectionStatsServerToRouter::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgSteamDatagramConnectionStatsServerToRouter::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgSteamDatagramConnectionStatsServerToRouter::CMsgSteamDatagramConnectionStatsServerToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsServerToRouter)
}
CMsgSteamDatagramConnectionStatsServerToRouter::CMsgSteamDatagramConnectionStatsServerToRouter(const CMsgSteamDatagramConnectionStatsServerToRouter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsServerToRouter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seq_num_s2r_){}
    , decltype(_impl_.seq_num_e2e_){}
    , decltype(_impl_.relay_session_id_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.server_connection_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  ::memcpy(&_impl_.seq_num_s2r_, &from._impl_.seq_num_s2r_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.server_connection_id_) -
    reinterpret_cast<char*>(&_impl_.seq_num_s2r_)) + sizeof(_impl_.server_connection_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsServerToRouter)
}

inline void CMsgSteamDatagramConnectionStatsServerToRouter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seq_num_s2r_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
    , decltype(_impl_.relay_session_id_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.server_connection_id_){0u}
  };
}

CMsgSteamDatagramConnectionStatsServerToRouter::~CMsgSteamDatagramConnectionStatsServerToRouter() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsServerToRouter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsServerToRouter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
}

void CMsgSteamDatagramConnectionStatsServerToRouter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsServerToRouter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsServerToRouter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.seq_num_s2r_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_connection_id_) -
        reinterpret_cast<char*>(&_impl_.seq_num_s2r_)) + sizeof(_impl_.server_connection_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsServerToRouter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_s2r = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seq_num_s2r(&has_bits);
          _impl_.seq_num_s2r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 relay_session_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_relay_session_id(&has_bits);
          _impl_.relay_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<69>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<77>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_connection_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_server_connection_id(&has_bits);
          _impl_.server_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsServerToRouter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsServerToRouter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional uint32 seq_num_s2r = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq_num_s2r(), target);
  }

  // optional uint32 seq_num_e2e = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_seq_num_e2e(), target);
  }

  // optional uint32 relay_session_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_relay_session_id(), target);
  }

  // optional fixed32 client_connection_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_client_connection_id(), target);
  }

  // repeated fixed32 ack_relay = 8;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 9;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_flags(), target);
  }

  // optional fixed32 server_connection_id = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(11, this->_internal_server_connection_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsServerToRouter)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsServerToRouter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsServerToRouter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional uint32 seq_num_s2r = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_s2r());
    }

    // optional uint32 seq_num_e2e = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

    // optional uint32 relay_session_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_relay_session_id());
    }

    // optional fixed32 client_connection_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional fixed32 server_connection_id = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsServerToRouter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsServerToRouter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsServerToRouter::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsServerToRouter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsServerToRouter*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsServerToRouter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsServerToRouter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seq_num_s2r_ = from._impl_.seq_num_s2r_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.relay_session_id_ = from._impl_.relay_session_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.server_connection_id_ = from._impl_.server_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsServerToRouter::CopyFrom(const CMsgSteamDatagramConnectionStatsServerToRouter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsServerToRouter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsServerToRouter::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsServerToRouter::InternalSwap(CMsgSteamDatagramConnectionStatsServerToRouter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.server_connection_id_)
      + sizeof(CMsgSteamDatagramConnectionStatsServerToRouter::_impl_.server_connection_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsServerToRouter, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsServerToRouter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[29]);
}

// ===================================================================

class CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PSessionRequestBody_EncryptedData>()._impl_._has_bits_);
  static void set_has_peer_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
}
CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData(const CMsgSteamDatagramP2PSessionRequestBody_EncryptedData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PSessionRequestBody_EncryptedData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peer_identity_string_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.peer_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_peer_identity_string()) {
    _this->_impl_.peer_identity_string_.Set(from._internal_peer_identity_string(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
}

inline void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peer_identity_string_){}
  };
  _impl_.peer_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::~CMsgSteamDatagramP2PSessionRequestBody_EncryptedData() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peer_identity_string_.Destroy();
}

void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.peer_identity_string_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string peer_identity_string = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_peer_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramP2PSessionRequestBody.EncryptedData.peer_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string peer_identity_string = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_peer_identity_string().data(), static_cast<int>(this->_internal_peer_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramP2PSessionRequestBody.EncryptedData.peer_identity_string");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_peer_identity_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  return target;
}

size_t CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string peer_identity_string = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_peer_identity_string());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PSessionRequestBody_EncryptedData*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PSessionRequestBody_EncryptedData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_peer_identity_string()) {
    _this->_internal_set_peer_identity_string(from._internal_peer_identity_string());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::CopyFrom(const CMsgSteamDatagramP2PSessionRequestBody_EncryptedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PSessionRequestBody.EncryptedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::InternalSwap(CMsgSteamDatagramP2PSessionRequestBody_EncryptedData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.peer_identity_string_, lhs_arena,
      &other->_impl_.peer_identity_string_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PSessionRequestBody_EncryptedData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[30]);
}

// ===================================================================

class CMsgSteamDatagramP2PSessionRequestBody::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PSessionRequestBody>()._impl_._has_bits_);
  static void set_has_challenge_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_legacy_peer_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_peer_identity_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_peer_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_encrypted_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encryption_your_public_key_lead_byte(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_encryption_my_ephemeral_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_network_config_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_build(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSteamDatagramP2PSessionRequestBody::CMsgSteamDatagramP2PSessionRequestBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PSessionRequestBody)
}
CMsgSteamDatagramP2PSessionRequestBody::CMsgSteamDatagramP2PSessionRequestBody(const CMsgSteamDatagramP2PSessionRequestBody& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PSessionRequestBody* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peer_identity_string_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.encrypted_data_){}
    , decltype(_impl_.encryption_my_ephemeral_public_key_){}
    , decltype(_impl_.challenge_){}
    , decltype(_impl_.challenge_time_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.legacy_peer_steam_id_){}
    , decltype(_impl_.peer_connection_id_){}
    , decltype(_impl_.protocol_version_){}
    , decltype(_impl_.network_config_version_){}
    , decltype(_impl_.encryption_your_public_key_lead_byte_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.peer_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_peer_identity_string()) {
    _this->_impl_.peer_identity_string_.Set(from._internal_peer_identity_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    _this->_impl_.platform_.Set(from._internal_platform(), 
      _this->GetArenaForAllocation());
  }
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build()) {
    _this->_impl_.build_.Set(from._internal_build(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encrypted_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_data()) {
    _this->_impl_.encrypted_data_.Set(from._internal_encrypted_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encryption_my_ephemeral_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encryption_my_ephemeral_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encryption_my_ephemeral_public_key()) {
    _this->_impl_.encryption_my_ephemeral_public_key_.Set(from._internal_encryption_my_ephemeral_public_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.challenge_, &from._impl_.challenge_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encryption_your_public_key_lead_byte_) -
    reinterpret_cast<char*>(&_impl_.challenge_)) + sizeof(_impl_.encryption_your_public_key_lead_byte_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PSessionRequestBody)
}

inline void CMsgSteamDatagramP2PSessionRequestBody::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peer_identity_string_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.encrypted_data_){}
    , decltype(_impl_.encryption_my_ephemeral_public_key_){}
    , decltype(_impl_.challenge_){uint64_t{0u}}
    , decltype(_impl_.challenge_time_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.legacy_peer_steam_id_){uint64_t{0u}}
    , decltype(_impl_.peer_connection_id_){0u}
    , decltype(_impl_.protocol_version_){0u}
    , decltype(_impl_.network_config_version_){uint64_t{0u}}
    , decltype(_impl_.encryption_your_public_key_lead_byte_){0u}
  };
  _impl_.peer_identity_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_identity_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encrypted_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encryption_my_ephemeral_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encryption_my_ephemeral_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PSessionRequestBody::~CMsgSteamDatagramP2PSessionRequestBody() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PSessionRequestBody)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PSessionRequestBody::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peer_identity_string_.Destroy();
  _impl_.platform_.Destroy();
  _impl_.build_.Destroy();
  _impl_.encrypted_data_.Destroy();
  _impl_.encryption_my_ephemeral_public_key_.Destroy();
}

void CMsgSteamDatagramP2PSessionRequestBody::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PSessionRequestBody::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PSessionRequestBody)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.peer_identity_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.encrypted_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.encryption_my_ephemeral_public_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.challenge_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_connection_id_) -
        reinterpret_cast<char*>(&_impl_.challenge_)) + sizeof(_impl_.client_connection_id_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.legacy_peer_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.encryption_your_public_key_lead_byte_) -
        reinterpret_cast<char*>(&_impl_.legacy_peer_steam_id_)) + sizeof(_impl_.encryption_your_public_key_lead_byte_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PSessionRequestBody::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 challenge_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_challenge_time(&has_bits);
          _impl_.challenge_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 challenge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_challenge(&has_bits);
          _impl_.challenge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 legacy_peer_steam_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_legacy_peer_steam_id(&has_bits);
          _impl_.legacy_peer_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 peer_connection_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_peer_connection_id(&has_bits);
          _impl_.peer_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 protocol_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_protocol_version(&has_bits);
          _impl_.protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 network_config_version = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_network_config_version(&has_bits);
          _impl_.network_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string peer_identity_string = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_peer_identity_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramP2PSessionRequestBody.peer_identity_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramP2PSessionRequestBody.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string build = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramP2PSessionRequestBody.build");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes encrypted_data = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 encryption_your_public_key_lead_byte = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_encryption_your_public_key_lead_byte(&has_bits);
          _impl_.encryption_your_public_key_lead_byte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encryption_my_ephemeral_public_key = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_encryption_my_ephemeral_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PSessionRequestBody::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PSessionRequestBody)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 challenge_time = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_challenge_time(), target);
  }

  // optional fixed64 challenge = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_challenge(), target);
  }

  // optional fixed32 client_connection_id = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_client_connection_id(), target);
  }

  // optional fixed64 legacy_peer_steam_id = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_legacy_peer_steam_id(), target);
  }

  // optional fixed32 peer_connection_id = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_peer_connection_id(), target);
  }

  // optional uint32 protocol_version = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_protocol_version(), target);
  }

  // optional uint64 network_config_version = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_network_config_version(), target);
  }

  // optional string peer_identity_string = 11;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_peer_identity_string().data(), static_cast<int>(this->_internal_peer_identity_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramP2PSessionRequestBody.peer_identity_string");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_peer_identity_string(), target);
  }

  // optional string platform = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramP2PSessionRequestBody.platform");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_platform(), target);
  }

  // optional string build = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_build().data(), static_cast<int>(this->_internal_build().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramP2PSessionRequestBody.build");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_build(), target);
  }

  // optional bytes encrypted_data = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_encrypted_data(), target);
  }

  // optional uint32 encryption_your_public_key_lead_byte = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_encryption_your_public_key_lead_byte(), target);
  }

  // optional bytes encryption_my_ephemeral_public_key = 16;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        16, this->_internal_encryption_my_ephemeral_public_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PSessionRequestBody)
  return target;
}

size_t CMsgSteamDatagramP2PSessionRequestBody::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PSessionRequestBody)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string peer_identity_string = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_peer_identity_string());
    }

    // optional string platform = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional string build = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build());
    }

    // optional bytes encrypted_data = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_data());
    }

    // optional bytes encryption_my_ephemeral_public_key = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encryption_my_ephemeral_public_key());
    }

    // optional fixed64 challenge = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional fixed32 challenge_time = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed32 client_connection_id = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional fixed64 legacy_peer_steam_id = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional fixed32 peer_connection_id = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 protocol_version = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_version());
    }

    // optional uint64 network_config_version = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_network_config_version());
    }

    // optional uint32 encryption_your_public_key_lead_byte = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_encryption_your_public_key_lead_byte());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PSessionRequestBody::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PSessionRequestBody::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PSessionRequestBody::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PSessionRequestBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PSessionRequestBody*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PSessionRequestBody&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PSessionRequestBody)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_peer_identity_string(from._internal_peer_identity_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_build(from._internal_build());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_encrypted_data(from._internal_encrypted_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_encryption_my_ephemeral_public_key(from._internal_encryption_my_ephemeral_public_key());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.challenge_ = from._impl_.challenge_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.challenge_time_ = from._impl_.challenge_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.legacy_peer_steam_id_ = from._impl_.legacy_peer_steam_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.peer_connection_id_ = from._impl_.peer_connection_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.network_config_version_ = from._impl_.network_config_version_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.encryption_your_public_key_lead_byte_ = from._impl_.encryption_your_public_key_lead_byte_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PSessionRequestBody::CopyFrom(const CMsgSteamDatagramP2PSessionRequestBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PSessionRequestBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PSessionRequestBody::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PSessionRequestBody::InternalSwap(CMsgSteamDatagramP2PSessionRequestBody* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.peer_identity_string_, lhs_arena,
      &other->_impl_.peer_identity_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.platform_, lhs_arena,
      &other->_impl_.platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.build_, lhs_arena,
      &other->_impl_.build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encrypted_data_, lhs_arena,
      &other->_impl_.encrypted_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encryption_my_ephemeral_public_key_, lhs_arena,
      &other->_impl_.encryption_my_ephemeral_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PSessionRequestBody, _impl_.encryption_your_public_key_lead_byte_)
      + sizeof(CMsgSteamDatagramP2PSessionRequestBody::_impl_.encryption_your_public_key_lead_byte_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PSessionRequestBody, _impl_.challenge_)>(
          reinterpret_cast<char*>(&_impl_.challenge_),
          reinterpret_cast<char*>(&other->_impl_.challenge_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PSessionRequestBody::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[31]);
}

// ===================================================================

class CMsgSteamDatagramP2PSessionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PSessionRequest>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramCertificateSigned& cert(const CMsgSteamDatagramP2PSessionRequest* msg);
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSteamDatagramCertificateSigned&
CMsgSteamDatagramP2PSessionRequest::_Internal::cert(const CMsgSteamDatagramP2PSessionRequest* msg) {
  return *msg->_impl_.cert_;
}
void CMsgSteamDatagramP2PSessionRequest::clear_cert() {
  if (_impl_.cert_ != nullptr) _impl_.cert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgSteamDatagramP2PSessionRequest::CMsgSteamDatagramP2PSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PSessionRequest)
}
CMsgSteamDatagramP2PSessionRequest::CMsgSteamDatagramP2PSessionRequest(const CMsgSteamDatagramP2PSessionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PSessionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.cert_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cert()) {
    _this->_impl_.cert_ = new ::CMsgSteamDatagramCertificateSigned(*from._impl_.cert_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PSessionRequest)
}

inline void CMsgSteamDatagramP2PSessionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.cert_){nullptr}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PSessionRequest::~CMsgSteamDatagramP2PSessionRequest() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PSessionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PSessionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_.Destroy();
  _impl_.signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cert_;
}

void CMsgSteamDatagramP2PSessionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PSessionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PSessionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cert_ != nullptr);
      _impl_.cert_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PSessionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramCertificateSigned cert = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PSessionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PSessionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramCertificateSigned cert = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cert(this),
        _Internal::cert(this).GetCachedSize(), target, stream);
  }

  // optional bytes body = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_body(), target);
  }

  // optional bytes signature = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PSessionRequest)
  return target;
}

size_t CMsgSteamDatagramP2PSessionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PSessionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes body = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional bytes signature = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PSessionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PSessionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PSessionRequest::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PSessionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PSessionRequest*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PSessionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PSessionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cert()->::CMsgSteamDatagramCertificateSigned::MergeFrom(
          from._internal_cert());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PSessionRequest::CopyFrom(const CMsgSteamDatagramP2PSessionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PSessionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PSessionRequest::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PSessionRequest::InternalSwap(CMsgSteamDatagramP2PSessionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.cert_, other->_impl_.cert_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PSessionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[32]);
}

// ===================================================================

class CMsgSteamDatagramP2PSessionEstablished::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PSessionEstablished>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_relay_routing_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq_num_r2c(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSteamDatagramP2PSessionEstablished::CMsgSteamDatagramP2PSessionEstablished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PSessionEstablished)
}
CMsgSteamDatagramP2PSessionEstablished::CMsgSteamDatagramP2PSessionEstablished(const CMsgSteamDatagramP2PSessionEstablished& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PSessionEstablished* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relay_routing_token_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.seq_num_r2c_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relay_routing_token()) {
    _this->_impl_.relay_routing_token_.Set(from._internal_relay_routing_token(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_num_r2c_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.seq_num_r2c_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PSessionEstablished)
}

inline void CMsgSteamDatagramP2PSessionEstablished::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relay_routing_token_){}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.seq_num_r2c_){0u}
  };
  _impl_.relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PSessionEstablished::~CMsgSteamDatagramP2PSessionEstablished() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PSessionEstablished)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PSessionEstablished::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.relay_routing_token_.Destroy();
}

void CMsgSteamDatagramP2PSessionEstablished::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PSessionEstablished::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PSessionEstablished)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.relay_routing_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_r2c_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.seq_num_r2c_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PSessionEstablished::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes relay_routing_token = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_relay_routing_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_r2c = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_seq_num_r2c(&has_bits);
          _impl_.seq_num_r2c_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PSessionEstablished::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PSessionEstablished)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // optional uint32 seconds_until_shutdown = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seconds_until_shutdown(), target);
  }

  // optional bytes relay_routing_token = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_relay_routing_token(), target);
  }

  // optional uint32 seq_num_r2c = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_seq_num_r2c(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PSessionEstablished)
  return target;
}

size_t CMsgSteamDatagramP2PSessionEstablished::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PSessionEstablished)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes relay_routing_token = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_relay_routing_token());
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 seconds_until_shutdown = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional uint32 seq_num_r2c = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_r2c());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PSessionEstablished::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PSessionEstablished::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PSessionEstablished::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PSessionEstablished::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PSessionEstablished*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PSessionEstablished&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PSessionEstablished)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_relay_routing_token(from._internal_relay_routing_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seq_num_r2c_ = from._impl_.seq_num_r2c_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PSessionEstablished::CopyFrom(const CMsgSteamDatagramP2PSessionEstablished& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PSessionEstablished)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PSessionEstablished::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PSessionEstablished::InternalSwap(CMsgSteamDatagramP2PSessionEstablished* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relay_routing_token_, lhs_arena,
      &other->_impl_.relay_routing_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PSessionEstablished, _impl_.seq_num_r2c_)
      + sizeof(CMsgSteamDatagramP2PSessionEstablished::_impl_.seq_num_r2c_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PSessionEstablished, _impl_.connection_id_)>(
          reinterpret_cast<char*>(&_impl_.connection_id_),
          reinterpret_cast<char*>(&other->_impl_.connection_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PSessionEstablished::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[33]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsP2PClientToRouter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsP2PClientToRouter>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgSteamDatagramP2PRoutingSummary& p2p_routing_summary(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg);
  static void set_has_p2p_routing_summary(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_forward_target_relay_routing_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_forward_target_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_routes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ack_peer_routes_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_seq_num_c2r(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsP2PClientToRouter::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsP2PClientToRouter::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg) {
  return *msg->_impl_.quality_e2e_;
}
const ::CMsgSteamDatagramP2PRoutingSummary&
CMsgSteamDatagramConnectionStatsP2PClientToRouter::_Internal::p2p_routing_summary(const CMsgSteamDatagramConnectionStatsP2PClientToRouter* msg) {
  return *msg->_impl_.p2p_routing_summary_;
}
void CMsgSteamDatagramConnectionStatsP2PClientToRouter::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgSteamDatagramConnectionStatsP2PClientToRouter::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgSteamDatagramConnectionStatsP2PClientToRouter::CMsgSteamDatagramConnectionStatsP2PClientToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
}
CMsgSteamDatagramConnectionStatsP2PClientToRouter::CMsgSteamDatagramConnectionStatsP2PClientToRouter(const CMsgSteamDatagramConnectionStatsP2PClientToRouter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsP2PClientToRouter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.forward_target_relay_routing_token_){}
    , decltype(_impl_.routes_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.forward_target_revision_){}
    , decltype(_impl_.ack_peer_routes_revision_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.seq_num_c2r_){}
    , decltype(_impl_.seq_num_e2e_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.forward_target_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forward_target_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forward_target_relay_routing_token()) {
    _this->_impl_.forward_target_relay_routing_token_.Set(from._internal_forward_target_relay_routing_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.routes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_routes()) {
    _this->_impl_.routes_.Set(from._internal_routes(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  if (from._internal_has_p2p_routing_summary()) {
    _this->_impl_.p2p_routing_summary_ = new ::CMsgSteamDatagramP2PRoutingSummary(*from._impl_.p2p_routing_summary_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.seq_num_e2e_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
}

inline void CMsgSteamDatagramConnectionStatsP2PClientToRouter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.forward_target_relay_routing_token_){}
    , decltype(_impl_.routes_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.p2p_routing_summary_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.forward_target_revision_){0u}
    , decltype(_impl_.ack_peer_routes_revision_){0u}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.seq_num_c2r_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
  };
  _impl_.forward_target_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forward_target_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.routes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramConnectionStatsP2PClientToRouter::~CMsgSteamDatagramConnectionStatsP2PClientToRouter() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsP2PClientToRouter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  _impl_.forward_target_relay_routing_token_.Destroy();
  _impl_.routes_.Destroy();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
  if (this != internal_default_instance()) delete _impl_.p2p_routing_summary_;
}

void CMsgSteamDatagramConnectionStatsP2PClientToRouter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsP2PClientToRouter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.forward_target_relay_routing_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.routes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.p2p_routing_summary_ != nullptr);
      _impl_.p2p_routing_summary_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ack_peer_routes_revision_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.ack_peer_routes_revision_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.seq_num_e2e_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsP2PClientToRouter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<29>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes forward_target_relay_routing_token = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_forward_target_relay_routing_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 forward_target_revision = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_forward_target_revision(&has_bits);
          _impl_.forward_target_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes routes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_routes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ack_peer_routes_revision = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_ack_peer_routes_revision(&has_bits);
          _impl_.ack_peer_routes_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 connection_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_c2r = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_seq_num_c2r(&has_bits);
          _impl_.seq_num_c2r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_p2p_routing_summary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsP2PClientToRouter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // repeated fixed32 ack_relay = 3;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 4;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional bytes forward_target_relay_routing_token = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_forward_target_relay_routing_token(), target);
  }

  // optional uint32 forward_target_revision = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_forward_target_revision(), target);
  }

  // optional bytes routes = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_routes(), target);
  }

  // optional uint32 ack_peer_routes_revision = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_ack_peer_routes_revision(), target);
  }

  // optional fixed32 connection_id = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_connection_id(), target);
  }

  // optional uint32 seq_num_c2r = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_seq_num_c2r(), target);
  }

  // optional uint32 seq_num_e2e = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_seq_num_e2e(), target);
  }

  // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::p2p_routing_summary(this),
        _Internal::p2p_routing_summary(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsP2PClientToRouter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes forward_target_relay_routing_token = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_forward_target_relay_routing_token());
    }

    // optional bytes routes = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_routes());
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.p2p_routing_summary_);
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 forward_target_revision = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_forward_target_revision());
    }

    // optional uint32 ack_peer_routes_revision = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ack_peer_routes_revision());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional fixed32 connection_id = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 seq_num_c2r = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_c2r());
    }

    // optional uint32 seq_num_e2e = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsP2PClientToRouter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsP2PClientToRouter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsP2PClientToRouter::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsP2PClientToRouter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsP2PClientToRouter*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsP2PClientToRouter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_forward_target_relay_routing_token(from._internal_forward_target_relay_routing_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_routes(from._internal_routes());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_p2p_routing_summary()->::CMsgSteamDatagramP2PRoutingSummary::MergeFrom(
          from._internal_p2p_routing_summary());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.forward_target_revision_ = from._impl_.forward_target_revision_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ack_peer_routes_revision_ = from._impl_.ack_peer_routes_revision_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.seq_num_c2r_ = from._impl_.seq_num_c2r_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsP2PClientToRouter::CopyFrom(const CMsgSteamDatagramConnectionStatsP2PClientToRouter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsP2PClientToRouter::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsP2PClientToRouter::InternalSwap(CMsgSteamDatagramConnectionStatsP2PClientToRouter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.forward_target_relay_routing_token_, lhs_arena,
      &other->_impl_.forward_target_relay_routing_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.routes_, lhs_arena,
      &other->_impl_.routes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.seq_num_e2e_)
      + sizeof(CMsgSteamDatagramConnectionStatsP2PClientToRouter::_impl_.seq_num_e2e_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsP2PClientToRouter, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsP2PClientToRouter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[34]);
}

// ===================================================================

class CMsgSteamDatagramConnectionStatsP2PRouterToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramConnectionStatsP2PRouterToClient>()._impl_._has_bits_);
  static const ::CMsgSteamDatagramConnectionQuality& quality_relay(const CMsgSteamDatagramConnectionStatsP2PRouterToClient* msg);
  static void set_has_quality_relay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSteamDatagramConnectionQuality& quality_e2e(const CMsgSteamDatagramConnectionStatsP2PRouterToClient* msg);
  static void set_has_quality_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seconds_until_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_migrate_request_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_migrate_request_port(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_scoring_penalty_relay_cluster(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ack_forward_target_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_routes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ack_peer_routes_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_seq_num_r2c(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_seq_num_e2e(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsP2PRouterToClient::_Internal::quality_relay(const CMsgSteamDatagramConnectionStatsP2PRouterToClient* msg) {
  return *msg->_impl_.quality_relay_;
}
const ::CMsgSteamDatagramConnectionQuality&
CMsgSteamDatagramConnectionStatsP2PRouterToClient::_Internal::quality_e2e(const CMsgSteamDatagramConnectionStatsP2PRouterToClient* msg) {
  return *msg->_impl_.quality_e2e_;
}
void CMsgSteamDatagramConnectionStatsP2PRouterToClient::clear_quality_relay() {
  if (_impl_.quality_relay_ != nullptr) _impl_.quality_relay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgSteamDatagramConnectionStatsP2PRouterToClient::clear_quality_e2e() {
  if (_impl_.quality_e2e_ != nullptr) _impl_.quality_e2e_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgSteamDatagramConnectionStatsP2PRouterToClient::CMsgSteamDatagramConnectionStatsP2PRouterToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
}
CMsgSteamDatagramConnectionStatsP2PRouterToClient::CMsgSteamDatagramConnectionStatsP2PRouterToClient(const CMsgSteamDatagramConnectionStatsP2PRouterToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramConnectionStatsP2PRouterToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){from._impl_.ack_relay_}
    , decltype(_impl_.legacy_ack_e2e_){from._impl_.legacy_ack_e2e_}
    , decltype(_impl_.routes_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seconds_until_shutdown_){}
    , decltype(_impl_.migrate_request_ip_){}
    , decltype(_impl_.migrate_request_port_){}
    , decltype(_impl_.scoring_penalty_relay_cluster_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.ack_forward_target_revision_){}
    , decltype(_impl_.ack_peer_routes_revision_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.seq_num_r2c_){}
    , decltype(_impl_.seq_num_e2e_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.routes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_routes()) {
    _this->_impl_.routes_.Set(from._internal_routes(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_quality_relay()) {
    _this->_impl_.quality_relay_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_relay_);
  }
  if (from._internal_has_quality_e2e()) {
    _this->_impl_.quality_e2e_ = new ::CMsgSteamDatagramConnectionQuality(*from._impl_.quality_e2e_);
  }
  ::memcpy(&_impl_.seconds_until_shutdown_, &from._impl_.seconds_until_shutdown_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
    reinterpret_cast<char*>(&_impl_.seconds_until_shutdown_)) + sizeof(_impl_.seq_num_e2e_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
}

inline void CMsgSteamDatagramConnectionStatsP2PRouterToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ack_relay_){arena}
    , decltype(_impl_.legacy_ack_e2e_){arena}
    , decltype(_impl_.routes_){}
    , decltype(_impl_.quality_relay_){nullptr}
    , decltype(_impl_.quality_e2e_){nullptr}
    , decltype(_impl_.seconds_until_shutdown_){0u}
    , decltype(_impl_.migrate_request_ip_){0u}
    , decltype(_impl_.migrate_request_port_){0u}
    , decltype(_impl_.scoring_penalty_relay_cluster_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.ack_forward_target_revision_){0u}
    , decltype(_impl_.ack_peer_routes_revision_){0u}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.seq_num_r2c_){0u}
    , decltype(_impl_.seq_num_e2e_){0u}
  };
  _impl_.routes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.routes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramConnectionStatsP2PRouterToClient::~CMsgSteamDatagramConnectionStatsP2PRouterToClient() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramConnectionStatsP2PRouterToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ack_relay_.~RepeatedField();
  _impl_.legacy_ack_e2e_.~RepeatedField();
  _impl_.routes_.Destroy();
  if (this != internal_default_instance()) delete _impl_.quality_relay_;
  if (this != internal_default_instance()) delete _impl_.quality_e2e_;
}

void CMsgSteamDatagramConnectionStatsP2PRouterToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramConnectionStatsP2PRouterToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_relay_.Clear();
  _impl_.legacy_ack_e2e_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.routes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.quality_relay_ != nullptr);
      _impl_.quality_relay_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.quality_e2e_ != nullptr);
      _impl_.quality_e2e_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.seconds_until_shutdown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.seconds_until_shutdown_)) + sizeof(_impl_.flags_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.ack_forward_target_revision_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_e2e_) -
        reinterpret_cast<char*>(&_impl_.ack_forward_target_revision_)) + sizeof(_impl_.seq_num_e2e_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramConnectionStatsP2PRouterToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_e2e(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_until_shutdown = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seconds_until_shutdown(&has_bits);
          _impl_.seconds_until_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 migrate_request_ip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_migrate_request_ip(&has_bits);
          _impl_.migrate_request_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 migrate_request_port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_migrate_request_port(&has_bits);
          _impl_.migrate_request_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scoring_penalty_relay_cluster = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_scoring_penalty_relay_cluster(&has_bits);
          _impl_.scoring_penalty_relay_cluster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 ack_relay = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_relay(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ack_relay(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 legacy_ack_e2e = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_legacy_ack_e2e(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<69>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_legacy_ack_e2e(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ack_forward_target_revision = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_ack_forward_target_revision(&has_bits);
          _impl_.ack_forward_target_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes routes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_routes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ack_peer_routes_revision = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_ack_peer_routes_revision(&has_bits);
          _impl_.ack_peer_routes_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 connection_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_r2c = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_seq_num_r2c(&has_bits);
          _impl_.seq_num_r2c_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num_e2e = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_seq_num_e2e(&has_bits);
          _impl_.seq_num_e2e_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramConnectionStatsP2PRouterToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::quality_relay(this),
        _Internal::quality_relay(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::quality_e2e(this),
        _Internal::quality_e2e(this).GetCachedSize(), target, stream);
  }

  // optional uint32 seconds_until_shutdown = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seconds_until_shutdown(), target);
  }

  // optional fixed32 migrate_request_ip = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_migrate_request_ip(), target);
  }

  // optional uint32 migrate_request_port = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_migrate_request_port(), target);
  }

  // optional uint32 scoring_penalty_relay_cluster = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_scoring_penalty_relay_cluster(), target);
  }

  // repeated fixed32 ack_relay = 7;
  for (int i = 0, n = this->_internal_ack_relay_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_ack_relay(i), target);
  }

  // repeated fixed32 legacy_ack_e2e = 8;
  for (int i = 0, n = this->_internal_legacy_ack_e2e_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_legacy_ack_e2e(i), target);
  }

  // optional uint32 flags = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_flags(), target);
  }

  // optional uint32 ack_forward_target_revision = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_ack_forward_target_revision(), target);
  }

  // optional bytes routes = 11;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_routes(), target);
  }

  // optional uint32 ack_peer_routes_revision = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_ack_peer_routes_revision(), target);
  }

  // optional fixed32 connection_id = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(13, this->_internal_connection_id(), target);
  }

  // optional uint32 seq_num_r2c = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_seq_num_r2c(), target);
  }

  // optional uint32 seq_num_e2e = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_seq_num_e2e(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  return target;
}

size_t CMsgSteamDatagramConnectionStatsP2PRouterToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ack_relay = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ack_relay_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ack_relay_size());
    total_size += data_size;
  }

  // repeated fixed32 legacy_ack_e2e = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_legacy_ack_e2e_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_legacy_ack_e2e_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes routes = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_routes());
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_relay_);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quality_e2e_);
    }

    // optional uint32 seconds_until_shutdown = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_until_shutdown());
    }

    // optional fixed32 migrate_request_ip = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 migrate_request_port = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_migrate_request_port());
    }

    // optional uint32 scoring_penalty_relay_cluster = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scoring_penalty_relay_cluster());
    }

    // optional uint32 flags = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 ack_forward_target_revision = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ack_forward_target_revision());
    }

    // optional uint32 ack_peer_routes_revision = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ack_peer_routes_revision());
    }

    // optional fixed32 connection_id = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional uint32 seq_num_r2c = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_r2c());
    }

    // optional uint32 seq_num_e2e = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num_e2e());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramConnectionStatsP2PRouterToClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramConnectionStatsP2PRouterToClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramConnectionStatsP2PRouterToClient::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramConnectionStatsP2PRouterToClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramConnectionStatsP2PRouterToClient*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramConnectionStatsP2PRouterToClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ack_relay_.MergeFrom(from._impl_.ack_relay_);
  _this->_impl_.legacy_ack_e2e_.MergeFrom(from._impl_.legacy_ack_e2e_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_routes(from._internal_routes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quality_relay()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_relay());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_quality_e2e()->::CMsgSteamDatagramConnectionQuality::MergeFrom(
          from._internal_quality_e2e());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seconds_until_shutdown_ = from._impl_.seconds_until_shutdown_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.migrate_request_ip_ = from._impl_.migrate_request_ip_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.migrate_request_port_ = from._impl_.migrate_request_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.scoring_penalty_relay_cluster_ = from._impl_.scoring_penalty_relay_cluster_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ack_forward_target_revision_ = from._impl_.ack_forward_target_revision_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ack_peer_routes_revision_ = from._impl_.ack_peer_routes_revision_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.seq_num_r2c_ = from._impl_.seq_num_r2c_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.seq_num_e2e_ = from._impl_.seq_num_e2e_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramConnectionStatsP2PRouterToClient::CopyFrom(const CMsgSteamDatagramConnectionStatsP2PRouterToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramConnectionStatsP2PRouterToClient::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramConnectionStatsP2PRouterToClient::InternalSwap(CMsgSteamDatagramConnectionStatsP2PRouterToClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_relay_.InternalSwap(&other->_impl_.ack_relay_);
  _impl_.legacy_ack_e2e_.InternalSwap(&other->_impl_.legacy_ack_e2e_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.routes_, lhs_arena,
      &other->_impl_.routes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.seq_num_e2e_)
      + sizeof(CMsgSteamDatagramConnectionStatsP2PRouterToClient::_impl_.seq_num_e2e_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramConnectionStatsP2PRouterToClient, _impl_.quality_relay_)>(
          reinterpret_cast<char*>(&_impl_.quality_relay_),
          reinterpret_cast<char*>(&other->_impl_.quality_relay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramConnectionStatsP2PRouterToClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[35]);
}

// ===================================================================

class CMsgSteamDatagramP2PBadRouteRouterToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PBadRouteRouterToClient>()._impl_._has_bits_);
  static void set_has_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_failed_relay_routing_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ack_forward_target_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kludge_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSteamDatagramP2PBadRouteRouterToClient::CMsgSteamDatagramP2PBadRouteRouterToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PBadRouteRouterToClient)
}
CMsgSteamDatagramP2PBadRouteRouterToClient::CMsgSteamDatagramP2PBadRouteRouterToClient(const CMsgSteamDatagramP2PBadRouteRouterToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PBadRouteRouterToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.failed_relay_routing_token_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.ack_forward_target_revision_){}
    , decltype(_impl_.kludge_pad_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.failed_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.failed_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_failed_relay_routing_token()) {
    _this->_impl_.failed_relay_routing_token_.Set(from._internal_failed_relay_routing_token(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kludge_pad_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.kludge_pad_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PBadRouteRouterToClient)
}

inline void CMsgSteamDatagramP2PBadRouteRouterToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.failed_relay_routing_token_){}
    , decltype(_impl_.connection_id_){0u}
    , decltype(_impl_.ack_forward_target_revision_){0u}
    , decltype(_impl_.kludge_pad_){uint64_t{0u}}
  };
  _impl_.failed_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.failed_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PBadRouteRouterToClient::~CMsgSteamDatagramP2PBadRouteRouterToClient() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PBadRouteRouterToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PBadRouteRouterToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.failed_relay_routing_token_.Destroy();
}

void CMsgSteamDatagramP2PBadRouteRouterToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PBadRouteRouterToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PBadRouteRouterToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.failed_relay_routing_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kludge_pad_) -
        reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.kludge_pad_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PBadRouteRouterToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 connection_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_connection_id(&has_bits);
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes failed_relay_routing_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_failed_relay_routing_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ack_forward_target_revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ack_forward_target_revision(&has_bits);
          _impl_.ack_forward_target_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 kludge_pad = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_kludge_pad(&has_bits);
          _impl_.kludge_pad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PBadRouteRouterToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PBadRouteRouterToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 connection_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_connection_id(), target);
  }

  // optional bytes failed_relay_routing_token = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_failed_relay_routing_token(), target);
  }

  // optional uint32 ack_forward_target_revision = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ack_forward_target_revision(), target);
  }

  // optional fixed64 kludge_pad = 99;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(99, this->_internal_kludge_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PBadRouteRouterToClient)
  return target;
}

size_t CMsgSteamDatagramP2PBadRouteRouterToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PBadRouteRouterToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes failed_relay_routing_token = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_failed_relay_routing_token());
    }

    // optional fixed32 connection_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 ack_forward_target_revision = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ack_forward_target_revision());
    }

    // optional fixed64 kludge_pad = 99;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PBadRouteRouterToClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PBadRouteRouterToClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PBadRouteRouterToClient::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PBadRouteRouterToClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PBadRouteRouterToClient*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PBadRouteRouterToClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PBadRouteRouterToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_failed_relay_routing_token(from._internal_failed_relay_routing_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.connection_id_ = from._impl_.connection_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ack_forward_target_revision_ = from._impl_.ack_forward_target_revision_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.kludge_pad_ = from._impl_.kludge_pad_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PBadRouteRouterToClient::CopyFrom(const CMsgSteamDatagramP2PBadRouteRouterToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PBadRouteRouterToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PBadRouteRouterToClient::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PBadRouteRouterToClient::InternalSwap(CMsgSteamDatagramP2PBadRouteRouterToClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.failed_relay_routing_token_, lhs_arena,
      &other->_impl_.failed_relay_routing_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.kludge_pad_)
      + sizeof(CMsgSteamDatagramP2PBadRouteRouterToClient::_impl_.kludge_pad_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PBadRouteRouterToClient, _impl_.connection_id_)>(
          reinterpret_cast<char*>(&_impl_.connection_id_),
          reinterpret_cast<char*>(&other->_impl_.connection_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PBadRouteRouterToClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[36]);
}

// ===================================================================

class CMsgSteamDatagramP2PRoutes_RelayCluster::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PRoutes_RelayCluster>()._impl_._has_bits_);
  static void set_has_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_score_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_session_relay_routing_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramP2PRoutes_RelayCluster::CMsgSteamDatagramP2PRoutes_RelayCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PRoutes.RelayCluster)
}
CMsgSteamDatagramP2PRoutes_RelayCluster::CMsgSteamDatagramP2PRoutes_RelayCluster(const CMsgSteamDatagramP2PRoutes_RelayCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PRoutes_RelayCluster* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_relay_routing_token_){}
    , decltype(_impl_.pop_id_){}
    , decltype(_impl_.ping_ms_){}
    , decltype(_impl_.score_penalty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.session_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_session_relay_routing_token()) {
    _this->_impl_.session_relay_routing_token_.Set(from._internal_session_relay_routing_token(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pop_id_, &from._impl_.pop_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.score_penalty_) -
    reinterpret_cast<char*>(&_impl_.pop_id_)) + sizeof(_impl_.score_penalty_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PRoutes.RelayCluster)
}

inline void CMsgSteamDatagramP2PRoutes_RelayCluster::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_relay_routing_token_){}
    , decltype(_impl_.pop_id_){0u}
    , decltype(_impl_.ping_ms_){0u}
    , decltype(_impl_.score_penalty_){0u}
  };
  _impl_.session_relay_routing_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_relay_routing_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramP2PRoutes_RelayCluster::~CMsgSteamDatagramP2PRoutes_RelayCluster() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PRoutes.RelayCluster)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PRoutes_RelayCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.session_relay_routing_token_.Destroy();
}

void CMsgSteamDatagramP2PRoutes_RelayCluster::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PRoutes_RelayCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PRoutes.RelayCluster)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.session_relay_routing_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.pop_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.score_penalty_) -
        reinterpret_cast<char*>(&_impl_.pop_id_)) + sizeof(_impl_.score_penalty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PRoutes_RelayCluster::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 pop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_pop_id(&has_bits);
          _impl_.pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ping_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ping_ms(&has_bits);
          _impl_.ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 score_penalty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_score_penalty(&has_bits);
          _impl_.score_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes session_relay_routing_token = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_session_relay_routing_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PRoutes_RelayCluster::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PRoutes.RelayCluster)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 pop_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_pop_id(), target);
  }

  // optional uint32 ping_ms = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ping_ms(), target);
  }

  // optional uint32 score_penalty = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_score_penalty(), target);
  }

  // optional bytes session_relay_routing_token = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_session_relay_routing_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PRoutes.RelayCluster)
  return target;
}

size_t CMsgSteamDatagramP2PRoutes_RelayCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PRoutes.RelayCluster)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes session_relay_routing_token = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_session_relay_routing_token());
    }

    // optional fixed32 pop_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 ping_ms = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ping_ms());
    }

    // optional uint32 score_penalty = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_score_penalty());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PRoutes_RelayCluster::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PRoutes_RelayCluster::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PRoutes_RelayCluster::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PRoutes_RelayCluster::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PRoutes_RelayCluster*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PRoutes_RelayCluster&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PRoutes.RelayCluster)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_session_relay_routing_token(from._internal_session_relay_routing_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pop_id_ = from._impl_.pop_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ping_ms_ = from._impl_.ping_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.score_penalty_ = from._impl_.score_penalty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PRoutes_RelayCluster::CopyFrom(const CMsgSteamDatagramP2PRoutes_RelayCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PRoutes.RelayCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PRoutes_RelayCluster::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PRoutes_RelayCluster::InternalSwap(CMsgSteamDatagramP2PRoutes_RelayCluster* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.session_relay_routing_token_, lhs_arena,
      &other->_impl_.session_relay_routing_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.score_penalty_)
      + sizeof(CMsgSteamDatagramP2PRoutes_RelayCluster::_impl_.score_penalty_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutes_RelayCluster, _impl_.pop_id_)>(
          reinterpret_cast<char*>(&_impl_.pop_id_),
          reinterpret_cast<char*>(&other->_impl_.pop_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PRoutes_RelayCluster::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[37]);
}

// ===================================================================

class CMsgSteamDatagramP2PRoutes_Route::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PRoutes_Route>()._impl_._has_bits_);
  static void set_has_my_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_your_pop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_legacy_score(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_interior_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSteamDatagramP2PRoutes_Route::CMsgSteamDatagramP2PRoutes_Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PRoutes.Route)
}
CMsgSteamDatagramP2PRoutes_Route::CMsgSteamDatagramP2PRoutes_Route(const CMsgSteamDatagramP2PRoutes_Route& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PRoutes_Route* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.my_pop_id_){}
    , decltype(_impl_.your_pop_id_){}
    , decltype(_impl_.legacy_score_){}
    , decltype(_impl_.interior_score_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.my_pop_id_, &from._impl_.my_pop_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.interior_score_) -
    reinterpret_cast<char*>(&_impl_.my_pop_id_)) + sizeof(_impl_.interior_score_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PRoutes.Route)
}

inline void CMsgSteamDatagramP2PRoutes_Route::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.my_pop_id_){0u}
    , decltype(_impl_.your_pop_id_){0u}
    , decltype(_impl_.legacy_score_){0u}
    , decltype(_impl_.interior_score_){0u}
  };
}

CMsgSteamDatagramP2PRoutes_Route::~CMsgSteamDatagramP2PRoutes_Route() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PRoutes.Route)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PRoutes_Route::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSteamDatagramP2PRoutes_Route::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PRoutes_Route::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PRoutes.Route)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.my_pop_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.interior_score_) -
        reinterpret_cast<char*>(&_impl_.my_pop_id_)) + sizeof(_impl_.interior_score_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PRoutes_Route::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 my_pop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_my_pop_id(&has_bits);
          _impl_.my_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 your_pop_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_your_pop_id(&has_bits);
          _impl_.your_pop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 legacy_score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_legacy_score(&has_bits);
          _impl_.legacy_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 interior_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_interior_score(&has_bits);
          _impl_.interior_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PRoutes_Route::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PRoutes.Route)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 my_pop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_my_pop_id(), target);
  }

  // optional fixed32 your_pop_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_your_pop_id(), target);
  }

  // optional uint32 legacy_score = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_legacy_score(), target);
  }

  // optional uint32 interior_score = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_interior_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PRoutes.Route)
  return target;
}

size_t CMsgSteamDatagramP2PRoutes_Route::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PRoutes.Route)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional fixed32 my_pop_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 your_pop_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 legacy_score = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_score());
    }

    // optional uint32 interior_score = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_interior_score());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PRoutes_Route::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PRoutes_Route::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PRoutes_Route::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PRoutes_Route::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PRoutes_Route*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PRoutes_Route&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PRoutes.Route)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.my_pop_id_ = from._impl_.my_pop_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.your_pop_id_ = from._impl_.your_pop_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.legacy_score_ = from._impl_.legacy_score_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.interior_score_ = from._impl_.interior_score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PRoutes_Route::CopyFrom(const CMsgSteamDatagramP2PRoutes_Route& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PRoutes.Route)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PRoutes_Route::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PRoutes_Route::InternalSwap(CMsgSteamDatagramP2PRoutes_Route* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutes_Route, _impl_.interior_score_)
      + sizeof(CMsgSteamDatagramP2PRoutes_Route::_impl_.interior_score_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramP2PRoutes_Route, _impl_.my_pop_id_)>(
          reinterpret_cast<char*>(&_impl_.my_pop_id_),
          reinterpret_cast<char*>(&other->_impl_.my_pop_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PRoutes_Route::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[38]);
}

// ===================================================================

class CMsgSteamDatagramP2PRoutes::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramP2PRoutes>()._impl_._has_bits_);
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramP2PRoutes::CMsgSteamDatagramP2PRoutes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramP2PRoutes)
}
CMsgSteamDatagramP2PRoutes::CMsgSteamDatagramP2PRoutes(const CMsgSteamDatagramP2PRoutes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramP2PRoutes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relay_clusters_){from._impl_.relay_clusters_}
    , decltype(_impl_.routes_){from._impl_.routes_}
    , decltype(_impl_.revision_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.revision_ = from._impl_.revision_;
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramP2PRoutes)
}

inline void CMsgSteamDatagramP2PRoutes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relay_clusters_){arena}
    , decltype(_impl_.routes_){arena}
    , decltype(_impl_.revision_){0u}
  };
}

CMsgSteamDatagramP2PRoutes::~CMsgSteamDatagramP2PRoutes() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramP2PRoutes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramP2PRoutes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.relay_clusters_.~RepeatedPtrField();
  _impl_.routes_.~RepeatedPtrField();
}

void CMsgSteamDatagramP2PRoutes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramP2PRoutes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramP2PRoutes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.relay_clusters_.Clear();
  _impl_.routes_.Clear();
  _impl_.revision_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramP2PRoutes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_relay_clusters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSteamDatagramP2PRoutes.Route routes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_routes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_revision(&has_bits);
          _impl_.revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramP2PRoutes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramP2PRoutes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_relay_clusters_size()); i < n; i++) {
    const auto& repfield = this->_internal_relay_clusters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSteamDatagramP2PRoutes.Route routes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_routes_size()); i < n; i++) {
    const auto& repfield = this->_internal_routes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 revision = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_revision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramP2PRoutes)
  return target;
}

size_t CMsgSteamDatagramP2PRoutes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramP2PRoutes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;
  total_size += 1UL * this->_internal_relay_clusters_size();
  for (const auto& msg : this->_impl_.relay_clusters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSteamDatagramP2PRoutes.Route routes = 2;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->_impl_.routes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 revision = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_revision());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramP2PRoutes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramP2PRoutes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramP2PRoutes::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramP2PRoutes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramP2PRoutes*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramP2PRoutes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramP2PRoutes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.relay_clusters_.MergeFrom(from._impl_.relay_clusters_);
  _this->_impl_.routes_.MergeFrom(from._impl_.routes_);
  if (from._internal_has_revision()) {
    _this->_internal_set_revision(from._internal_revision());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramP2PRoutes::CopyFrom(const CMsgSteamDatagramP2PRoutes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramP2PRoutes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramP2PRoutes::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramP2PRoutes::InternalSwap(CMsgSteamDatagramP2PRoutes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.relay_clusters_.InternalSwap(&other->_impl_.relay_clusters_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
  swap(_impl_.revision_, other->_impl_.revision_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramP2PRoutes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[39]);
}

// ===================================================================

class CMsgSteamDatagramSetSecondaryAddressRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramSetSecondaryAddressRequest>()._impl_._has_bits_);
  static void set_has_client_main_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_main_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_connection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_send_duplication(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kludge_pad(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSteamDatagramSetSecondaryAddressRequest::CMsgSteamDatagramSetSecondaryAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramSetSecondaryAddressRequest)
}
CMsgSteamDatagramSetSecondaryAddressRequest::CMsgSteamDatagramSetSecondaryAddressRequest(const CMsgSteamDatagramSetSecondaryAddressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramSetSecondaryAddressRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_identity_){}
    , decltype(_impl_.kludge_pad_){}
    , decltype(_impl_.client_main_ip_){}
    , decltype(_impl_.client_main_port_){}
    , decltype(_impl_.client_connection_id_){}
    , decltype(_impl_.request_send_duplication_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_identity()) {
    _this->_impl_.client_identity_.Set(from._internal_client_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kludge_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kludge_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kludge_pad()) {
    _this->_impl_.kludge_pad_.Set(from._internal_kludge_pad(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.client_main_ip_, &from._impl_.client_main_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.request_send_duplication_) -
    reinterpret_cast<char*>(&_impl_.client_main_ip_)) + sizeof(_impl_.request_send_duplication_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramSetSecondaryAddressRequest)
}

inline void CMsgSteamDatagramSetSecondaryAddressRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_identity_){}
    , decltype(_impl_.kludge_pad_){}
    , decltype(_impl_.client_main_ip_){0u}
    , decltype(_impl_.client_main_port_){0u}
    , decltype(_impl_.client_connection_id_){0u}
    , decltype(_impl_.request_send_duplication_){false}
  };
  _impl_.client_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kludge_pad_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kludge_pad_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramSetSecondaryAddressRequest::~CMsgSteamDatagramSetSecondaryAddressRequest() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramSetSecondaryAddressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramSetSecondaryAddressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_identity_.Destroy();
  _impl_.kludge_pad_.Destroy();
}

void CMsgSteamDatagramSetSecondaryAddressRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramSetSecondaryAddressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramSetSecondaryAddressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.kludge_pad_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.client_main_ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.request_send_duplication_) -
        reinterpret_cast<char*>(&_impl_.client_main_ip_)) + sizeof(_impl_.request_send_duplication_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramSetSecondaryAddressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 client_main_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_client_main_ip(&has_bits);
          _impl_.client_main_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_main_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_client_main_port(&has_bits);
          _impl_.client_main_port_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 client_connection_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_client_connection_id(&has_bits);
          _impl_.client_connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string client_identity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_client_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramSetSecondaryAddressRequest.client_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool request_send_duplication = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_request_send_duplication(&has_bits);
          _impl_.request_send_duplication_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kludge_pad = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_kludge_pad();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramSetSecondaryAddressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramSetSecondaryAddressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 client_main_ip = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_client_main_ip(), target);
  }

  // optional fixed32 client_main_port = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_client_main_port(), target);
  }

  // optional fixed32 client_connection_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_client_connection_id(), target);
  }

  // optional string client_identity = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_client_identity().data(), static_cast<int>(this->_internal_client_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramSetSecondaryAddressRequest.client_identity");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_client_identity(), target);
  }

  // optional bool request_send_duplication = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_request_send_duplication(), target);
  }

  // optional bytes kludge_pad = 99;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        99, this->_internal_kludge_pad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramSetSecondaryAddressRequest)
  return target;
}

size_t CMsgSteamDatagramSetSecondaryAddressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramSetSecondaryAddressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_identity = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_identity());
    }

    // optional bytes kludge_pad = 99;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kludge_pad());
    }

    // optional fixed32 client_main_ip = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed32 client_main_port = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional fixed32 client_connection_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool request_send_duplication = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramSetSecondaryAddressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramSetSecondaryAddressRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramSetSecondaryAddressRequest::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramSetSecondaryAddressRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramSetSecondaryAddressRequest*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramSetSecondaryAddressRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramSetSecondaryAddressRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_identity(from._internal_client_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_kludge_pad(from._internal_kludge_pad());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_main_ip_ = from._impl_.client_main_ip_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_main_port_ = from._impl_.client_main_port_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_connection_id_ = from._impl_.client_connection_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_send_duplication_ = from._impl_.request_send_duplication_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramSetSecondaryAddressRequest::CopyFrom(const CMsgSteamDatagramSetSecondaryAddressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramSetSecondaryAddressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramSetSecondaryAddressRequest::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramSetSecondaryAddressRequest::InternalSwap(CMsgSteamDatagramSetSecondaryAddressRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_identity_, lhs_arena,
      &other->_impl_.client_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kludge_pad_, lhs_arena,
      &other->_impl_.kludge_pad_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.request_send_duplication_)
      + sizeof(CMsgSteamDatagramSetSecondaryAddressRequest::_impl_.request_send_duplication_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamDatagramSetSecondaryAddressRequest, _impl_.client_main_ip_)>(
          reinterpret_cast<char*>(&_impl_.client_main_ip_),
          reinterpret_cast<char*>(&other->_impl_.client_main_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramSetSecondaryAddressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[40]);
}

// ===================================================================

class CMsgSteamDatagramSetSecondaryAddressResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamDatagramSetSecondaryAddressResult>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSteamDatagramSetSecondaryAddressResult::CMsgSteamDatagramSetSecondaryAddressResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamDatagramSetSecondaryAddressResult)
}
CMsgSteamDatagramSetSecondaryAddressResult::CMsgSteamDatagramSetSecondaryAddressResult(const CMsgSteamDatagramSetSecondaryAddressResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamDatagramSetSecondaryAddressResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:CMsgSteamDatagramSetSecondaryAddressResult)
}

inline void CMsgSteamDatagramSetSecondaryAddressResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.success_){false}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSteamDatagramSetSecondaryAddressResult::~CMsgSteamDatagramSetSecondaryAddressResult() {
  // @@protoc_insertion_point(destructor:CMsgSteamDatagramSetSecondaryAddressResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamDatagramSetSecondaryAddressResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void CMsgSteamDatagramSetSecondaryAddressResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamDatagramSetSecondaryAddressResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamDatagramSetSecondaryAddressResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamDatagramSetSecondaryAddressResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSteamDatagramSetSecondaryAddressResult.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamDatagramSetSecondaryAddressResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamDatagramSetSecondaryAddressResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSteamDatagramSetSecondaryAddressResult.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamDatagramSetSecondaryAddressResult)
  return target;
}

size_t CMsgSteamDatagramSetSecondaryAddressResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamDatagramSetSecondaryAddressResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamDatagramSetSecondaryAddressResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamDatagramSetSecondaryAddressResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamDatagramSetSecondaryAddressResult::GetClassData() const { return &_class_data_; }


void CMsgSteamDatagramSetSecondaryAddressResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamDatagramSetSecondaryAddressResult*>(&to_msg);
  auto& from = static_cast<const CMsgSteamDatagramSetSecondaryAddressResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamDatagramSetSecondaryAddressResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamDatagramSetSecondaryAddressResult::CopyFrom(const CMsgSteamDatagramSetSecondaryAddressResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamDatagramSetSecondaryAddressResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamDatagramSetSecondaryAddressResult::IsInitialized() const {
  return true;
}

void CMsgSteamDatagramSetSecondaryAddressResult::InternalSwap(CMsgSteamDatagramSetSecondaryAddressResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamDatagramSetSecondaryAddressResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_getter, &descriptor_table_steamdatagram_5fmessages_5fsdr_2eproto_once,
      file_level_metadata_steamdatagram_5fmessages_5fsdr_2eproto[41]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgSteamNetworkingIPAddress*
Arena::CreateMaybeMessage< ::CMsgSteamNetworkingIPAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamNetworkingIPAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramSignedMessageGeneric*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramSignedMessageGeneric >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramSignedMessageGeneric >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramRouterPingReply_RouteException*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramRouterPingReply_RouteException >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramRouterPingReply_RouteException >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramRouterPingReply_AltAddress*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramRouterPingReply_AltAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramRouterPingReply_AltAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramRouterPingReply*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramRouterPingReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramRouterPingReply >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramGameserverPingRequestBody*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramGameserverPingRequestBody >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramGameserverPingRequestBody >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramGameserverPingRequestEnvelope*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramGameserverPingRequestEnvelope >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramGameserverPingRequestEnvelope >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramGameserverPingReplyData*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramGameserverPingReplyData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramGameserverPingReplyData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramNoSessionRelayToClient*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramNoSessionRelayToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramNoSessionRelayToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramNoSessionRelayToPeer*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramNoSessionRelayToPeer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramNoSessionRelayToPeer >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTOSTreatment*
Arena::CreateMaybeMessage< ::CMsgTOSTreatment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTOSTreatment >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientPingSampleRequest*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientPingSampleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientPingSampleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientPingSampleReply_POP_AltAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientPingSampleReply_POP*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientPingSampleReply_POP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientPingSampleReply_POP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientPingSampleReply*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientPingSampleReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientPingSampleReply >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientSwitchedPrimary_RouterQuality >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramClientSwitchedPrimary*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramClientSwitchedPrimary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramClientSwitchedPrimary >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectRequest*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectOK*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectOK >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectOK >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamNetworkingP2PSDRRoutingSummary*
Arena::CreateMaybeMessage< ::CMsgSteamNetworkingP2PSDRRoutingSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamNetworkingP2PSDRRoutingSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PRoutingSummary*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PRoutingSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PRoutingSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionClosed*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionClosed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionClosed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramNoConnection*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramNoConnection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramNoConnection >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramGameserverSessionRequest*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramGameserverSessionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramGameserverSessionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramGameserverSessionEstablished*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramGameserverSessionEstablished >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramGameserverSessionEstablished >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsClientToRouter*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsClientToRouter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsClientToRouter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsRouterToClient*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsRouterToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsRouterToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsRouterToServer*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsRouterToServer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsRouterToServer >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsServerToRouter*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsServerToRouter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsServerToRouter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PSessionRequestBody_EncryptedData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PSessionRequestBody*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PSessionRequestBody >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PSessionRequestBody >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PSessionRequest*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PSessionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PSessionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PSessionEstablished*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PSessionEstablished >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PSessionEstablished >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsP2PClientToRouter*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsP2PClientToRouter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsP2PClientToRouter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramConnectionStatsP2PRouterToClient*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramConnectionStatsP2PRouterToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramConnectionStatsP2PRouterToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PBadRouteRouterToClient*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PBadRouteRouterToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PBadRouteRouterToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PRoutes_RelayCluster*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PRoutes_RelayCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PRoutes_RelayCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PRoutes_Route*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PRoutes_Route >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PRoutes_Route >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramP2PRoutes*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramP2PRoutes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramP2PRoutes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramSetSecondaryAddressRequest*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramSetSecondaryAddressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramSetSecondaryAddressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamDatagramSetSecondaryAddressResult*
Arena::CreateMaybeMessage< ::CMsgSteamDatagramSetSecondaryAddressResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamDatagramSetSecondaryAddressResult >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
