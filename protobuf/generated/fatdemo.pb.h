// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fatdemo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fatdemo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fatdemo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fatdemo_2eproto;
class MLDemoHeader;
struct MLDemoHeaderDefaultTypeInternal;
extern MLDemoHeaderDefaultTypeInternal _MLDemoHeader_default_instance_;
class MLDict;
struct MLDictDefaultTypeInternal;
extern MLDictDefaultTypeInternal _MLDict_default_instance_;
class MLEvent;
struct MLEventDefaultTypeInternal;
extern MLEventDefaultTypeInternal _MLEvent_default_instance_;
class MLGameState;
struct MLGameStateDefaultTypeInternal;
extern MLGameStateDefaultTypeInternal _MLGameState_default_instance_;
class MLMatchState;
struct MLMatchStateDefaultTypeInternal;
extern MLMatchStateDefaultTypeInternal _MLMatchState_default_instance_;
class MLPlayerState;
struct MLPlayerStateDefaultTypeInternal;
extern MLPlayerStateDefaultTypeInternal _MLPlayerState_default_instance_;
class MLRoundState;
struct MLRoundStateDefaultTypeInternal;
extern MLRoundStateDefaultTypeInternal _MLRoundState_default_instance_;
class MLTick;
struct MLTickDefaultTypeInternal;
extern MLTickDefaultTypeInternal _MLTick_default_instance_;
class MLWeaponState;
struct MLWeaponStateDefaultTypeInternal;
extern MLWeaponStateDefaultTypeInternal _MLWeaponState_default_instance_;
class VacNetShot;
struct VacNetShotDefaultTypeInternal;
extern VacNetShotDefaultTypeInternal _VacNetShot_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::MLDemoHeader* Arena::CreateMaybeMessage<::MLDemoHeader>(Arena*);
template<> ::MLDict* Arena::CreateMaybeMessage<::MLDict>(Arena*);
template<> ::MLEvent* Arena::CreateMaybeMessage<::MLEvent>(Arena*);
template<> ::MLGameState* Arena::CreateMaybeMessage<::MLGameState>(Arena*);
template<> ::MLMatchState* Arena::CreateMaybeMessage<::MLMatchState>(Arena*);
template<> ::MLPlayerState* Arena::CreateMaybeMessage<::MLPlayerState>(Arena*);
template<> ::MLRoundState* Arena::CreateMaybeMessage<::MLRoundState>(Arena*);
template<> ::MLTick* Arena::CreateMaybeMessage<::MLTick>(Arena*);
template<> ::MLWeaponState* Arena::CreateMaybeMessage<::MLWeaponState>(Arena*);
template<> ::VacNetShot* Arena::CreateMaybeMessage<::VacNetShot>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EHitGroup : int {
  EHG_Generic = 0,
  EHG_Head = 1,
  EHG_Chest = 2,
  EHG_Stomach = 3,
  EHG_LeftArm = 4,
  EHG_RightArm = 5,
  EHG_LeftLeg = 6,
  EHG_RightLeg = 7,
  EHG_Gear = 8,
  EHG_Miss = 9
};
bool EHitGroup_IsValid(int value);
constexpr EHitGroup EHitGroup_MIN = EHG_Generic;
constexpr EHitGroup EHitGroup_MAX = EHG_Miss;
constexpr int EHitGroup_ARRAYSIZE = EHitGroup_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHitGroup_descriptor();
template<typename T>
inline const std::string& EHitGroup_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHitGroup>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHitGroup_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHitGroup_descriptor(), enum_t_value);
}
inline bool EHitGroup_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHitGroup* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHitGroup>(
    EHitGroup_descriptor(), name, value);
}
enum ETeam : int {
  ET_Unknown = 0,
  ET_Spectator = 1,
  ET_Terrorist = 2,
  ET_CT = 3
};
bool ETeam_IsValid(int value);
constexpr ETeam ETeam_MIN = ET_Unknown;
constexpr ETeam ETeam_MAX = ET_CT;
constexpr int ETeam_ARRAYSIZE = ETeam_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETeam_descriptor();
template<typename T>
inline const std::string& ETeam_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETeam>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETeam_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETeam_descriptor(), enum_t_value);
}
inline bool ETeam_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETeam* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETeam>(
    ETeam_descriptor(), name, value);
}
enum EWeaponType : int {
  EWT_Knife = 0,
  EWT_Pistol = 1,
  EWT_SubMachineGun = 2,
  EWT_Rifle = 3,
  EWT_Shotgun = 4,
  EWT_SniperRifle = 5,
  EWT_MachineGun = 6,
  EWT_C4 = 7,
  EWT_Grenade = 8,
  EWT_Equipment = 9,
  EWT_StackableItem = 10,
  EWT_Unknown = 11
};
bool EWeaponType_IsValid(int value);
constexpr EWeaponType EWeaponType_MIN = EWT_Knife;
constexpr EWeaponType EWeaponType_MAX = EWT_Unknown;
constexpr int EWeaponType_ARRAYSIZE = EWeaponType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EWeaponType_descriptor();
template<typename T>
inline const std::string& EWeaponType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EWeaponType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EWeaponType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EWeaponType_descriptor(), enum_t_value);
}
inline bool EWeaponType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EWeaponType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EWeaponType>(
    EWeaponType_descriptor(), name, value);
}
// ===================================================================

class MLDict final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLDict) */ {
 public:
  inline MLDict() : MLDict(nullptr) {}
  ~MLDict() override;
  explicit PROTOBUF_CONSTEXPR MLDict(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLDict(const MLDict& from);
  MLDict(MLDict&& from) noexcept
    : MLDict() {
    *this = ::std::move(from);
  }

  inline MLDict& operator=(const MLDict& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDict& operator=(MLDict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDict& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLDict* internal_default_instance() {
    return reinterpret_cast<const MLDict*>(
               &_MLDict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MLDict& a, MLDict& b) {
    a.Swap(&b);
  }
  inline void Swap(MLDict* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDict* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDict* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLDict>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLDict& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLDict& from) {
    MLDict::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLDict* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLDict";
  }
  protected:
  explicit MLDict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValStringFieldNumber = 2,
    kValIntFieldNumber = 3,
    kValFloatFieldNumber = 4,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string val_string = 2;
  bool has_val_string() const;
  private:
  bool _internal_has_val_string() const;
  public:
  void clear_val_string();
  const std::string& val_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val_string();
  PROTOBUF_NODISCARD std::string* release_val_string();
  void set_allocated_val_string(std::string* val_string);
  private:
  const std::string& _internal_val_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val_string(const std::string& value);
  std::string* _internal_mutable_val_string();
  public:

  // optional int32 val_int = 3;
  bool has_val_int() const;
  private:
  bool _internal_has_val_int() const;
  public:
  void clear_val_int();
  int32_t val_int() const;
  void set_val_int(int32_t value);
  private:
  int32_t _internal_val_int() const;
  void _internal_set_val_int(int32_t value);
  public:

  // optional float val_float = 4;
  bool has_val_float() const;
  private:
  bool _internal_has_val_float() const;
  public:
  void clear_val_float();
  float val_float() const;
  void set_val_float(float value);
  private:
  float _internal_val_float() const;
  void _internal_set_val_float(float value);
  public:

  // @@protoc_insertion_point(class_scope:MLDict)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_string_;
    int32_t val_int_;
    float val_float_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLEvent) */ {
 public:
  inline MLEvent() : MLEvent(nullptr) {}
  ~MLEvent() override;
  explicit PROTOBUF_CONSTEXPR MLEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLEvent(const MLEvent& from);
  MLEvent(MLEvent&& from) noexcept
    : MLEvent() {
    *this = ::std::move(from);
  }

  inline MLEvent& operator=(const MLEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLEvent& operator=(MLEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLEvent* internal_default_instance() {
    return reinterpret_cast<const MLEvent*>(
               &_MLEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MLEvent& a, MLEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MLEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLEvent& from) {
    MLEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLEvent";
  }
  protected:
  explicit MLEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kEventNameFieldNumber = 1,
  };
  // repeated .MLDict data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::MLDict* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLDict >*
      mutable_data();
  private:
  const ::MLDict& _internal_data(int index) const;
  ::MLDict* _internal_add_data();
  public:
  const ::MLDict& data(int index) const;
  ::MLDict* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLDict >&
      data() const;

  // optional string event_name = 1;
  bool has_event_name() const;
  private:
  bool _internal_has_event_name() const;
  public:
  void clear_event_name();
  const std::string& event_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_name();
  PROTOBUF_NODISCARD std::string* release_event_name();
  void set_allocated_event_name(std::string* event_name);
  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(const std::string& value);
  std::string* _internal_mutable_event_name();
  public:

  // @@protoc_insertion_point(class_scope:MLEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLDict > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLMatchState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLMatchState) */ {
 public:
  inline MLMatchState() : MLMatchState(nullptr) {}
  ~MLMatchState() override;
  explicit PROTOBUF_CONSTEXPR MLMatchState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLMatchState(const MLMatchState& from);
  MLMatchState(MLMatchState&& from) noexcept
    : MLMatchState() {
    *this = ::std::move(from);
  }

  inline MLMatchState& operator=(const MLMatchState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLMatchState& operator=(MLMatchState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLMatchState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLMatchState* internal_default_instance() {
    return reinterpret_cast<const MLMatchState*>(
               &_MLMatchState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MLMatchState& a, MLMatchState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLMatchState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLMatchState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLMatchState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLMatchState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLMatchState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLMatchState& from) {
    MLMatchState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLMatchState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLMatchState";
  }
  protected:
  explicit MLMatchState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameModeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kRoundFieldNumber = 3,
    kScoreCtFieldNumber = 4,
    kScoreTFieldNumber = 5,
  };
  // optional string game_mode = 1;
  bool has_game_mode() const;
  private:
  bool _internal_has_game_mode() const;
  public:
  void clear_game_mode();
  const std::string& game_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_mode();
  PROTOBUF_NODISCARD std::string* release_game_mode();
  void set_allocated_game_mode(std::string* game_mode);
  private:
  const std::string& _internal_game_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_mode(const std::string& value);
  std::string* _internal_mutable_game_mode();
  public:

  // optional string phase = 2;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  const std::string& phase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phase();
  PROTOBUF_NODISCARD std::string* release_phase();
  void set_allocated_phase(std::string* phase);
  private:
  const std::string& _internal_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phase(const std::string& value);
  std::string* _internal_mutable_phase();
  public:

  // optional int32 round = 3;
  bool has_round() const;
  private:
  bool _internal_has_round() const;
  public:
  void clear_round();
  int32_t round() const;
  void set_round(int32_t value);
  private:
  int32_t _internal_round() const;
  void _internal_set_round(int32_t value);
  public:

  // optional int32 score_ct = 4;
  bool has_score_ct() const;
  private:
  bool _internal_has_score_ct() const;
  public:
  void clear_score_ct();
  int32_t score_ct() const;
  void set_score_ct(int32_t value);
  private:
  int32_t _internal_score_ct() const;
  void _internal_set_score_ct(int32_t value);
  public:

  // optional int32 score_t = 5;
  bool has_score_t() const;
  private:
  bool _internal_has_score_t() const;
  public:
  void clear_score_t();
  int32_t score_t() const;
  void set_score_t(int32_t value);
  private:
  int32_t _internal_score_t() const;
  void _internal_set_score_t(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MLMatchState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phase_;
    int32_t round_;
    int32_t score_ct_;
    int32_t score_t_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLRoundState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLRoundState) */ {
 public:
  inline MLRoundState() : MLRoundState(nullptr) {}
  ~MLRoundState() override;
  explicit PROTOBUF_CONSTEXPR MLRoundState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLRoundState(const MLRoundState& from);
  MLRoundState(MLRoundState&& from) noexcept
    : MLRoundState() {
    *this = ::std::move(from);
  }

  inline MLRoundState& operator=(const MLRoundState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLRoundState& operator=(MLRoundState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLRoundState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLRoundState* internal_default_instance() {
    return reinterpret_cast<const MLRoundState*>(
               &_MLRoundState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MLRoundState& a, MLRoundState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLRoundState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLRoundState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLRoundState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLRoundState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLRoundState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLRoundState& from) {
    MLRoundState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLRoundState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLRoundState";
  }
  protected:
  explicit MLRoundState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseFieldNumber = 1,
    kBombStateFieldNumber = 3,
    kWinTeamFieldNumber = 2,
  };
  // optional string phase = 1;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  const std::string& phase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phase();
  PROTOBUF_NODISCARD std::string* release_phase();
  void set_allocated_phase(std::string* phase);
  private:
  const std::string& _internal_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phase(const std::string& value);
  std::string* _internal_mutable_phase();
  public:

  // optional string bomb_state = 3;
  bool has_bomb_state() const;
  private:
  bool _internal_has_bomb_state() const;
  public:
  void clear_bomb_state();
  const std::string& bomb_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bomb_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bomb_state();
  PROTOBUF_NODISCARD std::string* release_bomb_state();
  void set_allocated_bomb_state(std::string* bomb_state);
  private:
  const std::string& _internal_bomb_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bomb_state(const std::string& value);
  std::string* _internal_mutable_bomb_state();
  public:

  // optional .ETeam win_team = 2 [default = ET_Unknown];
  bool has_win_team() const;
  private:
  bool _internal_has_win_team() const;
  public:
  void clear_win_team();
  ::ETeam win_team() const;
  void set_win_team(::ETeam value);
  private:
  ::ETeam _internal_win_team() const;
  void _internal_set_win_team(::ETeam value);
  public:

  // @@protoc_insertion_point(class_scope:MLRoundState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bomb_state_;
    int win_team_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLWeaponState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLWeaponState) */ {
 public:
  inline MLWeaponState() : MLWeaponState(nullptr) {}
  ~MLWeaponState() override;
  explicit PROTOBUF_CONSTEXPR MLWeaponState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLWeaponState(const MLWeaponState& from);
  MLWeaponState(MLWeaponState&& from) noexcept
    : MLWeaponState() {
    *this = ::std::move(from);
  }

  inline MLWeaponState& operator=(const MLWeaponState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLWeaponState& operator=(MLWeaponState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLWeaponState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLWeaponState* internal_default_instance() {
    return reinterpret_cast<const MLWeaponState*>(
               &_MLWeaponState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MLWeaponState& a, MLWeaponState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLWeaponState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLWeaponState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLWeaponState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLWeaponState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLWeaponState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLWeaponState& from) {
    MLWeaponState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLWeaponState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLWeaponState";
  }
  protected:
  explicit MLWeaponState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStateFieldNumber = 7,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 3,
    kAmmoClipFieldNumber = 4,
    kAmmoClipMaxFieldNumber = 5,
    kAmmoReserveFieldNumber = 6,
    kRecoilIndexFieldNumber = 8,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string state = 7;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional int32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // optional .EWeaponType type = 3 [default = EWT_Knife];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::EWeaponType type() const;
  void set_type(::EWeaponType value);
  private:
  ::EWeaponType _internal_type() const;
  void _internal_set_type(::EWeaponType value);
  public:

  // optional int32 ammo_clip = 4;
  bool has_ammo_clip() const;
  private:
  bool _internal_has_ammo_clip() const;
  public:
  void clear_ammo_clip();
  int32_t ammo_clip() const;
  void set_ammo_clip(int32_t value);
  private:
  int32_t _internal_ammo_clip() const;
  void _internal_set_ammo_clip(int32_t value);
  public:

  // optional int32 ammo_clip_max = 5;
  bool has_ammo_clip_max() const;
  private:
  bool _internal_has_ammo_clip_max() const;
  public:
  void clear_ammo_clip_max();
  int32_t ammo_clip_max() const;
  void set_ammo_clip_max(int32_t value);
  private:
  int32_t _internal_ammo_clip_max() const;
  void _internal_set_ammo_clip_max(int32_t value);
  public:

  // optional int32 ammo_reserve = 6;
  bool has_ammo_reserve() const;
  private:
  bool _internal_has_ammo_reserve() const;
  public:
  void clear_ammo_reserve();
  int32_t ammo_reserve() const;
  void set_ammo_reserve(int32_t value);
  private:
  int32_t _internal_ammo_reserve() const;
  void _internal_set_ammo_reserve(int32_t value);
  public:

  // optional float recoil_index = 8;
  bool has_recoil_index() const;
  private:
  bool _internal_has_recoil_index() const;
  public:
  void clear_recoil_index();
  float recoil_index() const;
  void set_recoil_index(float value);
  private:
  float _internal_recoil_index() const;
  void _internal_set_recoil_index(float value);
  public:

  // @@protoc_insertion_point(class_scope:MLWeaponState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    int32_t index_;
    int type_;
    int32_t ammo_clip_;
    int32_t ammo_clip_max_;
    int32_t ammo_reserve_;
    float recoil_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLPlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLPlayerState) */ {
 public:
  inline MLPlayerState() : MLPlayerState(nullptr) {}
  ~MLPlayerState() override;
  explicit PROTOBUF_CONSTEXPR MLPlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLPlayerState(const MLPlayerState& from);
  MLPlayerState(MLPlayerState&& from) noexcept
    : MLPlayerState() {
    *this = ::std::move(from);
  }

  inline MLPlayerState& operator=(const MLPlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLPlayerState& operator=(MLPlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLPlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLPlayerState* internal_default_instance() {
    return reinterpret_cast<const MLPlayerState*>(
               &_MLPlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MLPlayerState& a, MLPlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLPlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLPlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLPlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLPlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLPlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLPlayerState& from) {
    MLPlayerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLPlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLPlayerState";
  }
  protected:
  explicit MLPlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponsFieldNumber = 20,
    kNameFieldNumber = 4,
    kClanFieldNumber = 5,
    kAbsposFieldNumber = 7,
    kEyeangleFieldNumber = 8,
    kEyeangleFwdFieldNumber = 9,
    kAccountIdFieldNumber = 1,
    kEntindexFieldNumber = 3,
    kTeamFieldNumber = 6,
    kHealthFieldNumber = 10,
    kArmorFieldNumber = 11,
    kFlashedFieldNumber = 12,
    kSmokedFieldNumber = 13,
    kMoneyFieldNumber = 14,
    kRoundKillsFieldNumber = 15,
    kRoundKillhsFieldNumber = 16,
    kBurningFieldNumber = 17,
    kHelmetFieldNumber = 18,
    kDefuseKitFieldNumber = 19,
    kPlayerSlotFieldNumber = 2,
  };
  // repeated .MLWeaponState weapons = 20;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;
  public:
  void clear_weapons();
  ::MLWeaponState* mutable_weapons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLWeaponState >*
      mutable_weapons();
  private:
  const ::MLWeaponState& _internal_weapons(int index) const;
  ::MLWeaponState* _internal_add_weapons();
  public:
  const ::MLWeaponState& weapons(int index) const;
  ::MLWeaponState* add_weapons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLWeaponState >&
      weapons() const;

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string clan = 5;
  bool has_clan() const;
  private:
  bool _internal_has_clan() const;
  public:
  void clear_clan();
  const std::string& clan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clan();
  PROTOBUF_NODISCARD std::string* release_clan();
  void set_allocated_clan(std::string* clan);
  private:
  const std::string& _internal_clan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clan(const std::string& value);
  std::string* _internal_mutable_clan();
  public:

  // optional .CMsgVector abspos = 7;
  bool has_abspos() const;
  private:
  bool _internal_has_abspos() const;
  public:
  void clear_abspos();
  const ::CMsgVector& abspos() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_abspos();
  ::CMsgVector* mutable_abspos();
  void set_allocated_abspos(::CMsgVector* abspos);
  private:
  const ::CMsgVector& _internal_abspos() const;
  ::CMsgVector* _internal_mutable_abspos();
  public:
  void unsafe_arena_set_allocated_abspos(
      ::CMsgVector* abspos);
  ::CMsgVector* unsafe_arena_release_abspos();

  // optional .CMsgQAngle eyeangle = 8;
  bool has_eyeangle() const;
  private:
  bool _internal_has_eyeangle() const;
  public:
  void clear_eyeangle();
  const ::CMsgQAngle& eyeangle() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_eyeangle();
  ::CMsgQAngle* mutable_eyeangle();
  void set_allocated_eyeangle(::CMsgQAngle* eyeangle);
  private:
  const ::CMsgQAngle& _internal_eyeangle() const;
  ::CMsgQAngle* _internal_mutable_eyeangle();
  public:
  void unsafe_arena_set_allocated_eyeangle(
      ::CMsgQAngle* eyeangle);
  ::CMsgQAngle* unsafe_arena_release_eyeangle();

  // optional .CMsgVector eyeangle_fwd = 9;
  bool has_eyeangle_fwd() const;
  private:
  bool _internal_has_eyeangle_fwd() const;
  public:
  void clear_eyeangle_fwd();
  const ::CMsgVector& eyeangle_fwd() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_eyeangle_fwd();
  ::CMsgVector* mutable_eyeangle_fwd();
  void set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd);
  private:
  const ::CMsgVector& _internal_eyeangle_fwd() const;
  ::CMsgVector* _internal_mutable_eyeangle_fwd();
  public:
  void unsafe_arena_set_allocated_eyeangle_fwd(
      ::CMsgVector* eyeangle_fwd);
  ::CMsgVector* unsafe_arena_release_eyeangle_fwd();

  // optional int32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  int32_t account_id() const;
  void set_account_id(int32_t value);
  private:
  int32_t _internal_account_id() const;
  void _internal_set_account_id(int32_t value);
  public:

  // optional int32 entindex = 3;
  bool has_entindex() const;
  private:
  bool _internal_has_entindex() const;
  public:
  void clear_entindex();
  int32_t entindex() const;
  void set_entindex(int32_t value);
  private:
  int32_t _internal_entindex() const;
  void _internal_set_entindex(int32_t value);
  public:

  // optional .ETeam team = 6 [default = ET_Unknown];
  bool has_team() const;
  private:
  bool _internal_has_team() const;
  public:
  void clear_team();
  ::ETeam team() const;
  void set_team(::ETeam value);
  private:
  ::ETeam _internal_team() const;
  void _internal_set_team(::ETeam value);
  public:

  // optional int32 health = 10;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  int32_t health() const;
  void set_health(int32_t value);
  private:
  int32_t _internal_health() const;
  void _internal_set_health(int32_t value);
  public:

  // optional int32 armor = 11;
  bool has_armor() const;
  private:
  bool _internal_has_armor() const;
  public:
  void clear_armor();
  int32_t armor() const;
  void set_armor(int32_t value);
  private:
  int32_t _internal_armor() const;
  void _internal_set_armor(int32_t value);
  public:

  // optional float flashed = 12;
  bool has_flashed() const;
  private:
  bool _internal_has_flashed() const;
  public:
  void clear_flashed();
  float flashed() const;
  void set_flashed(float value);
  private:
  float _internal_flashed() const;
  void _internal_set_flashed(float value);
  public:

  // optional float smoked = 13;
  bool has_smoked() const;
  private:
  bool _internal_has_smoked() const;
  public:
  void clear_smoked();
  float smoked() const;
  void set_smoked(float value);
  private:
  float _internal_smoked() const;
  void _internal_set_smoked(float value);
  public:

  // optional int32 money = 14;
  bool has_money() const;
  private:
  bool _internal_has_money() const;
  public:
  void clear_money();
  int32_t money() const;
  void set_money(int32_t value);
  private:
  int32_t _internal_money() const;
  void _internal_set_money(int32_t value);
  public:

  // optional int32 round_kills = 15;
  bool has_round_kills() const;
  private:
  bool _internal_has_round_kills() const;
  public:
  void clear_round_kills();
  int32_t round_kills() const;
  void set_round_kills(int32_t value);
  private:
  int32_t _internal_round_kills() const;
  void _internal_set_round_kills(int32_t value);
  public:

  // optional int32 round_killhs = 16;
  bool has_round_killhs() const;
  private:
  bool _internal_has_round_killhs() const;
  public:
  void clear_round_killhs();
  int32_t round_killhs() const;
  void set_round_killhs(int32_t value);
  private:
  int32_t _internal_round_killhs() const;
  void _internal_set_round_killhs(int32_t value);
  public:

  // optional float burning = 17;
  bool has_burning() const;
  private:
  bool _internal_has_burning() const;
  public:
  void clear_burning();
  float burning() const;
  void set_burning(float value);
  private:
  float _internal_burning() const;
  void _internal_set_burning(float value);
  public:

  // optional bool helmet = 18;
  bool has_helmet() const;
  private:
  bool _internal_has_helmet() const;
  public:
  void clear_helmet();
  bool helmet() const;
  void set_helmet(bool value);
  private:
  bool _internal_helmet() const;
  void _internal_set_helmet(bool value);
  public:

  // optional bool defuse_kit = 19;
  bool has_defuse_kit() const;
  private:
  bool _internal_has_defuse_kit() const;
  public:
  void clear_defuse_kit();
  bool defuse_kit() const;
  void set_defuse_kit(bool value);
  private:
  bool _internal_defuse_kit() const;
  void _internal_set_defuse_kit(bool value);
  public:

  // optional int32 player_slot = 2 [default = -1];
  bool has_player_slot() const;
  private:
  bool _internal_has_player_slot() const;
  public:
  void clear_player_slot();
  int32_t player_slot() const;
  void set_player_slot(int32_t value);
  private:
  int32_t _internal_player_slot() const;
  void _internal_set_player_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MLPlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLWeaponState > weapons_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clan_;
    ::CMsgVector* abspos_;
    ::CMsgQAngle* eyeangle_;
    ::CMsgVector* eyeangle_fwd_;
    int32_t account_id_;
    int32_t entindex_;
    int team_;
    int32_t health_;
    int32_t armor_;
    float flashed_;
    float smoked_;
    int32_t money_;
    int32_t round_kills_;
    int32_t round_killhs_;
    float burning_;
    bool helmet_;
    bool defuse_kit_;
    int32_t player_slot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLGameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLGameState) */ {
 public:
  inline MLGameState() : MLGameState(nullptr) {}
  ~MLGameState() override;
  explicit PROTOBUF_CONSTEXPR MLGameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLGameState(const MLGameState& from);
  MLGameState(MLGameState&& from) noexcept
    : MLGameState() {
    *this = ::std::move(from);
  }

  inline MLGameState& operator=(const MLGameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLGameState& operator=(MLGameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLGameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLGameState* internal_default_instance() {
    return reinterpret_cast<const MLGameState*>(
               &_MLGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MLGameState& a, MLGameState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLGameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLGameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLGameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLGameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLGameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLGameState& from) {
    MLGameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLGameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLGameState";
  }
  protected:
  explicit MLGameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kMatchFieldNumber = 1,
    kRoundFieldNumber = 2,
  };
  // repeated .MLPlayerState players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::MLPlayerState* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLPlayerState >*
      mutable_players();
  private:
  const ::MLPlayerState& _internal_players(int index) const;
  ::MLPlayerState* _internal_add_players();
  public:
  const ::MLPlayerState& players(int index) const;
  ::MLPlayerState* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLPlayerState >&
      players() const;

  // optional .MLMatchState match = 1;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::MLMatchState& match() const;
  PROTOBUF_NODISCARD ::MLMatchState* release_match();
  ::MLMatchState* mutable_match();
  void set_allocated_match(::MLMatchState* match);
  private:
  const ::MLMatchState& _internal_match() const;
  ::MLMatchState* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::MLMatchState* match);
  ::MLMatchState* unsafe_arena_release_match();

  // optional .MLRoundState round = 2;
  bool has_round() const;
  private:
  bool _internal_has_round() const;
  public:
  void clear_round();
  const ::MLRoundState& round() const;
  PROTOBUF_NODISCARD ::MLRoundState* release_round();
  ::MLRoundState* mutable_round();
  void set_allocated_round(::MLRoundState* round);
  private:
  const ::MLRoundState& _internal_round() const;
  ::MLRoundState* _internal_mutable_round();
  public:
  void unsafe_arena_set_allocated_round(
      ::MLRoundState* round);
  ::MLRoundState* unsafe_arena_release_round();

  // @@protoc_insertion_point(class_scope:MLGameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLPlayerState > players_;
    ::MLMatchState* match_;
    ::MLRoundState* round_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLDemoHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLDemoHeader) */ {
 public:
  inline MLDemoHeader() : MLDemoHeader(nullptr) {}
  ~MLDemoHeader() override;
  explicit PROTOBUF_CONSTEXPR MLDemoHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLDemoHeader(const MLDemoHeader& from);
  MLDemoHeader(MLDemoHeader&& from) noexcept
    : MLDemoHeader() {
    *this = ::std::move(from);
  }

  inline MLDemoHeader& operator=(const MLDemoHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDemoHeader& operator=(MLDemoHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDemoHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLDemoHeader* internal_default_instance() {
    return reinterpret_cast<const MLDemoHeader*>(
               &_MLDemoHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MLDemoHeader& a, MLDemoHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MLDemoHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDemoHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDemoHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLDemoHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLDemoHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLDemoHeader& from) {
    MLDemoHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLDemoHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLDemoHeader";
  }
  protected:
  explicit MLDemoHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
    kTickRateFieldNumber = 2,
    kVersionFieldNumber = 3,
    kSteamUniverseFieldNumber = 4,
  };
  // optional string map_name = 1;
  bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional int32 tick_rate = 2;
  bool has_tick_rate() const;
  private:
  bool _internal_has_tick_rate() const;
  public:
  void clear_tick_rate();
  int32_t tick_rate() const;
  void set_tick_rate(int32_t value);
  private:
  int32_t _internal_tick_rate() const;
  void _internal_set_tick_rate(int32_t value);
  public:

  // optional uint32 version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional uint32 steam_universe = 4;
  bool has_steam_universe() const;
  private:
  bool _internal_has_steam_universe() const;
  public:
  void clear_steam_universe();
  uint32_t steam_universe() const;
  void set_steam_universe(uint32_t value);
  private:
  uint32_t _internal_steam_universe() const;
  void _internal_set_steam_universe(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MLDemoHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
    int32_t tick_rate_;
    uint32_t version_;
    uint32_t steam_universe_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class MLTick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MLTick) */ {
 public:
  inline MLTick() : MLTick(nullptr) {}
  ~MLTick() override;
  explicit PROTOBUF_CONSTEXPR MLTick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLTick(const MLTick& from);
  MLTick(MLTick&& from) noexcept
    : MLTick() {
    *this = ::std::move(from);
  }

  inline MLTick& operator=(const MLTick& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLTick& operator=(MLTick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLTick& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLTick* internal_default_instance() {
    return reinterpret_cast<const MLTick*>(
               &_MLTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MLTick& a, MLTick& b) {
    a.Swap(&b);
  }
  inline void Swap(MLTick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLTick* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLTick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLTick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLTick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MLTick& from) {
    MLTick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLTick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MLTick";
  }
  protected:
  explicit MLTick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kStateFieldNumber = 2,
    kTickCountFieldNumber = 1,
  };
  // repeated .MLEvent events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::MLEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLEvent >*
      mutable_events();
  private:
  const ::MLEvent& _internal_events(int index) const;
  ::MLEvent* _internal_add_events();
  public:
  const ::MLEvent& events(int index) const;
  ::MLEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLEvent >&
      events() const;

  // optional .MLGameState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::MLGameState& state() const;
  PROTOBUF_NODISCARD ::MLGameState* release_state();
  ::MLGameState* mutable_state();
  void set_allocated_state(::MLGameState* state);
  private:
  const ::MLGameState& _internal_state() const;
  ::MLGameState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::MLGameState* state);
  ::MLGameState* unsafe_arena_release_state();

  // optional int32 tick_count = 1;
  bool has_tick_count() const;
  private:
  bool _internal_has_tick_count() const;
  public:
  void clear_tick_count();
  int32_t tick_count() const;
  void set_tick_count(int32_t value);
  private:
  int32_t _internal_tick_count() const;
  void _internal_set_tick_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MLTick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLEvent > events_;
    ::MLGameState* state_;
    int32_t tick_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// -------------------------------------------------------------------

class VacNetShot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VacNetShot) */ {
 public:
  inline VacNetShot() : VacNetShot(nullptr) {}
  ~VacNetShot() override;
  explicit PROTOBUF_CONSTEXPR VacNetShot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VacNetShot(const VacNetShot& from);
  VacNetShot(VacNetShot&& from) noexcept
    : VacNetShot() {
    *this = ::std::move(from);
  }

  inline VacNetShot& operator=(const VacNetShot& from) {
    CopyFrom(from);
    return *this;
  }
  inline VacNetShot& operator=(VacNetShot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VacNetShot& default_instance() {
    return *internal_default_instance();
  }
  static inline const VacNetShot* internal_default_instance() {
    return reinterpret_cast<const VacNetShot*>(
               &_VacNetShot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VacNetShot& a, VacNetShot& b) {
    a.Swap(&b);
  }
  inline void Swap(VacNetShot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VacNetShot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VacNetShot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VacNetShot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VacNetShot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VacNetShot& from) {
    VacNetShot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VacNetShot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VacNetShot";
  }
  protected:
  explicit VacNetShot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaYawWindowFieldNumber = 6,
    kDeltaPitchWindowFieldNumber = 7,
    kSteamidPlayerFieldNumber = 1,
    kRoundNumberFieldNumber = 2,
    kHitTypeFieldNumber = 3,
    kWeaponTypeFieldNumber = 4,
    kDistanceToHurtTargetFieldNumber = 5,
  };
  // repeated float delta_yaw_window = 6;
  int delta_yaw_window_size() const;
  private:
  int _internal_delta_yaw_window_size() const;
  public:
  void clear_delta_yaw_window();
  private:
  float _internal_delta_yaw_window(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_delta_yaw_window() const;
  void _internal_add_delta_yaw_window(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_delta_yaw_window();
  public:
  float delta_yaw_window(int index) const;
  void set_delta_yaw_window(int index, float value);
  void add_delta_yaw_window(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      delta_yaw_window() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_delta_yaw_window();

  // repeated float delta_pitch_window = 7;
  int delta_pitch_window_size() const;
  private:
  int _internal_delta_pitch_window_size() const;
  public:
  void clear_delta_pitch_window();
  private:
  float _internal_delta_pitch_window(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_delta_pitch_window() const;
  void _internal_add_delta_pitch_window(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_delta_pitch_window();
  public:
  float delta_pitch_window(int index) const;
  void set_delta_pitch_window(int index, float value);
  void add_delta_pitch_window(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      delta_pitch_window() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_delta_pitch_window();

  // optional fixed64 steamid_player = 1;
  bool has_steamid_player() const;
  private:
  bool _internal_has_steamid_player() const;
  public:
  void clear_steamid_player();
  uint64_t steamid_player() const;
  void set_steamid_player(uint64_t value);
  private:
  uint64_t _internal_steamid_player() const;
  void _internal_set_steamid_player(uint64_t value);
  public:

  // optional int32 round_number = 2;
  bool has_round_number() const;
  private:
  bool _internal_has_round_number() const;
  public:
  void clear_round_number();
  int32_t round_number() const;
  void set_round_number(int32_t value);
  private:
  int32_t _internal_round_number() const;
  void _internal_set_round_number(int32_t value);
  public:

  // optional int32 hit_type = 3;
  bool has_hit_type() const;
  private:
  bool _internal_has_hit_type() const;
  public:
  void clear_hit_type();
  int32_t hit_type() const;
  void set_hit_type(int32_t value);
  private:
  int32_t _internal_hit_type() const;
  void _internal_set_hit_type(int32_t value);
  public:

  // optional int32 weapon_type = 4;
  bool has_weapon_type() const;
  private:
  bool _internal_has_weapon_type() const;
  public:
  void clear_weapon_type();
  int32_t weapon_type() const;
  void set_weapon_type(int32_t value);
  private:
  int32_t _internal_weapon_type() const;
  void _internal_set_weapon_type(int32_t value);
  public:

  // optional float distance_to_hurt_target = 5;
  bool has_distance_to_hurt_target() const;
  private:
  bool _internal_has_distance_to_hurt_target() const;
  public:
  void clear_distance_to_hurt_target();
  float distance_to_hurt_target() const;
  void set_distance_to_hurt_target(float value);
  private:
  float _internal_distance_to_hurt_target() const;
  void _internal_set_distance_to_hurt_target(float value);
  public:

  // @@protoc_insertion_point(class_scope:VacNetShot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > delta_yaw_window_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > delta_pitch_window_;
    uint64_t steamid_player_;
    int32_t round_number_;
    int32_t hit_type_;
    int32_t weapon_type_;
    float distance_to_hurt_target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MLDict

// optional string key = 1;
inline bool MLDict::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLDict::has_key() const {
  return _internal_has_key();
}
inline void MLDict::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDict::key() const {
  // @@protoc_insertion_point(field_get:MLDict.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLDict::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDict.key)
}
inline std::string* MLDict::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:MLDict.key)
  return _s;
}
inline const std::string& MLDict::_internal_key() const {
  return _impl_.key_.Get();
}
inline void MLDict::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDict::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* MLDict::release_key() {
  // @@protoc_insertion_point(field_release:MLDict.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLDict::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDict.key)
}

// optional string val_string = 2;
inline bool MLDict::_internal_has_val_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLDict::has_val_string() const {
  return _internal_has_val_string();
}
inline void MLDict::clear_val_string() {
  _impl_.val_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLDict::val_string() const {
  // @@protoc_insertion_point(field_get:MLDict.val_string)
  return _internal_val_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLDict::set_val_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.val_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDict.val_string)
}
inline std::string* MLDict::mutable_val_string() {
  std::string* _s = _internal_mutable_val_string();
  // @@protoc_insertion_point(field_mutable:MLDict.val_string)
  return _s;
}
inline const std::string& MLDict::_internal_val_string() const {
  return _impl_.val_string_.Get();
}
inline void MLDict::_internal_set_val_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_string_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDict::_internal_mutable_val_string() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.val_string_.Mutable(GetArenaForAllocation());
}
inline std::string* MLDict::release_val_string() {
  // @@protoc_insertion_point(field_release:MLDict.val_string)
  if (!_internal_has_val_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.val_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_string_.IsDefault()) {
    _impl_.val_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLDict::set_allocated_val_string(std::string* val_string) {
  if (val_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.val_string_.SetAllocated(val_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_string_.IsDefault()) {
    _impl_.val_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDict.val_string)
}

// optional int32 val_int = 3;
inline bool MLDict::_internal_has_val_int() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MLDict::has_val_int() const {
  return _internal_has_val_int();
}
inline void MLDict::clear_val_int() {
  _impl_.val_int_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t MLDict::_internal_val_int() const {
  return _impl_.val_int_;
}
inline int32_t MLDict::val_int() const {
  // @@protoc_insertion_point(field_get:MLDict.val_int)
  return _internal_val_int();
}
inline void MLDict::_internal_set_val_int(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.val_int_ = value;
}
inline void MLDict::set_val_int(int32_t value) {
  _internal_set_val_int(value);
  // @@protoc_insertion_point(field_set:MLDict.val_int)
}

// optional float val_float = 4;
inline bool MLDict::_internal_has_val_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MLDict::has_val_float() const {
  return _internal_has_val_float();
}
inline void MLDict::clear_val_float() {
  _impl_.val_float_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MLDict::_internal_val_float() const {
  return _impl_.val_float_;
}
inline float MLDict::val_float() const {
  // @@protoc_insertion_point(field_get:MLDict.val_float)
  return _internal_val_float();
}
inline void MLDict::_internal_set_val_float(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.val_float_ = value;
}
inline void MLDict::set_val_float(float value) {
  _internal_set_val_float(value);
  // @@protoc_insertion_point(field_set:MLDict.val_float)
}

// -------------------------------------------------------------------

// MLEvent

// optional string event_name = 1;
inline bool MLEvent::_internal_has_event_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLEvent::has_event_name() const {
  return _internal_has_event_name();
}
inline void MLEvent::clear_event_name() {
  _impl_.event_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLEvent::event_name() const {
  // @@protoc_insertion_point(field_get:MLEvent.event_name)
  return _internal_event_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLEvent::set_event_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.event_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLEvent.event_name)
}
inline std::string* MLEvent::mutable_event_name() {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:MLEvent.event_name)
  return _s;
}
inline const std::string& MLEvent::_internal_event_name() const {
  return _impl_.event_name_.Get();
}
inline void MLEvent::_internal_set_event_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLEvent::_internal_mutable_event_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.event_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MLEvent::release_event_name() {
  // @@protoc_insertion_point(field_release:MLEvent.event_name)
  if (!_internal_has_event_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.event_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_name_.IsDefault()) {
    _impl_.event_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLEvent::set_allocated_event_name(std::string* event_name) {
  if (event_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.event_name_.SetAllocated(event_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_name_.IsDefault()) {
    _impl_.event_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLEvent.event_name)
}

// repeated .MLDict data = 2;
inline int MLEvent::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int MLEvent::data_size() const {
  return _internal_data_size();
}
inline void MLEvent::clear_data() {
  _impl_.data_.Clear();
}
inline ::MLDict* MLEvent::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:MLEvent.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLDict >*
MLEvent::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MLEvent.data)
  return &_impl_.data_;
}
inline const ::MLDict& MLEvent::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::MLDict& MLEvent::data(int index) const {
  // @@protoc_insertion_point(field_get:MLEvent.data)
  return _internal_data(index);
}
inline ::MLDict* MLEvent::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::MLDict* MLEvent::add_data() {
  ::MLDict* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:MLEvent.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLDict >&
MLEvent::data() const {
  // @@protoc_insertion_point(field_list:MLEvent.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// MLMatchState

// optional string game_mode = 1;
inline bool MLMatchState::_internal_has_game_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLMatchState::has_game_mode() const {
  return _internal_has_game_mode();
}
inline void MLMatchState::clear_game_mode() {
  _impl_.game_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLMatchState::game_mode() const {
  // @@protoc_insertion_point(field_get:MLMatchState.game_mode)
  return _internal_game_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLMatchState::set_game_mode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.game_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLMatchState.game_mode)
}
inline std::string* MLMatchState::mutable_game_mode() {
  std::string* _s = _internal_mutable_game_mode();
  // @@protoc_insertion_point(field_mutable:MLMatchState.game_mode)
  return _s;
}
inline const std::string& MLMatchState::_internal_game_mode() const {
  return _impl_.game_mode_.Get();
}
inline void MLMatchState::_internal_set_game_mode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* MLMatchState::_internal_mutable_game_mode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.game_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* MLMatchState::release_game_mode() {
  // @@protoc_insertion_point(field_release:MLMatchState.game_mode)
  if (!_internal_has_game_mode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.game_mode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_mode_.IsDefault()) {
    _impl_.game_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLMatchState::set_allocated_game_mode(std::string* game_mode) {
  if (game_mode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.game_mode_.SetAllocated(game_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_mode_.IsDefault()) {
    _impl_.game_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.game_mode)
}

// optional string phase = 2;
inline bool MLMatchState::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLMatchState::has_phase() const {
  return _internal_has_phase();
}
inline void MLMatchState::clear_phase() {
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLMatchState::phase() const {
  // @@protoc_insertion_point(field_get:MLMatchState.phase)
  return _internal_phase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLMatchState::set_phase(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.phase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLMatchState.phase)
}
inline std::string* MLMatchState::mutable_phase() {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLMatchState.phase)
  return _s;
}
inline const std::string& MLMatchState::_internal_phase() const {
  return _impl_.phase_.Get();
}
inline void MLMatchState::_internal_set_phase(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_.Set(value, GetArenaForAllocation());
}
inline std::string* MLMatchState::_internal_mutable_phase() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.phase_.Mutable(GetArenaForAllocation());
}
inline std::string* MLMatchState::release_phase() {
  // @@protoc_insertion_point(field_release:MLMatchState.phase)
  if (!_internal_has_phase()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.phase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLMatchState::set_allocated_phase(std::string* phase) {
  if (phase != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phase_.SetAllocated(phase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.phase)
}

// optional int32 round = 3;
inline bool MLMatchState::_internal_has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MLMatchState::has_round() const {
  return _internal_has_round();
}
inline void MLMatchState::clear_round() {
  _impl_.round_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t MLMatchState::_internal_round() const {
  return _impl_.round_;
}
inline int32_t MLMatchState::round() const {
  // @@protoc_insertion_point(field_get:MLMatchState.round)
  return _internal_round();
}
inline void MLMatchState::_internal_set_round(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.round_ = value;
}
inline void MLMatchState::set_round(int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:MLMatchState.round)
}

// optional int32 score_ct = 4;
inline bool MLMatchState::_internal_has_score_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MLMatchState::has_score_ct() const {
  return _internal_has_score_ct();
}
inline void MLMatchState::clear_score_ct() {
  _impl_.score_ct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t MLMatchState::_internal_score_ct() const {
  return _impl_.score_ct_;
}
inline int32_t MLMatchState::score_ct() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_ct)
  return _internal_score_ct();
}
inline void MLMatchState::_internal_set_score_ct(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.score_ct_ = value;
}
inline void MLMatchState::set_score_ct(int32_t value) {
  _internal_set_score_ct(value);
  // @@protoc_insertion_point(field_set:MLMatchState.score_ct)
}

// optional int32 score_t = 5;
inline bool MLMatchState::_internal_has_score_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MLMatchState::has_score_t() const {
  return _internal_has_score_t();
}
inline void MLMatchState::clear_score_t() {
  _impl_.score_t_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t MLMatchState::_internal_score_t() const {
  return _impl_.score_t_;
}
inline int32_t MLMatchState::score_t() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_t)
  return _internal_score_t();
}
inline void MLMatchState::_internal_set_score_t(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.score_t_ = value;
}
inline void MLMatchState::set_score_t(int32_t value) {
  _internal_set_score_t(value);
  // @@protoc_insertion_point(field_set:MLMatchState.score_t)
}

// -------------------------------------------------------------------

// MLRoundState

// optional string phase = 1;
inline bool MLRoundState::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLRoundState::has_phase() const {
  return _internal_has_phase();
}
inline void MLRoundState::clear_phase() {
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLRoundState::phase() const {
  // @@protoc_insertion_point(field_get:MLRoundState.phase)
  return _internal_phase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLRoundState::set_phase(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.phase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLRoundState.phase)
}
inline std::string* MLRoundState::mutable_phase() {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLRoundState.phase)
  return _s;
}
inline const std::string& MLRoundState::_internal_phase() const {
  return _impl_.phase_.Get();
}
inline void MLRoundState::_internal_set_phase(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(value, GetArenaForAllocation());
}
inline std::string* MLRoundState::_internal_mutable_phase() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phase_.Mutable(GetArenaForAllocation());
}
inline std::string* MLRoundState::release_phase() {
  // @@protoc_insertion_point(field_release:MLRoundState.phase)
  if (!_internal_has_phase()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.phase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLRoundState::set_allocated_phase(std::string* phase) {
  if (phase != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phase_.SetAllocated(phase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.phase)
}

// optional .ETeam win_team = 2 [default = ET_Unknown];
inline bool MLRoundState::_internal_has_win_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MLRoundState::has_win_team() const {
  return _internal_has_win_team();
}
inline void MLRoundState::clear_win_team() {
  _impl_.win_team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ETeam MLRoundState::_internal_win_team() const {
  return static_cast< ::ETeam >(_impl_.win_team_);
}
inline ::ETeam MLRoundState::win_team() const {
  // @@protoc_insertion_point(field_get:MLRoundState.win_team)
  return _internal_win_team();
}
inline void MLRoundState::_internal_set_win_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.win_team_ = value;
}
inline void MLRoundState::set_win_team(::ETeam value) {
  _internal_set_win_team(value);
  // @@protoc_insertion_point(field_set:MLRoundState.win_team)
}

// optional string bomb_state = 3;
inline bool MLRoundState::_internal_has_bomb_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLRoundState::has_bomb_state() const {
  return _internal_has_bomb_state();
}
inline void MLRoundState::clear_bomb_state() {
  _impl_.bomb_state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLRoundState::bomb_state() const {
  // @@protoc_insertion_point(field_get:MLRoundState.bomb_state)
  return _internal_bomb_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLRoundState::set_bomb_state(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.bomb_state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLRoundState.bomb_state)
}
inline std::string* MLRoundState::mutable_bomb_state() {
  std::string* _s = _internal_mutable_bomb_state();
  // @@protoc_insertion_point(field_mutable:MLRoundState.bomb_state)
  return _s;
}
inline const std::string& MLRoundState::_internal_bomb_state() const {
  return _impl_.bomb_state_.Get();
}
inline void MLRoundState::_internal_set_bomb_state(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bomb_state_.Set(value, GetArenaForAllocation());
}
inline std::string* MLRoundState::_internal_mutable_bomb_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bomb_state_.Mutable(GetArenaForAllocation());
}
inline std::string* MLRoundState::release_bomb_state() {
  // @@protoc_insertion_point(field_release:MLRoundState.bomb_state)
  if (!_internal_has_bomb_state()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.bomb_state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bomb_state_.IsDefault()) {
    _impl_.bomb_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLRoundState::set_allocated_bomb_state(std::string* bomb_state) {
  if (bomb_state != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bomb_state_.SetAllocated(bomb_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bomb_state_.IsDefault()) {
    _impl_.bomb_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.bomb_state)
}

// -------------------------------------------------------------------

// MLWeaponState

// optional int32 index = 1;
inline bool MLWeaponState::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MLWeaponState::has_index() const {
  return _internal_has_index();
}
inline void MLWeaponState::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t MLWeaponState::_internal_index() const {
  return _impl_.index_;
}
inline int32_t MLWeaponState::index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.index)
  return _internal_index();
}
inline void MLWeaponState::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}
inline void MLWeaponState::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.index)
}

// optional string name = 2;
inline bool MLWeaponState::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLWeaponState::has_name() const {
  return _internal_has_name();
}
inline void MLWeaponState::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLWeaponState::name() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLWeaponState::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLWeaponState.name)
}
inline std::string* MLWeaponState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.name)
  return _s;
}
inline const std::string& MLWeaponState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MLWeaponState::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLWeaponState::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MLWeaponState::release_name() {
  // @@protoc_insertion_point(field_release:MLWeaponState.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLWeaponState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.name)
}

// optional .EWeaponType type = 3 [default = EWT_Knife];
inline bool MLWeaponState::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MLWeaponState::has_type() const {
  return _internal_has_type();
}
inline void MLWeaponState::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::EWeaponType MLWeaponState::_internal_type() const {
  return static_cast< ::EWeaponType >(_impl_.type_);
}
inline ::EWeaponType MLWeaponState::type() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.type)
  return _internal_type();
}
inline void MLWeaponState::_internal_set_type(::EWeaponType value) {
  assert(::EWeaponType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void MLWeaponState::set_type(::EWeaponType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.type)
}

// optional int32 ammo_clip = 4;
inline bool MLWeaponState::_internal_has_ammo_clip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MLWeaponState::has_ammo_clip() const {
  return _internal_has_ammo_clip();
}
inline void MLWeaponState::clear_ammo_clip() {
  _impl_.ammo_clip_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t MLWeaponState::_internal_ammo_clip() const {
  return _impl_.ammo_clip_;
}
inline int32_t MLWeaponState::ammo_clip() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip)
  return _internal_ammo_clip();
}
inline void MLWeaponState::_internal_set_ammo_clip(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ammo_clip_ = value;
}
inline void MLWeaponState::set_ammo_clip(int32_t value) {
  _internal_set_ammo_clip(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip)
}

// optional int32 ammo_clip_max = 5;
inline bool MLWeaponState::_internal_has_ammo_clip_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MLWeaponState::has_ammo_clip_max() const {
  return _internal_has_ammo_clip_max();
}
inline void MLWeaponState::clear_ammo_clip_max() {
  _impl_.ammo_clip_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t MLWeaponState::_internal_ammo_clip_max() const {
  return _impl_.ammo_clip_max_;
}
inline int32_t MLWeaponState::ammo_clip_max() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip_max)
  return _internal_ammo_clip_max();
}
inline void MLWeaponState::_internal_set_ammo_clip_max(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ammo_clip_max_ = value;
}
inline void MLWeaponState::set_ammo_clip_max(int32_t value) {
  _internal_set_ammo_clip_max(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip_max)
}

// optional int32 ammo_reserve = 6;
inline bool MLWeaponState::_internal_has_ammo_reserve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MLWeaponState::has_ammo_reserve() const {
  return _internal_has_ammo_reserve();
}
inline void MLWeaponState::clear_ammo_reserve() {
  _impl_.ammo_reserve_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t MLWeaponState::_internal_ammo_reserve() const {
  return _impl_.ammo_reserve_;
}
inline int32_t MLWeaponState::ammo_reserve() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_reserve)
  return _internal_ammo_reserve();
}
inline void MLWeaponState::_internal_set_ammo_reserve(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ammo_reserve_ = value;
}
inline void MLWeaponState::set_ammo_reserve(int32_t value) {
  _internal_set_ammo_reserve(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_reserve)
}

// optional string state = 7;
inline bool MLWeaponState::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLWeaponState::has_state() const {
  return _internal_has_state();
}
inline void MLWeaponState::clear_state() {
  _impl_.state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLWeaponState::state() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLWeaponState::set_state(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLWeaponState.state)
}
inline std::string* MLWeaponState::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.state)
  return _s;
}
inline const std::string& MLWeaponState::_internal_state() const {
  return _impl_.state_.Get();
}
inline void MLWeaponState::_internal_set_state(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* MLWeaponState::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* MLWeaponState::release_state() {
  // @@protoc_insertion_point(field_release:MLWeaponState.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLWeaponState::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.state)
}

// optional float recoil_index = 8;
inline bool MLWeaponState::_internal_has_recoil_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MLWeaponState::has_recoil_index() const {
  return _internal_has_recoil_index();
}
inline void MLWeaponState::clear_recoil_index() {
  _impl_.recoil_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MLWeaponState::_internal_recoil_index() const {
  return _impl_.recoil_index_;
}
inline float MLWeaponState::recoil_index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.recoil_index)
  return _internal_recoil_index();
}
inline void MLWeaponState::_internal_set_recoil_index(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.recoil_index_ = value;
}
inline void MLWeaponState::set_recoil_index(float value) {
  _internal_set_recoil_index(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.recoil_index)
}

// -------------------------------------------------------------------

// MLPlayerState

// optional int32 account_id = 1;
inline bool MLPlayerState::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MLPlayerState::has_account_id() const {
  return _internal_has_account_id();
}
inline void MLPlayerState::clear_account_id() {
  _impl_.account_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t MLPlayerState::_internal_account_id() const {
  return _impl_.account_id_;
}
inline int32_t MLPlayerState::account_id() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.account_id)
  return _internal_account_id();
}
inline void MLPlayerState::_internal_set_account_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.account_id_ = value;
}
inline void MLPlayerState::set_account_id(int32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.account_id)
}

// optional int32 player_slot = 2 [default = -1];
inline bool MLPlayerState::_internal_has_player_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MLPlayerState::has_player_slot() const {
  return _internal_has_player_slot();
}
inline void MLPlayerState::clear_player_slot() {
  _impl_.player_slot_ = -1;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t MLPlayerState::_internal_player_slot() const {
  return _impl_.player_slot_;
}
inline int32_t MLPlayerState::player_slot() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.player_slot)
  return _internal_player_slot();
}
inline void MLPlayerState::_internal_set_player_slot(int32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.player_slot_ = value;
}
inline void MLPlayerState::set_player_slot(int32_t value) {
  _internal_set_player_slot(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.player_slot)
}

// optional int32 entindex = 3;
inline bool MLPlayerState::_internal_has_entindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MLPlayerState::has_entindex() const {
  return _internal_has_entindex();
}
inline void MLPlayerState::clear_entindex() {
  _impl_.entindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t MLPlayerState::_internal_entindex() const {
  return _impl_.entindex_;
}
inline int32_t MLPlayerState::entindex() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.entindex)
  return _internal_entindex();
}
inline void MLPlayerState::_internal_set_entindex(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.entindex_ = value;
}
inline void MLPlayerState::set_entindex(int32_t value) {
  _internal_set_entindex(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.entindex)
}

// optional string name = 4;
inline bool MLPlayerState::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLPlayerState::has_name() const {
  return _internal_has_name();
}
inline void MLPlayerState::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLPlayerState::name() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLPlayerState::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLPlayerState.name)
}
inline std::string* MLPlayerState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.name)
  return _s;
}
inline const std::string& MLPlayerState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MLPlayerState::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLPlayerState::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MLPlayerState::release_name() {
  // @@protoc_insertion_point(field_release:MLPlayerState.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLPlayerState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.name)
}

// optional string clan = 5;
inline bool MLPlayerState::_internal_has_clan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLPlayerState::has_clan() const {
  return _internal_has_clan();
}
inline void MLPlayerState::clear_clan() {
  _impl_.clan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLPlayerState::clan() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.clan)
  return _internal_clan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLPlayerState::set_clan(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.clan_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLPlayerState.clan)
}
inline std::string* MLPlayerState::mutable_clan() {
  std::string* _s = _internal_mutable_clan();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.clan)
  return _s;
}
inline const std::string& MLPlayerState::_internal_clan() const {
  return _impl_.clan_.Get();
}
inline void MLPlayerState::_internal_set_clan(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clan_.Set(value, GetArenaForAllocation());
}
inline std::string* MLPlayerState::_internal_mutable_clan() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.clan_.Mutable(GetArenaForAllocation());
}
inline std::string* MLPlayerState::release_clan() {
  // @@protoc_insertion_point(field_release:MLPlayerState.clan)
  if (!_internal_has_clan()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.clan_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clan_.IsDefault()) {
    _impl_.clan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLPlayerState::set_allocated_clan(std::string* clan) {
  if (clan != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.clan_.SetAllocated(clan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clan_.IsDefault()) {
    _impl_.clan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.clan)
}

// optional .ETeam team = 6 [default = ET_Unknown];
inline bool MLPlayerState::_internal_has_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MLPlayerState::has_team() const {
  return _internal_has_team();
}
inline void MLPlayerState::clear_team() {
  _impl_.team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ETeam MLPlayerState::_internal_team() const {
  return static_cast< ::ETeam >(_impl_.team_);
}
inline ::ETeam MLPlayerState::team() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.team)
  return _internal_team();
}
inline void MLPlayerState::_internal_set_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.team_ = value;
}
inline void MLPlayerState::set_team(::ETeam value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.team)
}

// optional .CMsgVector abspos = 7;
inline bool MLPlayerState::_internal_has_abspos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.abspos_ != nullptr);
  return value;
}
inline bool MLPlayerState::has_abspos() const {
  return _internal_has_abspos();
}
inline const ::CMsgVector& MLPlayerState::_internal_abspos() const {
  const ::CMsgVector* p = _impl_.abspos_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::abspos() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.abspos)
  return _internal_abspos();
}
inline void MLPlayerState::unsafe_arena_set_allocated_abspos(
    ::CMsgVector* abspos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.abspos_);
  }
  _impl_.abspos_ = abspos;
  if (abspos) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.abspos)
}
inline ::CMsgVector* MLPlayerState::release_abspos() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* MLPlayerState::unsafe_arena_release_abspos() {
  // @@protoc_insertion_point(field_release:MLPlayerState.abspos)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
  return temp;
}
inline ::CMsgVector* MLPlayerState::_internal_mutable_abspos() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.abspos_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.abspos_ = p;
  }
  return _impl_.abspos_;
}
inline ::CMsgVector* MLPlayerState::mutable_abspos() {
  ::CMsgVector* _msg = _internal_mutable_abspos();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.abspos)
  return _msg;
}
inline void MLPlayerState::set_allocated_abspos(::CMsgVector* abspos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.abspos_);
  }
  if (abspos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abspos));
    if (message_arena != submessage_arena) {
      abspos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abspos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.abspos_ = abspos;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.abspos)
}

// optional .CMsgQAngle eyeangle = 8;
inline bool MLPlayerState::_internal_has_eyeangle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_ != nullptr);
  return value;
}
inline bool MLPlayerState::has_eyeangle() const {
  return _internal_has_eyeangle();
}
inline const ::CMsgQAngle& MLPlayerState::_internal_eyeangle() const {
  const ::CMsgQAngle* p = _impl_.eyeangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(
      ::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& MLPlayerState::eyeangle() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle)
  return _internal_eyeangle();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle(
    ::CMsgQAngle* eyeangle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eyeangle_);
  }
  _impl_.eyeangle_ = eyeangle;
  if (eyeangle) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle)
}
inline ::CMsgQAngle* MLPlayerState::release_eyeangle() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* temp = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgQAngle* MLPlayerState::unsafe_arena_release_eyeangle() {
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* temp = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* MLPlayerState::_internal_mutable_eyeangle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.eyeangle_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.eyeangle_ = p;
  }
  return _impl_.eyeangle_;
}
inline ::CMsgQAngle* MLPlayerState::mutable_eyeangle() {
  ::CMsgQAngle* _msg = _internal_mutable_eyeangle();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle(::CMsgQAngle* eyeangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eyeangle_);
  }
  if (eyeangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eyeangle));
    if (message_arena != submessage_arena) {
      eyeangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eyeangle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.eyeangle_ = eyeangle;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle)
}

// optional .CMsgVector eyeangle_fwd = 9;
inline bool MLPlayerState::_internal_has_eyeangle_fwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_fwd_ != nullptr);
  return value;
}
inline bool MLPlayerState::has_eyeangle_fwd() const {
  return _internal_has_eyeangle_fwd();
}
inline const ::CMsgVector& MLPlayerState::_internal_eyeangle_fwd() const {
  const ::CMsgVector* p = _impl_.eyeangle_fwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(
      ::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::eyeangle_fwd() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle_fwd)
  return _internal_eyeangle_fwd();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle_fwd(
    ::CMsgVector* eyeangle_fwd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eyeangle_fwd_);
  }
  _impl_.eyeangle_fwd_ = eyeangle_fwd;
  if (eyeangle_fwd) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle_fwd)
}
inline ::CMsgVector* MLPlayerState::release_eyeangle_fwd() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* temp = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgVector* MLPlayerState::unsafe_arena_release_eyeangle_fwd() {
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle_fwd)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* temp = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
  return temp;
}
inline ::CMsgVector* MLPlayerState::_internal_mutable_eyeangle_fwd() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.eyeangle_fwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.eyeangle_fwd_ = p;
  }
  return _impl_.eyeangle_fwd_;
}
inline ::CMsgVector* MLPlayerState::mutable_eyeangle_fwd() {
  ::CMsgVector* _msg = _internal_mutable_eyeangle_fwd();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle_fwd)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eyeangle_fwd_);
  }
  if (eyeangle_fwd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eyeangle_fwd));
    if (message_arena != submessage_arena) {
      eyeangle_fwd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eyeangle_fwd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.eyeangle_fwd_ = eyeangle_fwd;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle_fwd)
}

// optional int32 health = 10;
inline bool MLPlayerState::_internal_has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MLPlayerState::has_health() const {
  return _internal_has_health();
}
inline void MLPlayerState::clear_health() {
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t MLPlayerState::_internal_health() const {
  return _impl_.health_;
}
inline int32_t MLPlayerState::health() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.health)
  return _internal_health();
}
inline void MLPlayerState::_internal_set_health(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.health_ = value;
}
inline void MLPlayerState::set_health(int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.health)
}

// optional int32 armor = 11;
inline bool MLPlayerState::_internal_has_armor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MLPlayerState::has_armor() const {
  return _internal_has_armor();
}
inline void MLPlayerState::clear_armor() {
  _impl_.armor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t MLPlayerState::_internal_armor() const {
  return _impl_.armor_;
}
inline int32_t MLPlayerState::armor() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.armor)
  return _internal_armor();
}
inline void MLPlayerState::_internal_set_armor(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.armor_ = value;
}
inline void MLPlayerState::set_armor(int32_t value) {
  _internal_set_armor(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.armor)
}

// optional float flashed = 12;
inline bool MLPlayerState::_internal_has_flashed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MLPlayerState::has_flashed() const {
  return _internal_has_flashed();
}
inline void MLPlayerState::clear_flashed() {
  _impl_.flashed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float MLPlayerState::_internal_flashed() const {
  return _impl_.flashed_;
}
inline float MLPlayerState::flashed() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.flashed)
  return _internal_flashed();
}
inline void MLPlayerState::_internal_set_flashed(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.flashed_ = value;
}
inline void MLPlayerState::set_flashed(float value) {
  _internal_set_flashed(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.flashed)
}

// optional float smoked = 13;
inline bool MLPlayerState::_internal_has_smoked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MLPlayerState::has_smoked() const {
  return _internal_has_smoked();
}
inline void MLPlayerState::clear_smoked() {
  _impl_.smoked_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float MLPlayerState::_internal_smoked() const {
  return _impl_.smoked_;
}
inline float MLPlayerState::smoked() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.smoked)
  return _internal_smoked();
}
inline void MLPlayerState::_internal_set_smoked(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.smoked_ = value;
}
inline void MLPlayerState::set_smoked(float value) {
  _internal_set_smoked(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.smoked)
}

// optional int32 money = 14;
inline bool MLPlayerState::_internal_has_money() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MLPlayerState::has_money() const {
  return _internal_has_money();
}
inline void MLPlayerState::clear_money() {
  _impl_.money_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t MLPlayerState::_internal_money() const {
  return _impl_.money_;
}
inline int32_t MLPlayerState::money() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.money)
  return _internal_money();
}
inline void MLPlayerState::_internal_set_money(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.money_ = value;
}
inline void MLPlayerState::set_money(int32_t value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.money)
}

// optional int32 round_kills = 15;
inline bool MLPlayerState::_internal_has_round_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MLPlayerState::has_round_kills() const {
  return _internal_has_round_kills();
}
inline void MLPlayerState::clear_round_kills() {
  _impl_.round_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t MLPlayerState::_internal_round_kills() const {
  return _impl_.round_kills_;
}
inline int32_t MLPlayerState::round_kills() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_kills)
  return _internal_round_kills();
}
inline void MLPlayerState::_internal_set_round_kills(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.round_kills_ = value;
}
inline void MLPlayerState::set_round_kills(int32_t value) {
  _internal_set_round_kills(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.round_kills)
}

// optional int32 round_killhs = 16;
inline bool MLPlayerState::_internal_has_round_killhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MLPlayerState::has_round_killhs() const {
  return _internal_has_round_killhs();
}
inline void MLPlayerState::clear_round_killhs() {
  _impl_.round_killhs_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t MLPlayerState::_internal_round_killhs() const {
  return _impl_.round_killhs_;
}
inline int32_t MLPlayerState::round_killhs() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_killhs)
  return _internal_round_killhs();
}
inline void MLPlayerState::_internal_set_round_killhs(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.round_killhs_ = value;
}
inline void MLPlayerState::set_round_killhs(int32_t value) {
  _internal_set_round_killhs(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.round_killhs)
}

// optional float burning = 17;
inline bool MLPlayerState::_internal_has_burning() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MLPlayerState::has_burning() const {
  return _internal_has_burning();
}
inline void MLPlayerState::clear_burning() {
  _impl_.burning_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float MLPlayerState::_internal_burning() const {
  return _impl_.burning_;
}
inline float MLPlayerState::burning() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.burning)
  return _internal_burning();
}
inline void MLPlayerState::_internal_set_burning(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.burning_ = value;
}
inline void MLPlayerState::set_burning(float value) {
  _internal_set_burning(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.burning)
}

// optional bool helmet = 18;
inline bool MLPlayerState::_internal_has_helmet() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MLPlayerState::has_helmet() const {
  return _internal_has_helmet();
}
inline void MLPlayerState::clear_helmet() {
  _impl_.helmet_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool MLPlayerState::_internal_helmet() const {
  return _impl_.helmet_;
}
inline bool MLPlayerState::helmet() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.helmet)
  return _internal_helmet();
}
inline void MLPlayerState::_internal_set_helmet(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.helmet_ = value;
}
inline void MLPlayerState::set_helmet(bool value) {
  _internal_set_helmet(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.helmet)
}

// optional bool defuse_kit = 19;
inline bool MLPlayerState::_internal_has_defuse_kit() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MLPlayerState::has_defuse_kit() const {
  return _internal_has_defuse_kit();
}
inline void MLPlayerState::clear_defuse_kit() {
  _impl_.defuse_kit_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool MLPlayerState::_internal_defuse_kit() const {
  return _impl_.defuse_kit_;
}
inline bool MLPlayerState::defuse_kit() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.defuse_kit)
  return _internal_defuse_kit();
}
inline void MLPlayerState::_internal_set_defuse_kit(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.defuse_kit_ = value;
}
inline void MLPlayerState::set_defuse_kit(bool value) {
  _internal_set_defuse_kit(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.defuse_kit)
}

// repeated .MLWeaponState weapons = 20;
inline int MLPlayerState::_internal_weapons_size() const {
  return _impl_.weapons_.size();
}
inline int MLPlayerState::weapons_size() const {
  return _internal_weapons_size();
}
inline void MLPlayerState::clear_weapons() {
  _impl_.weapons_.Clear();
}
inline ::MLWeaponState* MLPlayerState::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:MLPlayerState.weapons)
  return _impl_.weapons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLWeaponState >*
MLPlayerState::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:MLPlayerState.weapons)
  return &_impl_.weapons_;
}
inline const ::MLWeaponState& MLPlayerState::_internal_weapons(int index) const {
  return _impl_.weapons_.Get(index);
}
inline const ::MLWeaponState& MLPlayerState::weapons(int index) const {
  // @@protoc_insertion_point(field_get:MLPlayerState.weapons)
  return _internal_weapons(index);
}
inline ::MLWeaponState* MLPlayerState::_internal_add_weapons() {
  return _impl_.weapons_.Add();
}
inline ::MLWeaponState* MLPlayerState::add_weapons() {
  ::MLWeaponState* _add = _internal_add_weapons();
  // @@protoc_insertion_point(field_add:MLPlayerState.weapons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLWeaponState >&
MLPlayerState::weapons() const {
  // @@protoc_insertion_point(field_list:MLPlayerState.weapons)
  return _impl_.weapons_;
}

// -------------------------------------------------------------------

// MLGameState

// optional .MLMatchState match = 1;
inline bool MLGameState::_internal_has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline bool MLGameState::has_match() const {
  return _internal_has_match();
}
inline void MLGameState::clear_match() {
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLMatchState& MLGameState::_internal_match() const {
  const ::MLMatchState* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLMatchState&>(
      ::_MLMatchState_default_instance_);
}
inline const ::MLMatchState& MLGameState::match() const {
  // @@protoc_insertion_point(field_get:MLGameState.match)
  return _internal_match();
}
inline void MLGameState::unsafe_arena_set_allocated_match(
    ::MLMatchState* match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = match;
  if (match) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.match)
}
inline ::MLMatchState* MLGameState::release_match() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* temp = _impl_.match_;
  _impl_.match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MLMatchState* MLGameState::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_release:MLGameState.match)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::MLMatchState* MLGameState::_internal_mutable_match() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.match_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLMatchState>(GetArenaForAllocation());
    _impl_.match_ = p;
  }
  return _impl_.match_;
}
inline ::MLMatchState* MLGameState::mutable_match() {
  ::MLMatchState* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:MLGameState.match)
  return _msg;
}
inline void MLGameState::set_allocated_match(::MLMatchState* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.match_;
  }
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.match_ = match;
  // @@protoc_insertion_point(field_set_allocated:MLGameState.match)
}

// optional .MLRoundState round = 2;
inline bool MLGameState::_internal_has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.round_ != nullptr);
  return value;
}
inline bool MLGameState::has_round() const {
  return _internal_has_round();
}
inline void MLGameState::clear_round() {
  if (_impl_.round_ != nullptr) _impl_.round_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MLRoundState& MLGameState::_internal_round() const {
  const ::MLRoundState* p = _impl_.round_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLRoundState&>(
      ::_MLRoundState_default_instance_);
}
inline const ::MLRoundState& MLGameState::round() const {
  // @@protoc_insertion_point(field_get:MLGameState.round)
  return _internal_round();
}
inline void MLGameState::unsafe_arena_set_allocated_round(
    ::MLRoundState* round) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.round_);
  }
  _impl_.round_ = round;
  if (round) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.round)
}
inline ::MLRoundState* MLGameState::release_round() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* temp = _impl_.round_;
  _impl_.round_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MLRoundState* MLGameState::unsafe_arena_release_round() {
  // @@protoc_insertion_point(field_release:MLGameState.round)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* temp = _impl_.round_;
  _impl_.round_ = nullptr;
  return temp;
}
inline ::MLRoundState* MLGameState::_internal_mutable_round() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.round_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLRoundState>(GetArenaForAllocation());
    _impl_.round_ = p;
  }
  return _impl_.round_;
}
inline ::MLRoundState* MLGameState::mutable_round() {
  ::MLRoundState* _msg = _internal_mutable_round();
  // @@protoc_insertion_point(field_mutable:MLGameState.round)
  return _msg;
}
inline void MLGameState::set_allocated_round(::MLRoundState* round) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.round_;
  }
  if (round) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(round);
    if (message_arena != submessage_arena) {
      round = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, round, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.round_ = round;
  // @@protoc_insertion_point(field_set_allocated:MLGameState.round)
}

// repeated .MLPlayerState players = 3;
inline int MLGameState::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int MLGameState::players_size() const {
  return _internal_players_size();
}
inline void MLGameState::clear_players() {
  _impl_.players_.Clear();
}
inline ::MLPlayerState* MLGameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MLGameState.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLPlayerState >*
MLGameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MLGameState.players)
  return &_impl_.players_;
}
inline const ::MLPlayerState& MLGameState::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::MLPlayerState& MLGameState::players(int index) const {
  // @@protoc_insertion_point(field_get:MLGameState.players)
  return _internal_players(index);
}
inline ::MLPlayerState* MLGameState::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::MLPlayerState* MLGameState::add_players() {
  ::MLPlayerState* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:MLGameState.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLPlayerState >&
MLGameState::players() const {
  // @@protoc_insertion_point(field_list:MLGameState.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// MLDemoHeader

// optional string map_name = 1;
inline bool MLDemoHeader::_internal_has_map_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MLDemoHeader::has_map_name() const {
  return _internal_has_map_name();
}
inline void MLDemoHeader::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDemoHeader::map_name() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLDemoHeader::set_map_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.map_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDemoHeader.map_name)
}
inline std::string* MLDemoHeader::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:MLDemoHeader.map_name)
  return _s;
}
inline const std::string& MLDemoHeader::_internal_map_name() const {
  return _impl_.map_name_.Get();
}
inline void MLDemoHeader::_internal_set_map_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDemoHeader::_internal_mutable_map_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MLDemoHeader::release_map_name() {
  // @@protoc_insertion_point(field_release:MLDemoHeader.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.map_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MLDemoHeader::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_name_.SetAllocated(map_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDemoHeader.map_name)
}

// optional int32 tick_rate = 2;
inline bool MLDemoHeader::_internal_has_tick_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLDemoHeader::has_tick_rate() const {
  return _internal_has_tick_rate();
}
inline void MLDemoHeader::clear_tick_rate() {
  _impl_.tick_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MLDemoHeader::_internal_tick_rate() const {
  return _impl_.tick_rate_;
}
inline int32_t MLDemoHeader::tick_rate() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.tick_rate)
  return _internal_tick_rate();
}
inline void MLDemoHeader::_internal_set_tick_rate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tick_rate_ = value;
}
inline void MLDemoHeader::set_tick_rate(int32_t value) {
  _internal_set_tick_rate(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.tick_rate)
}

// optional uint32 version = 3;
inline bool MLDemoHeader::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MLDemoHeader::has_version() const {
  return _internal_has_version();
}
inline void MLDemoHeader::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MLDemoHeader::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t MLDemoHeader::version() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.version)
  return _internal_version();
}
inline void MLDemoHeader::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_ = value;
}
inline void MLDemoHeader::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.version)
}

// optional uint32 steam_universe = 4;
inline bool MLDemoHeader::_internal_has_steam_universe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MLDemoHeader::has_steam_universe() const {
  return _internal_has_steam_universe();
}
inline void MLDemoHeader::clear_steam_universe() {
  _impl_.steam_universe_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MLDemoHeader::_internal_steam_universe() const {
  return _impl_.steam_universe_;
}
inline uint32_t MLDemoHeader::steam_universe() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.steam_universe)
  return _internal_steam_universe();
}
inline void MLDemoHeader::_internal_set_steam_universe(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.steam_universe_ = value;
}
inline void MLDemoHeader::set_steam_universe(uint32_t value) {
  _internal_set_steam_universe(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.steam_universe)
}

// -------------------------------------------------------------------

// MLTick

// optional int32 tick_count = 1;
inline bool MLTick::_internal_has_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MLTick::has_tick_count() const {
  return _internal_has_tick_count();
}
inline void MLTick::clear_tick_count() {
  _impl_.tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MLTick::_internal_tick_count() const {
  return _impl_.tick_count_;
}
inline int32_t MLTick::tick_count() const {
  // @@protoc_insertion_point(field_get:MLTick.tick_count)
  return _internal_tick_count();
}
inline void MLTick::_internal_set_tick_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tick_count_ = value;
}
inline void MLTick::set_tick_count(int32_t value) {
  _internal_set_tick_count(value);
  // @@protoc_insertion_point(field_set:MLTick.tick_count)
}

// optional .MLGameState state = 2;
inline bool MLTick::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline bool MLTick::has_state() const {
  return _internal_has_state();
}
inline void MLTick::clear_state() {
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLGameState& MLTick::_internal_state() const {
  const ::MLGameState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLGameState&>(
      ::_MLGameState_default_instance_);
}
inline const ::MLGameState& MLTick::state() const {
  // @@protoc_insertion_point(field_get:MLTick.state)
  return _internal_state();
}
inline void MLTick::unsafe_arena_set_allocated_state(
    ::MLGameState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLTick.state)
}
inline ::MLGameState* MLTick::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MLGameState* MLTick::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:MLTick.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::MLGameState* MLTick::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLGameState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::MLGameState* MLTick::mutable_state() {
  ::MLGameState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLTick.state)
  return _msg;
}
inline void MLTick::set_allocated_state(::MLGameState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:MLTick.state)
}

// repeated .MLEvent events = 3;
inline int MLTick::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int MLTick::events_size() const {
  return _internal_events_size();
}
inline void MLTick::clear_events() {
  _impl_.events_.Clear();
}
inline ::MLEvent* MLTick::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:MLTick.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLEvent >*
MLTick::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:MLTick.events)
  return &_impl_.events_;
}
inline const ::MLEvent& MLTick::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::MLEvent& MLTick::events(int index) const {
  // @@protoc_insertion_point(field_get:MLTick.events)
  return _internal_events(index);
}
inline ::MLEvent* MLTick::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::MLEvent* MLTick::add_events() {
  ::MLEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:MLTick.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MLEvent >&
MLTick::events() const {
  // @@protoc_insertion_point(field_list:MLTick.events)
  return _impl_.events_;
}

// -------------------------------------------------------------------

// VacNetShot

// optional fixed64 steamid_player = 1;
inline bool VacNetShot::_internal_has_steamid_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VacNetShot::has_steamid_player() const {
  return _internal_has_steamid_player();
}
inline void VacNetShot::clear_steamid_player() {
  _impl_.steamid_player_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VacNetShot::_internal_steamid_player() const {
  return _impl_.steamid_player_;
}
inline uint64_t VacNetShot::steamid_player() const {
  // @@protoc_insertion_point(field_get:VacNetShot.steamid_player)
  return _internal_steamid_player();
}
inline void VacNetShot::_internal_set_steamid_player(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steamid_player_ = value;
}
inline void VacNetShot::set_steamid_player(uint64_t value) {
  _internal_set_steamid_player(value);
  // @@protoc_insertion_point(field_set:VacNetShot.steamid_player)
}

// optional int32 round_number = 2;
inline bool VacNetShot::_internal_has_round_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VacNetShot::has_round_number() const {
  return _internal_has_round_number();
}
inline void VacNetShot::clear_round_number() {
  _impl_.round_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VacNetShot::_internal_round_number() const {
  return _impl_.round_number_;
}
inline int32_t VacNetShot::round_number() const {
  // @@protoc_insertion_point(field_get:VacNetShot.round_number)
  return _internal_round_number();
}
inline void VacNetShot::_internal_set_round_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.round_number_ = value;
}
inline void VacNetShot::set_round_number(int32_t value) {
  _internal_set_round_number(value);
  // @@protoc_insertion_point(field_set:VacNetShot.round_number)
}

// optional int32 hit_type = 3;
inline bool VacNetShot::_internal_has_hit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VacNetShot::has_hit_type() const {
  return _internal_has_hit_type();
}
inline void VacNetShot::clear_hit_type() {
  _impl_.hit_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VacNetShot::_internal_hit_type() const {
  return _impl_.hit_type_;
}
inline int32_t VacNetShot::hit_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.hit_type)
  return _internal_hit_type();
}
inline void VacNetShot::_internal_set_hit_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hit_type_ = value;
}
inline void VacNetShot::set_hit_type(int32_t value) {
  _internal_set_hit_type(value);
  // @@protoc_insertion_point(field_set:VacNetShot.hit_type)
}

// optional int32 weapon_type = 4;
inline bool VacNetShot::_internal_has_weapon_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VacNetShot::has_weapon_type() const {
  return _internal_has_weapon_type();
}
inline void VacNetShot::clear_weapon_type() {
  _impl_.weapon_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t VacNetShot::_internal_weapon_type() const {
  return _impl_.weapon_type_;
}
inline int32_t VacNetShot::weapon_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.weapon_type)
  return _internal_weapon_type();
}
inline void VacNetShot::_internal_set_weapon_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.weapon_type_ = value;
}
inline void VacNetShot::set_weapon_type(int32_t value) {
  _internal_set_weapon_type(value);
  // @@protoc_insertion_point(field_set:VacNetShot.weapon_type)
}

// optional float distance_to_hurt_target = 5;
inline bool VacNetShot::_internal_has_distance_to_hurt_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VacNetShot::has_distance_to_hurt_target() const {
  return _internal_has_distance_to_hurt_target();
}
inline void VacNetShot::clear_distance_to_hurt_target() {
  _impl_.distance_to_hurt_target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VacNetShot::_internal_distance_to_hurt_target() const {
  return _impl_.distance_to_hurt_target_;
}
inline float VacNetShot::distance_to_hurt_target() const {
  // @@protoc_insertion_point(field_get:VacNetShot.distance_to_hurt_target)
  return _internal_distance_to_hurt_target();
}
inline void VacNetShot::_internal_set_distance_to_hurt_target(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.distance_to_hurt_target_ = value;
}
inline void VacNetShot::set_distance_to_hurt_target(float value) {
  _internal_set_distance_to_hurt_target(value);
  // @@protoc_insertion_point(field_set:VacNetShot.distance_to_hurt_target)
}

// repeated float delta_yaw_window = 6;
inline int VacNetShot::_internal_delta_yaw_window_size() const {
  return _impl_.delta_yaw_window_.size();
}
inline int VacNetShot::delta_yaw_window_size() const {
  return _internal_delta_yaw_window_size();
}
inline void VacNetShot::clear_delta_yaw_window() {
  _impl_.delta_yaw_window_.Clear();
}
inline float VacNetShot::_internal_delta_yaw_window(int index) const {
  return _impl_.delta_yaw_window_.Get(index);
}
inline float VacNetShot::delta_yaw_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window(index);
}
inline void VacNetShot::set_delta_yaw_window(int index, float value) {
  _impl_.delta_yaw_window_.Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_yaw_window)
}
inline void VacNetShot::_internal_add_delta_yaw_window(float value) {
  _impl_.delta_yaw_window_.Add(value);
}
inline void VacNetShot::add_delta_yaw_window(float value) {
  _internal_add_delta_yaw_window(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_yaw_window)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VacNetShot::_internal_delta_yaw_window() const {
  return _impl_.delta_yaw_window_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VacNetShot::delta_yaw_window() const {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VacNetShot::_internal_mutable_delta_yaw_window() {
  return &_impl_.delta_yaw_window_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VacNetShot::mutable_delta_yaw_window() {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_yaw_window)
  return _internal_mutable_delta_yaw_window();
}

// repeated float delta_pitch_window = 7;
inline int VacNetShot::_internal_delta_pitch_window_size() const {
  return _impl_.delta_pitch_window_.size();
}
inline int VacNetShot::delta_pitch_window_size() const {
  return _internal_delta_pitch_window_size();
}
inline void VacNetShot::clear_delta_pitch_window() {
  _impl_.delta_pitch_window_.Clear();
}
inline float VacNetShot::_internal_delta_pitch_window(int index) const {
  return _impl_.delta_pitch_window_.Get(index);
}
inline float VacNetShot::delta_pitch_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window(index);
}
inline void VacNetShot::set_delta_pitch_window(int index, float value) {
  _impl_.delta_pitch_window_.Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_pitch_window)
}
inline void VacNetShot::_internal_add_delta_pitch_window(float value) {
  _impl_.delta_pitch_window_.Add(value);
}
inline void VacNetShot::add_delta_pitch_window(float value) {
  _internal_add_delta_pitch_window(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_pitch_window)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VacNetShot::_internal_delta_pitch_window() const {
  return _impl_.delta_pitch_window_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VacNetShot::delta_pitch_window() const {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VacNetShot::_internal_mutable_delta_pitch_window() {
  return &_impl_.delta_pitch_window_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VacNetShot::mutable_delta_pitch_window() {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_pitch_window)
  return _internal_mutable_delta_pitch_window();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EHitGroup> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHitGroup>() {
  return ::EHitGroup_descriptor();
}
template <> struct is_proto_enum< ::ETeam> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETeam>() {
  return ::ETeam_descriptor();
}
template <> struct is_proto_enum< ::EWeaponType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EWeaponType>() {
  return ::EWeaponType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto
